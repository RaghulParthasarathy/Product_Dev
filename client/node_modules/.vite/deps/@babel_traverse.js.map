{
  "version": 3,
  "sources": ["../../@babel/traverse/src/path/lib/virtual-types.ts", "../../ms/index.js", "../../debug/src/common.js", "../../debug/src/browser.js", "../../@babel/traverse/src/path/lib/virtual-types-validator.ts", "../../@babel/traverse/src/visitors.ts", "../../@babel/traverse/src/scope/lib/renamer.ts", "../../@babel/traverse/src/scope/binding.ts", "../../@babel/traverse/node_modules/globals/globals.json", "../../@babel/traverse/node_modules/globals/index.js", "../../@babel/traverse/src/cache.ts", "../../@babel/traverse/src/scope/index.ts", "../../@babel/traverse/src/path/ancestry.ts", "../../@babel/traverse/src/path/inference/util.ts", "../../@babel/traverse/src/path/inference/inferer-reference.ts", "../../@babel/traverse/src/path/inference/inferers.ts", "../../@babel/traverse/src/path/inference/index.ts", "../../picocolors/picocolors.browser.js", "../../js-tokens/index.js", "../../@babel/code-frame/src/defs.ts", "../../@babel/code-frame/src/highlight.ts", "../../@babel/code-frame/src/index.ts", "../../@babel/traverse/src/path/lib/hoister.ts", "../../@babel/traverse/src/path/lib/removal-hooks.ts", "../../@babel/traverse/src/path/removal.ts", "../../@babel/traverse/src/path/modification.ts", "../../@babel/traverse/src/path/replacement.ts", "../../@babel/traverse/src/path/evaluation.ts", "../../@babel/template/src/formatters.ts", "../../@babel/template/src/options.ts", "../../@babel/template/src/parse.ts", "../../@babel/template/src/populate.ts", "../../@babel/template/src/string.ts", "../../@babel/template/src/literal.ts", "../../@babel/template/src/builder.ts", "../../@babel/template/src/index.ts", "../../@babel/traverse/src/path/conversion.ts", "../../@babel/traverse/src/path/introspection.ts", "../../@babel/traverse/src/path/family.ts", "../../@babel/traverse/src/path/comments.ts", "../../@babel/traverse/src/path/index.ts", "../../@babel/traverse/src/context.ts", "../../@babel/traverse/src/traverse-node.ts", "../../@babel/traverse/src/path/context.ts", "../../@babel/traverse/src/hub.ts", "../../@babel/traverse/src/index.ts"],
  "sourcesContent": ["import type * as t from \"@babel/types\";\n\nexport interface VirtualTypeAliases {\n  BindingIdentifier: t.Identifier;\n  BlockScoped: t.Node;\n  ExistentialTypeParam: t.ExistsTypeAnnotation;\n  Expression: t.Expression;\n  Flow: t.Flow | t.ImportDeclaration | t.ExportDeclaration | t.ImportSpecifier;\n  ForAwaitStatement: t.ForOfStatement;\n  Generated: t.Node;\n  NumericLiteralTypeAnnotation: t.NumberLiteralTypeAnnotation;\n  Pure: t.Node;\n  Referenced: t.Node;\n  ReferencedIdentifier: t.Identifier | t.JSXIdentifier;\n  ReferencedMemberExpression: t.MemberExpression;\n  RestProperty: t.RestElement;\n  Scope: t.Scopable | t.Pattern;\n  SpreadProperty: t.RestElement;\n  Statement: t.Statement;\n  User: t.Node;\n  Var: t.VariableDeclaration;\n}\n\ntype VirtualTypeMapping = readonly (t.Node[\"type\"] | keyof t.Aliases)[] | null;\n\nexport const ReferencedIdentifier: VirtualTypeMapping = [\n  \"Identifier\",\n  \"JSXIdentifier\",\n] as const;\n\nexport const ReferencedMemberExpression: VirtualTypeMapping = [\n  \"MemberExpression\",\n] as const;\n\nexport const BindingIdentifier: VirtualTypeMapping = [\"Identifier\"] as const;\n\nexport const Statement: VirtualTypeMapping = [\"Statement\"] as const;\n\nexport const Expression: VirtualTypeMapping = [\"Expression\"] as const;\n\nexport const Scope: VirtualTypeMapping = [\"Scopable\", \"Pattern\"] as const;\n\nexport const Referenced: VirtualTypeMapping = null;\n\nexport const BlockScoped: VirtualTypeMapping = null;\n\nexport const Var: VirtualTypeMapping = [\"VariableDeclaration\"];\n\nexport const User: VirtualTypeMapping = null;\n\nexport const Generated: VirtualTypeMapping = null;\n\nexport const Pure: VirtualTypeMapping = null;\n\nexport const Flow: VirtualTypeMapping = [\n  \"Flow\",\n  \"ImportDeclaration\",\n  \"ExportDeclaration\",\n  \"ImportSpecifier\",\n] as const;\n\n// TODO: 7.0 Backwards Compat\nexport const RestProperty: VirtualTypeMapping = [\"RestElement\"] as const;\n\nexport const SpreadProperty: VirtualTypeMapping = [\"RestElement\"] as const;\n\nexport const ExistentialTypeParam: VirtualTypeMapping = [\n  \"ExistsTypeAnnotation\",\n] as const;\n\nexport const NumericLiteralTypeAnnotation: VirtualTypeMapping = [\n  \"NumberLiteralTypeAnnotation\",\n] as const;\n\nexport const ForAwaitStatement: VirtualTypeMapping = [\n  \"ForOfStatement\",\n] as const;\n", "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n", "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n", "/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n", "import type NodePath from \"../index.ts\";\nimport {\n  isBinding,\n  isBlockScoped as nodeIsBlockScoped,\n  isExportDeclaration,\n  isExpression as nodeIsExpression,\n  isFlow as nodeIsFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isRestElement as nodeIsRestElement,\n  isReferenced as nodeIsReferenced,\n  isScope as nodeIsScope,\n  isStatement as nodeIsStatement,\n  isVar as nodeIsVar,\n  isVariableDeclaration,\n  react,\n  isForOfStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nconst { isCompatTag } = react;\nimport type { VirtualTypeAliases } from \"./virtual-types.ts\";\n\ntype Opts<Obj> = Partial<{\n  [Prop in keyof Obj]: Obj[Prop] extends t.Node\n    ? t.Node\n    : Obj[Prop] extends t.Node[]\n      ? t.Node[]\n      : Obj[Prop];\n}>;\n\nexport interface VirtualTypeNodePathValidators {\n  isBindingIdentifier(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"BindingIdentifier\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"BindingIdentifier\"]>;\n  isBlockScoped(opts?: Opts<VirtualTypeAliases[\"BlockScoped\"]>): boolean;\n  /**\n   * @deprecated\n   */\n  isExistentialTypeParam(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ExistentialTypeParam\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ExistentialTypeParam\"]>;\n  isExpression(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Expression\"]>,\n  ): this is NodePath<t.Expression>;\n  isFlow(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Flow\"]>,\n  ): this is NodePath<t.Flow>;\n  isForAwaitStatement(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ForAwaitStatement\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ForAwaitStatement\"]>;\n  isGenerated(opts?: VirtualTypeAliases[\"Generated\"]): boolean;\n  /**\n   * @deprecated\n   */\n  isNumericLiteralTypeAnnotation(\n    opts?: VirtualTypeAliases[\"NumericLiteralTypeAnnotation\"],\n  ): void;\n  isPure(opts?: VirtualTypeAliases[\"Pure\"]): boolean;\n  isReferenced(opts?: VirtualTypeAliases[\"Referenced\"]): boolean;\n  isReferencedIdentifier(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ReferencedIdentifier\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ReferencedIdentifier\"]>;\n  isReferencedMemberExpression(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"ReferencedMemberExpression\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"ReferencedMemberExpression\"]>;\n  isRestProperty(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"RestProperty\"]>,\n  ): this is NodePath<t.RestProperty>;\n  isScope(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Scope\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"Scope\"]>;\n  isSpreadProperty(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"SpreadProperty\"]>,\n  ): this is NodePath<t.SpreadProperty>;\n  isStatement(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Statement\"]>,\n  ): this is NodePath<t.Statement>;\n  isUser(opts?: VirtualTypeAliases[\"User\"]): boolean;\n  isVar(\n    this: NodePath,\n    opts?: Opts<VirtualTypeAliases[\"Var\"]>,\n  ): this is NodePath<VirtualTypeAliases[\"Var\"]>;\n}\n\nexport function isReferencedIdentifier(this: NodePath, opts?: any): boolean {\n  const { node, parent } = this;\n  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n    if (isJSXIdentifier(node, opts)) {\n      if (isCompatTag(node.name)) return false;\n    } else {\n      // not a JSXIdentifier or an Identifier\n      return false;\n    }\n  }\n\n  // check if node is referenced\n  return nodeIsReferenced(node, parent, this.parentPath.parent);\n}\n\nexport function isReferencedMemberExpression(this: NodePath): boolean {\n  const { node, parent } = this;\n  return isMemberExpression(node) && nodeIsReferenced(node, parent);\n}\n\nexport function isBindingIdentifier(this: NodePath): boolean {\n  const { node, parent } = this;\n  const grandparent = this.parentPath.parent;\n  return isIdentifier(node) && isBinding(node, parent, grandparent);\n}\n\nexport function isStatement(this: NodePath): boolean {\n  const { node, parent } = this;\n  if (nodeIsStatement(node)) {\n    if (isVariableDeclaration(node)) {\n      if (isForXStatement(parent, { left: node })) return false;\n      if (isForStatement(parent, { init: node })) return false;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function isExpression(this: NodePath): boolean {\n  if (this.isIdentifier()) {\n    return this.isReferencedIdentifier();\n  } else {\n    return nodeIsExpression(this.node);\n  }\n}\n\nexport function isScope(this: NodePath): boolean {\n  return nodeIsScope(this.node, this.parent);\n}\n\nexport function isReferenced(this: NodePath): boolean {\n  return nodeIsReferenced(this.node, this.parent);\n}\n\nexport function isBlockScoped(this: NodePath): boolean {\n  return nodeIsBlockScoped(this.node);\n}\n\nexport function isVar(this: NodePath): boolean {\n  return nodeIsVar(this.node);\n}\n\nexport function isUser(this: NodePath): boolean {\n  return this.node && !!this.node.loc;\n}\n\nexport function isGenerated(this: NodePath): boolean {\n  return !this.isUser();\n}\n\nexport function isPure(this: NodePath, constantsOnly?: boolean): boolean {\n  return this.scope.isPure(this.node, constantsOnly);\n}\n\nexport function isFlow(this: NodePath): boolean {\n  const { node } = this;\n  if (nodeIsFlow(node)) {\n    return true;\n  } else if (isImportDeclaration(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else if (isExportDeclaration(node)) {\n    return node.exportKind === \"type\";\n  } else if (isImportSpecifier(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else {\n    return false;\n  }\n}\n\n// TODO: 7.0 Backwards Compat\nexport function isRestProperty(this: NodePath): boolean {\n  return nodeIsRestElement(this.node) && this.parentPath?.isObjectPattern();\n}\n\nexport function isSpreadProperty(this: NodePath): boolean {\n  return nodeIsRestElement(this.node) && this.parentPath?.isObjectExpression();\n}\n\nexport function isForAwaitStatement(this: NodePath): boolean {\n  return isForOfStatement(this.node, { await: true });\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.isExistentialTypeParam = function isExistentialTypeParam(\n    this: NodePath,\n  ): void {\n    throw new Error(\n      \"`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.\",\n    );\n  };\n\n  // eslint-disable-next-line no-restricted-globals\n  exports.isNumericLiteralTypeAnnotation =\n    function isNumericLiteralTypeAnnotation(this: NodePath): void {\n      throw new Error(\n        \"`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.\",\n      );\n    };\n}\n", "import * as virtualTypes from \"./path/lib/virtual-types.ts\";\nimport * as virtualTypesValidators from \"./path/lib/virtual-types-validator.ts\";\nimport type { Node } from \"@babel/types\";\nimport {\n  DEPRECATED_KEYS,\n  DEPRECATED_ALIASES,\n  FLIPPED_ALIAS_KEYS,\n  TYPES,\n  __internal__deprecationWarning as deprecationWarning,\n} from \"@babel/types\";\nimport type { ExplodedVisitor, NodePath, Visitor } from \"./index.ts\";\nimport type { ExplVisitNode, VisitNodeFunction, VisitPhase } from \"./types.ts\";\nimport { requeueComputedKeyAndDecorators } from \"./path/context.ts\";\n\ntype VIRTUAL_TYPES = keyof typeof virtualTypes;\nfunction isVirtualType(type: string): type is VIRTUAL_TYPES {\n  return type in virtualTypes;\n}\nexport type VisitWrapper<S = any> = (\n  stateName: string | undefined,\n  visitorType: VisitPhase,\n  callback: VisitNodeFunction<S, Node>,\n) => VisitNodeFunction<S, Node>;\n\nexport function isExplodedVisitor(\n  visitor: Visitor,\n): visitor is ExplodedVisitor {\n  // @ts-expect-error _exploded is not defined on non-exploded Visitor\n  return visitor?._exploded;\n}\n\n// We need to name this function `explode$1` because otherwise rollup-plugin-dts\n// will generate a `namespace traverse { var explode: typeof explode; }` when\n// bundling @babel/traverse's index.d.ts.\n// TODO: Just call it `explode` once https://github.com/Swatinem/rollup-plugin-dts/issues/307\n// is fixed.\nexport { explode$1 as explode };\n/**\n * explode() will take a visitor object with all of the various shorthands\n * that we support, and validates & normalizes it into a common format, ready\n * to be used in traversal\n *\n * The various shorthands are:\n * * `Identifier() { ... }` -> `Identifier: { enter() { ... } }`\n * * `\"Identifier|NumericLiteral\": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`\n * * Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`\n * Other normalizations are:\n * * Visitors of virtual types are wrapped, so that they are only visited when\n *   their dynamic check passes\n * * `enter` and `exit` functions are wrapped in arrays, to ease merging of\n *   visitors\n */\nfunction explode$1<S>(visitor: Visitor<S>): ExplodedVisitor<S> {\n  if (isExplodedVisitor(visitor)) return visitor;\n  // @ts-expect-error `visitor` will be cast to ExplodedVisitor by this function\n  visitor._exploded = true;\n\n  // normalise pipes\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    const parts: Array<string> = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      // @ts-expect-error part will be verified by `verify` later\n      visitor[part] = fns;\n    }\n  }\n\n  // verify data structure\n  verify$1(visitor);\n\n  // make sure there's no __esModule type since this is because we're using loose mode\n  // and it sets __esModule to be enumerable on all modules :(\n  // @ts-expect-error ESModule interop\n  delete visitor.__esModule;\n\n  // ensure visitors are objects\n  ensureEntranceObjects(visitor);\n\n  // ensure enter/exit callbacks are arrays\n  ensureCallbackArrays(visitor);\n\n  // add type wrappers\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (!isVirtualType(nodeType)) continue;\n\n    // wrap all the functions\n    const fns = visitor[nodeType];\n    for (const type of Object.keys(fns)) {\n      // @ts-expect-error normalised as VisitNodeObject\n      fns[type] = wrapCheck(nodeType, fns[type]);\n    }\n\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    const types = virtualTypes[nodeType];\n    if (types !== null) {\n      for (const type of types) {\n        // merge the visitor if necessary or just put it back in\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          // @ts-expect-error Expression produces too complex union\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  // add aliases\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n\n    if (nodeType in DEPRECATED_KEYS) {\n      const deprecatedKey = DEPRECATED_KEYS[nodeType];\n      deprecationWarning(nodeType, deprecatedKey, \"Visitor \");\n      aliases = [deprecatedKey];\n    } else if (nodeType in DEPRECATED_ALIASES) {\n      const deprecatedAlias =\n        DEPRECATED_ALIASES[nodeType as keyof typeof DEPRECATED_ALIASES];\n      deprecationWarning(nodeType, deprecatedAlias, \"Visitor \");\n      aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];\n    }\n\n    if (!aliases) continue;\n\n    const fns = visitor[nodeType];\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = { ...fns };\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    ensureCallbackArrays(\n      // @ts-expect-error nodeType must present in visitor after previous validations\n      visitor[nodeType],\n    );\n  }\n\n  // @ts-expect-error explosion has been performed\n  return visitor as ExplodedVisitor;\n}\n\n// We need to name this function `verify$1` because otherwise rollup-plugin-dts\n// will generate a `namespace traverse { var verify: typeof verify; }` when\n// bundling @babel/traverse's index.d.ts.\n// TODO: Just call it `verify` once https://github.com/Swatinem/rollup-plugin-dts/issues/307\n// is fixed.\nexport { verify$1 as verify };\nfunction verify$1(visitor: Visitor) {\n  // @ts-expect-error _verified is not defined on non-verified Visitor.\n  // TODO: unify _verified and _exploded.\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\n      \"You passed `traverse()` a function when it expected a visitor object, \" +\n        \"are you sure you didn't mean `{ enter: Function }`?\",\n    );\n  }\n\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (!TYPES.includes(nodeType)) {\n      throw new Error(\n        `You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${PACKAGE_JSON.version}`,\n      );\n    }\n\n    const visitors = visitor[nodeType];\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          // verify that it just contains functions\n          validateVisitorMethods(\n            `${nodeType}.${visitorKey}`,\n            visitors[visitorKey],\n          );\n        } else {\n          throw new Error(\n            \"You passed `traverse()` a visitor object with the property \" +\n              `${nodeType} that has the invalid property ${visitorKey}`,\n          );\n        }\n      }\n    }\n  }\n\n  // @ts-expect-error _verified is not defined on non-verified Visitor.\n  // TODO: unify _verified and _exploded.\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(\n  path: string,\n  val: any,\n): asserts val is Function | Function[] {\n  const fns = [].concat(val);\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\n        `Non-function found defined in ${path} with type ${typeof fn}`,\n      );\n    }\n  }\n}\n\nexport function merge<State>(\n  visitors: Visitor<State>[],\n): ExplodedVisitor<State>;\nexport function merge(\n  visitors: Visitor<unknown>[],\n  states?: any[],\n  wrapper?: Function | null,\n): ExplodedVisitor<unknown>;\nexport function merge(\n  visitors: any[],\n  states: any[] = [],\n  wrapper?: VisitWrapper | null,\n): ExplodedVisitor {\n  const mergedVisitor: ExplodedVisitor = { _verified: true, _exploded: true };\n  if (!process.env.BABEL_8_BREAKING) {\n    // For compatibility with old Babel versions, we must hide _verified and _exploded.\n    // Otherwise, old versions of the validator will throw sayng that `true` is not\n    // a function, because it tries to validate it as a visitor.\n    Object.defineProperty(mergedVisitor, \"_exploded\", { enumerable: false });\n    Object.defineProperty(mergedVisitor, \"_verified\", { enumerable: false });\n  }\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = explode$1(visitors[i]);\n    const state = states[i];\n\n    let topVisitor: ExplVisitNode<unknown, Node> = visitor;\n    if (state || wrapper) {\n      topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);\n    }\n    mergePair(mergedVisitor, topVisitor);\n\n    for (const key of Object.keys(visitor) as (keyof ExplodedVisitor)[]) {\n      if (shouldIgnoreKey(key)) continue;\n\n      let typeVisitor = visitor[key];\n\n      // if we have state or wrapper then overload the callbacks to take it\n      if (state || wrapper) {\n        typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);\n      }\n\n      const nodeVisitor = (mergedVisitor[key] ||= {});\n      mergePair(nodeVisitor, typeVisitor);\n    }\n  }\n\n  return mergedVisitor;\n}\n\nfunction wrapWithStateOrWrapper<State>(\n  oldVisitor: ExplVisitNode<State, Node>,\n  state: State | null,\n  wrapper?: VisitWrapper<State> | null,\n): ExplVisitNode<State, Node> {\n  const newVisitor: ExplVisitNode<State, Node> = {};\n\n  for (const phase of [\"enter\", \"exit\"] as VisitPhase[]) {\n    let fns = oldVisitor[phase];\n\n    // not an enter/exit array of callbacks\n    if (!Array.isArray(fns)) continue;\n\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path: NodePath) {\n          fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        // @ts-expect-error Fixme: actually PluginPass.key (aka pluginAlias)?\n        newFn = wrapper(state?.key, phase, newFn);\n      }\n\n      // Override toString in case this function is printed, we want to print the wrapped function, same as we do in `wrapCheck`\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n\n    newVisitor[phase] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj: Visitor) {\n  for (const key of Object.keys(obj) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(key)) continue;\n\n    const fns = obj[key];\n    if (typeof fns === \"function\") {\n      // @ts-expect-error: Expression produces a union type that is too complex to represent.\n      obj[key] = { enter: fns };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj: Visitor) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(nodeType: VIRTUAL_TYPES, fn: Function) {\n  const fnKey = `is${nodeType}`;\n  // @ts-expect-error we know virtualTypesValidators will contain `fnKey`, but TS doesn't\n  const validator = virtualTypesValidators[fnKey];\n  const newFn = function (this: unknown, path: NodePath) {\n    if (validator.call(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n  newFn.toString = () => fn.toString();\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key: string): key is\n  | `_${string}` // ` // Comment to fix syntax highlighting in vscode\n  | \"enter\"\n  | \"exit\"\n  | \"shouldSkip\"\n  | \"denylist\"\n  | \"noScope\"\n  | \"skipKeys\"\n  | \"blacklist\" {\n  // internal/hidden key\n  if (key[0] === \"_\") return true;\n\n  // ignore function keys\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  // ignore other options\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\") {\n    return true;\n  }\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (key === \"blacklist\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/*\nfunction mergePair(\n  dest: ExplVisitNode<unknown, Node>,\n  src: ExplVisitNode<unknown, Node>,\n);\n*/\nfunction mergePair(dest: any, src: any) {\n  for (const phase of [\"enter\", \"exit\"] as VisitPhase[]) {\n    if (!src[phase]) continue;\n    dest[phase] = [].concat(dest[phase] || [], src[phase]);\n  }\n}\n\n// environmentVisitor should be used when traversing the whole class and not for specific class elements/methods.\n// For perf reasons, the environmentVisitor might be traversed with `{ noScope: true }`, which means `path.scope` is undefined.\n// Avoid using `path.scope` here\nconst _environmentVisitor: Visitor = {\n  FunctionParent(path) {\n    // arrows are not skipped because they inherit the context.\n    if (path.isArrowFunctionExpression()) return;\n\n    path.skip();\n    if (path.isMethod()) {\n      if (\n        !process.env.BABEL_8_BREAKING &&\n        !path.requeueComputedKeyAndDecorators\n      ) {\n        // See https://github.com/babel/babel/issues/16694\n        requeueComputedKeyAndDecorators.call(path);\n      } else {\n        path.requeueComputedKeyAndDecorators();\n      }\n    }\n  },\n  Property(path) {\n    if (path.isObjectProperty()) return;\n    path.skip();\n    if (\n      !process.env.BABEL_8_BREAKING &&\n      !path.requeueComputedKeyAndDecorators\n    ) {\n      // See https://github.com/babel/babel/issues/16694\n      requeueComputedKeyAndDecorators.call(path);\n    } else {\n      path.requeueComputedKeyAndDecorators();\n    }\n  },\n};\n\nexport function environmentVisitor<S>(visitor: Visitor<S>): Visitor<S> {\n  return merge([_environmentVisitor, visitor]);\n}\n", "import type Binding from \"../binding.ts\";\nimport * as t from \"@babel/types\";\nimport type { NodePath, Visitor } from \"../../index.ts\";\nimport { traverseNode } from \"../../traverse-node.ts\";\nimport { explode } from \"../../visitors.ts\";\nimport { getAssignmentIdentifiers, type Identifier } from \"@babel/types\";\nimport { requeueComputedKeyAndDecorators } from \"../../path/context.ts\";\n\nconst renameVisitor: Visitor<Renamer> = {\n  ReferencedIdentifier({ node }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (\n      !path.scope.bindingIdentifierEquals(\n        state.oldName,\n        state.binding.identifier,\n      )\n    ) {\n      path.skip();\n      if (path.isMethod()) {\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          !path.requeueComputedKeyAndDecorators\n        ) {\n          // See https://github.com/babel/babel/issues/16694\n          requeueComputedKeyAndDecorators.call(path);\n        } else {\n          path.requeueComputedKeyAndDecorators();\n        }\n      }\n    }\n  },\n\n  ObjectProperty({ node, scope }, state) {\n    const { name } = node.key as Identifier;\n    if (\n      node.shorthand &&\n      // In destructuring the identifier is already renamed by the\n      // AssignmentExpression|Declaration|VariableDeclarator visitor,\n      // while in object literals it's renamed later by the\n      // ReferencedIdentifier visitor.\n      (name === state.oldName || name === state.newName) &&\n      // Ignore shadowed bindings\n      scope.getBindingIdentifier(name) === state.binding.identifier\n    ) {\n      node.shorthand = false;\n      if (!process.env.BABEL_8_BREAKING) {\n        if (node.extra?.shorthand) node.extra.shorthand = false;\n      }\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(\n    path: NodePath<\n      t.AssignmentExpression | t.Declaration | t.VariableDeclarator\n    >,\n    state,\n  ) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.isAssignmentExpression()\n      ? // See https://github.com/babel/babel/issues/16694\n        getAssignmentIdentifiers(path.node)\n      : path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  },\n};\n\nexport default class Renamer {\n  constructor(binding: Binding, oldName: string, newName: string) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  declare oldName: string;\n  declare newName: string;\n  declare binding: Binding;\n\n  maybeConvertFromExportDeclaration(parentDeclar: NodePath) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration()) {\n      const { declaration } = maybeExportDeclar.node;\n      if (t.isDeclaration(declaration) && !declaration.id) {\n        return;\n      }\n    }\n\n    if (maybeExportDeclar.isExportAllDeclaration()) {\n      return;\n    }\n\n    maybeExportDeclar.splitExportDeclaration();\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function declaration\n\n    // if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    // if (this.binding.kind !== \"hoisted\") return;\n\n    // path.node.id = identifier(this.oldName);\n    // path.node._blockHoist = 3;\n\n    // path.replaceWith(\n    //   variableDeclaration(\"let\", [\n    //     variableDeclarator(identifier(this.newName), toExpression(path.node)),\n    //   ]),\n    // );\n  }\n\n  maybeConvertFromClassFunctionExpression(path: NodePath) {\n    return path; // TODO\n\n    // // retain the `name` of a class/function expression\n\n    // if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    // if (this.binding.kind !== \"local\") return;\n\n    // path.node.id = identifier(this.oldName);\n\n    // this.binding.scope.parent.push({\n    //   id: identifier(this.newName),\n    // });\n\n    // path.replaceWith(\n    //   assignmentExpression(\"=\", identifier(this.newName), path.node),\n    // );\n  }\n\n  rename(/* Babel 7 - block?: t.Pattern | t.Scopable */) {\n    const { binding, oldName, newName } = this;\n    const { scope, path } = binding;\n\n    const parentDeclar = path.find(\n      path =>\n        path.isDeclaration() ||\n        path.isFunctionExpression() ||\n        path.isClassExpression(),\n    );\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n      if (bindingIds[oldName] === binding.identifier) {\n        // When we are renaming an exported identifier, we need to ensure that\n        // the exported binding keeps the old name.\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = process.env.BABEL_8_BREAKING\n      ? scope.block\n      : (arguments[0] as t.Pattern | t.Scopable) || scope.block;\n\n    // When blockToTraverse is a SwitchStatement, the discriminant\n    // is not part of the current scope and thus should be skipped.\n\n    // const foo = {\n    //   get [x]() {\n    //     return x;\n    //   },\n    // };\n    const skipKeys: Record<string, true> = { discriminant: true };\n    if (t.isMethod(blockToTraverse)) {\n      if (blockToTraverse.computed) {\n        skipKeys.key = true;\n      }\n      if (!t.isObjectMethod(blockToTraverse)) {\n        skipKeys.decorators = true;\n      }\n    }\n\n    traverseNode(\n      blockToTraverse,\n      explode(renameVisitor),\n      scope,\n      this,\n      scope.path,\n      skipKeys,\n    );\n\n    if (process.env.BABEL_8_BREAKING) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    } else if (!arguments[0]) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(path);\n      this.maybeConvertFromClassFunctionExpression(path);\n    }\n  }\n}\n", "import type NodePath from \"../path/index.ts\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"./index.ts\";\n\nexport type BindingKind =\n  | \"var\" /* var declarator */\n  | \"let\" /* let declarator, class declaration id, catch clause parameters */\n  | \"const\" /* const/using declarator */\n  | \"module\" /* import specifiers */\n  | \"hoisted\" /* function declaration id */\n  | \"param\" /* function declaration parameters */\n  | \"local\" /* function expression id, class expression id */\n  | \"unknown\"; /* export specifiers */\n/**\n * This class is responsible for a binding inside of a scope.\n *\n * It tracks the following:\n *\n *  * Node path.\n *  * Amount of times referenced by other nodes.\n *  * Paths to nodes that reassign or modify this binding.\n *  * The kind of binding. (Is it a parameter, declaration etc)\n */\n\nexport default class Binding {\n  identifier: t.Identifier;\n  scope: Scope;\n  path: NodePath;\n  kind: BindingKind;\n\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind,\n  }: {\n    identifier: t.Identifier;\n    scope: Scope;\n    path: NodePath;\n    kind: BindingKind;\n  }) {\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n\n    if ((kind === \"var\" || kind === \"hoisted\") && isDeclaredInLoop(path)) {\n      this.reassign(path);\n    }\n\n    this.clearValue();\n  }\n\n  constantViolations: Array<NodePath> = [];\n  constant: boolean = true;\n\n  referencePaths: Array<NodePath> = [];\n  referenced: boolean = false;\n  references: number = 0;\n\n  declare hasDeoptedValue: boolean;\n  declare hasValue: boolean;\n  declare value: any;\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value: any) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  /**\n   * Register a constant violation with the provided `path`.\n   */\n\n  reassign(path: NodePath) {\n    this.constant = false;\n    if (this.constantViolations.includes(path)) {\n      return;\n    }\n    this.constantViolations.push(path);\n  }\n\n  /**\n   * Increment the amount of references to this binding.\n   */\n\n  reference(path: NodePath) {\n    if (this.referencePaths.includes(path)) {\n      return;\n    }\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  /**\n   * Decrement the amount of references to this binding.\n   */\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n}\n\nfunction isDeclaredInLoop(path: NodePath) {\n  for (\n    let { parentPath, key } = path;\n    parentPath;\n    { parentPath, key } = parentPath\n  ) {\n    if (parentPath.isFunctionParent()) return false;\n    if (\n      parentPath.isWhile() ||\n      parentPath.isForXStatement() ||\n      (parentPath.isForStatement() && key === \"body\")\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n", "{\n\t\"builtin\": {\n\t\t\"Array\": false,\n\t\t\"ArrayBuffer\": false,\n\t\t\"Atomics\": false,\n\t\t\"BigInt\": false,\n\t\t\"BigInt64Array\": false,\n\t\t\"BigUint64Array\": false,\n\t\t\"Boolean\": false,\n\t\t\"constructor\": false,\n\t\t\"DataView\": false,\n\t\t\"Date\": false,\n\t\t\"decodeURI\": false,\n\t\t\"decodeURIComponent\": false,\n\t\t\"encodeURI\": false,\n\t\t\"encodeURIComponent\": false,\n\t\t\"Error\": false,\n\t\t\"escape\": false,\n\t\t\"eval\": false,\n\t\t\"EvalError\": false,\n\t\t\"Float32Array\": false,\n\t\t\"Float64Array\": false,\n\t\t\"Function\": false,\n\t\t\"globalThis\": false,\n\t\t\"hasOwnProperty\": false,\n\t\t\"Infinity\": false,\n\t\t\"Int16Array\": false,\n\t\t\"Int32Array\": false,\n\t\t\"Int8Array\": false,\n\t\t\"isFinite\": false,\n\t\t\"isNaN\": false,\n\t\t\"isPrototypeOf\": false,\n\t\t\"JSON\": false,\n\t\t\"Map\": false,\n\t\t\"Math\": false,\n\t\t\"NaN\": false,\n\t\t\"Number\": false,\n\t\t\"Object\": false,\n\t\t\"parseFloat\": false,\n\t\t\"parseInt\": false,\n\t\t\"Promise\": false,\n\t\t\"propertyIsEnumerable\": false,\n\t\t\"Proxy\": false,\n\t\t\"RangeError\": false,\n\t\t\"ReferenceError\": false,\n\t\t\"Reflect\": false,\n\t\t\"RegExp\": false,\n\t\t\"Set\": false,\n\t\t\"SharedArrayBuffer\": false,\n\t\t\"String\": false,\n\t\t\"Symbol\": false,\n\t\t\"SyntaxError\": false,\n\t\t\"toLocaleString\": false,\n\t\t\"toString\": false,\n\t\t\"TypeError\": false,\n\t\t\"Uint16Array\": false,\n\t\t\"Uint32Array\": false,\n\t\t\"Uint8Array\": false,\n\t\t\"Uint8ClampedArray\": false,\n\t\t\"undefined\": false,\n\t\t\"unescape\": false,\n\t\t\"URIError\": false,\n\t\t\"valueOf\": false,\n\t\t\"WeakMap\": false,\n\t\t\"WeakSet\": false\n\t},\n\t\"es5\": {\n\t\t\"Array\": false,\n\t\t\"Boolean\": false,\n\t\t\"constructor\": false,\n\t\t\"Date\": false,\n\t\t\"decodeURI\": false,\n\t\t\"decodeURIComponent\": false,\n\t\t\"encodeURI\": false,\n\t\t\"encodeURIComponent\": false,\n\t\t\"Error\": false,\n\t\t\"escape\": false,\n\t\t\"eval\": false,\n\t\t\"EvalError\": false,\n\t\t\"Function\": false,\n\t\t\"hasOwnProperty\": false,\n\t\t\"Infinity\": false,\n\t\t\"isFinite\": false,\n\t\t\"isNaN\": false,\n\t\t\"isPrototypeOf\": false,\n\t\t\"JSON\": false,\n\t\t\"Math\": false,\n\t\t\"NaN\": false,\n\t\t\"Number\": false,\n\t\t\"Object\": false,\n\t\t\"parseFloat\": false,\n\t\t\"parseInt\": false,\n\t\t\"propertyIsEnumerable\": false,\n\t\t\"RangeError\": false,\n\t\t\"ReferenceError\": false,\n\t\t\"RegExp\": false,\n\t\t\"String\": false,\n\t\t\"SyntaxError\": false,\n\t\t\"toLocaleString\": false,\n\t\t\"toString\": false,\n\t\t\"TypeError\": false,\n\t\t\"undefined\": false,\n\t\t\"unescape\": false,\n\t\t\"URIError\": false,\n\t\t\"valueOf\": false\n\t},\n\t\"es2015\": {\n\t\t\"Array\": false,\n\t\t\"ArrayBuffer\": false,\n\t\t\"Boolean\": false,\n\t\t\"constructor\": false,\n\t\t\"DataView\": false,\n\t\t\"Date\": false,\n\t\t\"decodeURI\": false,\n\t\t\"decodeURIComponent\": false,\n\t\t\"encodeURI\": false,\n\t\t\"encodeURIComponent\": false,\n\t\t\"Error\": false,\n\t\t\"escape\": false,\n\t\t\"eval\": false,\n\t\t\"EvalError\": false,\n\t\t\"Float32Array\": false,\n\t\t\"Float64Array\": false,\n\t\t\"Function\": false,\n\t\t\"hasOwnProperty\": false,\n\t\t\"Infinity\": false,\n\t\t\"Int16Array\": false,\n\t\t\"Int32Array\": false,\n\t\t\"Int8Array\": false,\n\t\t\"isFinite\": false,\n\t\t\"isNaN\": false,\n\t\t\"isPrototypeOf\": false,\n\t\t\"JSON\": false,\n\t\t\"Map\": false,\n\t\t\"Math\": false,\n\t\t\"NaN\": false,\n\t\t\"Number\": false,\n\t\t\"Object\": false,\n\t\t\"parseFloat\": false,\n\t\t\"parseInt\": false,\n\t\t\"Promise\": false,\n\t\t\"propertyIsEnumerable\": false,\n\t\t\"Proxy\": false,\n\t\t\"RangeError\": false,\n\t\t\"ReferenceError\": false,\n\t\t\"Reflect\": false,\n\t\t\"RegExp\": false,\n\t\t\"Set\": false,\n\t\t\"String\": false,\n\t\t\"Symbol\": false,\n\t\t\"SyntaxError\": false,\n\t\t\"toLocaleString\": false,\n\t\t\"toString\": false,\n\t\t\"TypeError\": false,\n\t\t\"Uint16Array\": false,\n\t\t\"Uint32Array\": false,\n\t\t\"Uint8Array\": false,\n\t\t\"Uint8ClampedArray\": false,\n\t\t\"undefined\": false,\n\t\t\"unescape\": false,\n\t\t\"URIError\": false,\n\t\t\"valueOf\": false,\n\t\t\"WeakMap\": false,\n\t\t\"WeakSet\": false\n\t},\n\t\"es2017\": {\n\t\t\"Array\": false,\n\t\t\"ArrayBuffer\": false,\n\t\t\"Atomics\": false,\n\t\t\"Boolean\": false,\n\t\t\"constructor\": false,\n\t\t\"DataView\": false,\n\t\t\"Date\": false,\n\t\t\"decodeURI\": false,\n\t\t\"decodeURIComponent\": false,\n\t\t\"encodeURI\": false,\n\t\t\"encodeURIComponent\": false,\n\t\t\"Error\": false,\n\t\t\"escape\": false,\n\t\t\"eval\": false,\n\t\t\"EvalError\": false,\n\t\t\"Float32Array\": false,\n\t\t\"Float64Array\": false,\n\t\t\"Function\": false,\n\t\t\"hasOwnProperty\": false,\n\t\t\"Infinity\": false,\n\t\t\"Int16Array\": false,\n\t\t\"Int32Array\": false,\n\t\t\"Int8Array\": false,\n\t\t\"isFinite\": false,\n\t\t\"isNaN\": false,\n\t\t\"isPrototypeOf\": false,\n\t\t\"JSON\": false,\n\t\t\"Map\": false,\n\t\t\"Math\": false,\n\t\t\"NaN\": false,\n\t\t\"Number\": false,\n\t\t\"Object\": false,\n\t\t\"parseFloat\": false,\n\t\t\"parseInt\": false,\n\t\t\"Promise\": false,\n\t\t\"propertyIsEnumerable\": false,\n\t\t\"Proxy\": false,\n\t\t\"RangeError\": false,\n\t\t\"ReferenceError\": false,\n\t\t\"Reflect\": false,\n\t\t\"RegExp\": false,\n\t\t\"Set\": false,\n\t\t\"SharedArrayBuffer\": false,\n\t\t\"String\": false,\n\t\t\"Symbol\": false,\n\t\t\"SyntaxError\": false,\n\t\t\"toLocaleString\": false,\n\t\t\"toString\": false,\n\t\t\"TypeError\": false,\n\t\t\"Uint16Array\": false,\n\t\t\"Uint32Array\": false,\n\t\t\"Uint8Array\": false,\n\t\t\"Uint8ClampedArray\": false,\n\t\t\"undefined\": false,\n\t\t\"unescape\": false,\n\t\t\"URIError\": false,\n\t\t\"valueOf\": false,\n\t\t\"WeakMap\": false,\n\t\t\"WeakSet\": false\n\t},\n\t\"browser\": {\n\t\t\"AbortController\": false,\n\t\t\"AbortSignal\": false,\n\t\t\"addEventListener\": false,\n\t\t\"alert\": false,\n\t\t\"AnalyserNode\": false,\n\t\t\"Animation\": false,\n\t\t\"AnimationEffectReadOnly\": false,\n\t\t\"AnimationEffectTiming\": false,\n\t\t\"AnimationEffectTimingReadOnly\": false,\n\t\t\"AnimationEvent\": false,\n\t\t\"AnimationPlaybackEvent\": false,\n\t\t\"AnimationTimeline\": false,\n\t\t\"applicationCache\": false,\n\t\t\"ApplicationCache\": false,\n\t\t\"ApplicationCacheErrorEvent\": false,\n\t\t\"atob\": false,\n\t\t\"Attr\": false,\n\t\t\"Audio\": false,\n\t\t\"AudioBuffer\": false,\n\t\t\"AudioBufferSourceNode\": false,\n\t\t\"AudioContext\": false,\n\t\t\"AudioDestinationNode\": false,\n\t\t\"AudioListener\": false,\n\t\t\"AudioNode\": false,\n\t\t\"AudioParam\": false,\n\t\t\"AudioProcessingEvent\": false,\n\t\t\"AudioScheduledSourceNode\": false,\n\t\t\"AudioWorkletGlobalScope \": false,\n\t\t\"AudioWorkletNode\": false,\n\t\t\"AudioWorkletProcessor\": false,\n\t\t\"BarProp\": false,\n\t\t\"BaseAudioContext\": false,\n\t\t\"BatteryManager\": false,\n\t\t\"BeforeUnloadEvent\": false,\n\t\t\"BiquadFilterNode\": false,\n\t\t\"Blob\": false,\n\t\t\"BlobEvent\": false,\n\t\t\"blur\": false,\n\t\t\"BroadcastChannel\": false,\n\t\t\"btoa\": false,\n\t\t\"BudgetService\": false,\n\t\t\"ByteLengthQueuingStrategy\": false,\n\t\t\"Cache\": false,\n\t\t\"caches\": false,\n\t\t\"CacheStorage\": false,\n\t\t\"cancelAnimationFrame\": false,\n\t\t\"cancelIdleCallback\": false,\n\t\t\"CanvasCaptureMediaStreamTrack\": false,\n\t\t\"CanvasGradient\": false,\n\t\t\"CanvasPattern\": false,\n\t\t\"CanvasRenderingContext2D\": false,\n\t\t\"ChannelMergerNode\": false,\n\t\t\"ChannelSplitterNode\": false,\n\t\t\"CharacterData\": false,\n\t\t\"clearInterval\": false,\n\t\t\"clearTimeout\": false,\n\t\t\"clientInformation\": false,\n\t\t\"ClipboardEvent\": false,\n\t\t\"close\": false,\n\t\t\"closed\": false,\n\t\t\"CloseEvent\": false,\n\t\t\"Comment\": false,\n\t\t\"CompositionEvent\": false,\n\t\t\"confirm\": false,\n\t\t\"console\": false,\n\t\t\"ConstantSourceNode\": false,\n\t\t\"ConvolverNode\": false,\n\t\t\"CountQueuingStrategy\": false,\n\t\t\"createImageBitmap\": false,\n\t\t\"Credential\": false,\n\t\t\"CredentialsContainer\": false,\n\t\t\"crypto\": false,\n\t\t\"Crypto\": false,\n\t\t\"CryptoKey\": false,\n\t\t\"CSS\": false,\n\t\t\"CSSConditionRule\": false,\n\t\t\"CSSFontFaceRule\": false,\n\t\t\"CSSGroupingRule\": false,\n\t\t\"CSSImportRule\": false,\n\t\t\"CSSKeyframeRule\": false,\n\t\t\"CSSKeyframesRule\": false,\n\t\t\"CSSMediaRule\": false,\n\t\t\"CSSNamespaceRule\": false,\n\t\t\"CSSPageRule\": false,\n\t\t\"CSSRule\": false,\n\t\t\"CSSRuleList\": false,\n\t\t\"CSSStyleDeclaration\": false,\n\t\t\"CSSStyleRule\": false,\n\t\t\"CSSStyleSheet\": false,\n\t\t\"CSSSupportsRule\": false,\n\t\t\"CustomElementRegistry\": false,\n\t\t\"customElements\": false,\n\t\t\"CustomEvent\": false,\n\t\t\"DataTransfer\": false,\n\t\t\"DataTransferItem\": false,\n\t\t\"DataTransferItemList\": false,\n\t\t\"defaultstatus\": false,\n\t\t\"defaultStatus\": false,\n\t\t\"DelayNode\": false,\n\t\t\"DeviceMotionEvent\": false,\n\t\t\"DeviceOrientationEvent\": false,\n\t\t\"devicePixelRatio\": false,\n\t\t\"dispatchEvent\": false,\n\t\t\"document\": false,\n\t\t\"Document\": false,\n\t\t\"DocumentFragment\": false,\n\t\t\"DocumentType\": false,\n\t\t\"DOMError\": false,\n\t\t\"DOMException\": false,\n\t\t\"DOMImplementation\": false,\n\t\t\"DOMMatrix\": false,\n\t\t\"DOMMatrixReadOnly\": false,\n\t\t\"DOMParser\": false,\n\t\t\"DOMPoint\": false,\n\t\t\"DOMPointReadOnly\": false,\n\t\t\"DOMQuad\": false,\n\t\t\"DOMRect\": false,\n\t\t\"DOMRectReadOnly\": false,\n\t\t\"DOMStringList\": false,\n\t\t\"DOMStringMap\": false,\n\t\t\"DOMTokenList\": false,\n\t\t\"DragEvent\": false,\n\t\t\"DynamicsCompressorNode\": false,\n\t\t\"Element\": false,\n\t\t\"ErrorEvent\": false,\n\t\t\"event\": false,\n\t\t\"Event\": false,\n\t\t\"EventSource\": false,\n\t\t\"EventTarget\": false,\n\t\t\"external\": false,\n\t\t\"fetch\": false,\n\t\t\"File\": false,\n\t\t\"FileList\": false,\n\t\t\"FileReader\": false,\n\t\t\"find\": false,\n\t\t\"focus\": false,\n\t\t\"FocusEvent\": false,\n\t\t\"FontFace\": false,\n\t\t\"FontFaceSetLoadEvent\": false,\n\t\t\"FormData\": false,\n\t\t\"frameElement\": false,\n\t\t\"frames\": false,\n\t\t\"GainNode\": false,\n\t\t\"Gamepad\": false,\n\t\t\"GamepadButton\": false,\n\t\t\"GamepadEvent\": false,\n\t\t\"getComputedStyle\": false,\n\t\t\"getSelection\": false,\n\t\t\"HashChangeEvent\": false,\n\t\t\"Headers\": false,\n\t\t\"history\": false,\n\t\t\"History\": false,\n\t\t\"HTMLAllCollection\": false,\n\t\t\"HTMLAnchorElement\": false,\n\t\t\"HTMLAreaElement\": false,\n\t\t\"HTMLAudioElement\": false,\n\t\t\"HTMLBaseElement\": false,\n\t\t\"HTMLBodyElement\": false,\n\t\t\"HTMLBRElement\": false,\n\t\t\"HTMLButtonElement\": false,\n\t\t\"HTMLCanvasElement\": false,\n\t\t\"HTMLCollection\": false,\n\t\t\"HTMLContentElement\": false,\n\t\t\"HTMLDataElement\": false,\n\t\t\"HTMLDataListElement\": false,\n\t\t\"HTMLDetailsElement\": false,\n\t\t\"HTMLDialogElement\": false,\n\t\t\"HTMLDirectoryElement\": false,\n\t\t\"HTMLDivElement\": false,\n\t\t\"HTMLDListElement\": false,\n\t\t\"HTMLDocument\": false,\n\t\t\"HTMLElement\": false,\n\t\t\"HTMLEmbedElement\": false,\n\t\t\"HTMLFieldSetElement\": false,\n\t\t\"HTMLFontElement\": false,\n\t\t\"HTMLFormControlsCollection\": false,\n\t\t\"HTMLFormElement\": false,\n\t\t\"HTMLFrameElement\": false,\n\t\t\"HTMLFrameSetElement\": false,\n\t\t\"HTMLHeadElement\": false,\n\t\t\"HTMLHeadingElement\": false,\n\t\t\"HTMLHRElement\": false,\n\t\t\"HTMLHtmlElement\": false,\n\t\t\"HTMLIFrameElement\": false,\n\t\t\"HTMLImageElement\": false,\n\t\t\"HTMLInputElement\": false,\n\t\t\"HTMLLabelElement\": false,\n\t\t\"HTMLLegendElement\": false,\n\t\t\"HTMLLIElement\": false,\n\t\t\"HTMLLinkElement\": false,\n\t\t\"HTMLMapElement\": false,\n\t\t\"HTMLMarqueeElement\": false,\n\t\t\"HTMLMediaElement\": false,\n\t\t\"HTMLMenuElement\": false,\n\t\t\"HTMLMetaElement\": false,\n\t\t\"HTMLMeterElement\": false,\n\t\t\"HTMLModElement\": false,\n\t\t\"HTMLObjectElement\": false,\n\t\t\"HTMLOListElement\": false,\n\t\t\"HTMLOptGroupElement\": false,\n\t\t\"HTMLOptionElement\": false,\n\t\t\"HTMLOptionsCollection\": false,\n\t\t\"HTMLOutputElement\": false,\n\t\t\"HTMLParagraphElement\": false,\n\t\t\"HTMLParamElement\": false,\n\t\t\"HTMLPictureElement\": false,\n\t\t\"HTMLPreElement\": false,\n\t\t\"HTMLProgressElement\": false,\n\t\t\"HTMLQuoteElement\": false,\n\t\t\"HTMLScriptElement\": false,\n\t\t\"HTMLSelectElement\": false,\n\t\t\"HTMLShadowElement\": false,\n\t\t\"HTMLSlotElement\": false,\n\t\t\"HTMLSourceElement\": false,\n\t\t\"HTMLSpanElement\": false,\n\t\t\"HTMLStyleElement\": false,\n\t\t\"HTMLTableCaptionElement\": false,\n\t\t\"HTMLTableCellElement\": false,\n\t\t\"HTMLTableColElement\": false,\n\t\t\"HTMLTableElement\": false,\n\t\t\"HTMLTableRowElement\": false,\n\t\t\"HTMLTableSectionElement\": false,\n\t\t\"HTMLTemplateElement\": false,\n\t\t\"HTMLTextAreaElement\": false,\n\t\t\"HTMLTimeElement\": false,\n\t\t\"HTMLTitleElement\": false,\n\t\t\"HTMLTrackElement\": false,\n\t\t\"HTMLUListElement\": false,\n\t\t\"HTMLUnknownElement\": false,\n\t\t\"HTMLVideoElement\": false,\n\t\t\"IDBCursor\": false,\n\t\t\"IDBCursorWithValue\": false,\n\t\t\"IDBDatabase\": false,\n\t\t\"IDBFactory\": false,\n\t\t\"IDBIndex\": false,\n\t\t\"IDBKeyRange\": false,\n\t\t\"IDBObjectStore\": false,\n\t\t\"IDBOpenDBRequest\": false,\n\t\t\"IDBRequest\": false,\n\t\t\"IDBTransaction\": false,\n\t\t\"IDBVersionChangeEvent\": false,\n\t\t\"IdleDeadline\": false,\n\t\t\"IIRFilterNode\": false,\n\t\t\"Image\": false,\n\t\t\"ImageBitmap\": false,\n\t\t\"ImageBitmapRenderingContext\": false,\n\t\t\"ImageCapture\": false,\n\t\t\"ImageData\": false,\n\t\t\"indexedDB\": false,\n\t\t\"innerHeight\": false,\n\t\t\"innerWidth\": false,\n\t\t\"InputEvent\": false,\n\t\t\"IntersectionObserver\": false,\n\t\t\"IntersectionObserverEntry\": false,\n\t\t\"Intl\": false,\n\t\t\"isSecureContext\": false,\n\t\t\"KeyboardEvent\": false,\n\t\t\"KeyframeEffect\": false,\n\t\t\"KeyframeEffectReadOnly\": false,\n\t\t\"length\": false,\n\t\t\"localStorage\": false,\n\t\t\"location\": true,\n\t\t\"Location\": false,\n\t\t\"locationbar\": false,\n\t\t\"matchMedia\": false,\n\t\t\"MediaDeviceInfo\": false,\n\t\t\"MediaDevices\": false,\n\t\t\"MediaElementAudioSourceNode\": false,\n\t\t\"MediaEncryptedEvent\": false,\n\t\t\"MediaError\": false,\n\t\t\"MediaKeyMessageEvent\": false,\n\t\t\"MediaKeySession\": false,\n\t\t\"MediaKeyStatusMap\": false,\n\t\t\"MediaKeySystemAccess\": false,\n\t\t\"MediaList\": false,\n\t\t\"MediaQueryList\": false,\n\t\t\"MediaQueryListEvent\": false,\n\t\t\"MediaRecorder\": false,\n\t\t\"MediaSettingsRange\": false,\n\t\t\"MediaSource\": false,\n\t\t\"MediaStream\": false,\n\t\t\"MediaStreamAudioDestinationNode\": false,\n\t\t\"MediaStreamAudioSourceNode\": false,\n\t\t\"MediaStreamEvent\": false,\n\t\t\"MediaStreamTrack\": false,\n\t\t\"MediaStreamTrackEvent\": false,\n\t\t\"menubar\": false,\n\t\t\"MessageChannel\": false,\n\t\t\"MessageEvent\": false,\n\t\t\"MessagePort\": false,\n\t\t\"MIDIAccess\": false,\n\t\t\"MIDIConnectionEvent\": false,\n\t\t\"MIDIInput\": false,\n\t\t\"MIDIInputMap\": false,\n\t\t\"MIDIMessageEvent\": false,\n\t\t\"MIDIOutput\": false,\n\t\t\"MIDIOutputMap\": false,\n\t\t\"MIDIPort\": false,\n\t\t\"MimeType\": false,\n\t\t\"MimeTypeArray\": false,\n\t\t\"MouseEvent\": false,\n\t\t\"moveBy\": false,\n\t\t\"moveTo\": false,\n\t\t\"MutationEvent\": false,\n\t\t\"MutationObserver\": false,\n\t\t\"MutationRecord\": false,\n\t\t\"name\": false,\n\t\t\"NamedNodeMap\": false,\n\t\t\"NavigationPreloadManager\": false,\n\t\t\"navigator\": false,\n\t\t\"Navigator\": false,\n\t\t\"NetworkInformation\": false,\n\t\t\"Node\": false,\n\t\t\"NodeFilter\": false,\n\t\t\"NodeIterator\": false,\n\t\t\"NodeList\": false,\n\t\t\"Notification\": false,\n\t\t\"OfflineAudioCompletionEvent\": false,\n\t\t\"OfflineAudioContext\": false,\n\t\t\"offscreenBuffering\": false,\n\t\t\"OffscreenCanvas\": true,\n\t\t\"onabort\": true,\n\t\t\"onafterprint\": true,\n\t\t\"onanimationend\": true,\n\t\t\"onanimationiteration\": true,\n\t\t\"onanimationstart\": true,\n\t\t\"onappinstalled\": true,\n\t\t\"onauxclick\": true,\n\t\t\"onbeforeinstallprompt\": true,\n\t\t\"onbeforeprint\": true,\n\t\t\"onbeforeunload\": true,\n\t\t\"onblur\": true,\n\t\t\"oncancel\": true,\n\t\t\"oncanplay\": true,\n\t\t\"oncanplaythrough\": true,\n\t\t\"onchange\": true,\n\t\t\"onclick\": true,\n\t\t\"onclose\": true,\n\t\t\"oncontextmenu\": true,\n\t\t\"oncuechange\": true,\n\t\t\"ondblclick\": true,\n\t\t\"ondevicemotion\": true,\n\t\t\"ondeviceorientation\": true,\n\t\t\"ondeviceorientationabsolute\": true,\n\t\t\"ondrag\": true,\n\t\t\"ondragend\": true,\n\t\t\"ondragenter\": true,\n\t\t\"ondragleave\": true,\n\t\t\"ondragover\": true,\n\t\t\"ondragstart\": true,\n\t\t\"ondrop\": true,\n\t\t\"ondurationchange\": true,\n\t\t\"onemptied\": true,\n\t\t\"onended\": true,\n\t\t\"onerror\": true,\n\t\t\"onfocus\": true,\n\t\t\"ongotpointercapture\": true,\n\t\t\"onhashchange\": true,\n\t\t\"oninput\": true,\n\t\t\"oninvalid\": true,\n\t\t\"onkeydown\": true,\n\t\t\"onkeypress\": true,\n\t\t\"onkeyup\": true,\n\t\t\"onlanguagechange\": true,\n\t\t\"onload\": true,\n\t\t\"onloadeddata\": true,\n\t\t\"onloadedmetadata\": true,\n\t\t\"onloadstart\": true,\n\t\t\"onlostpointercapture\": true,\n\t\t\"onmessage\": true,\n\t\t\"onmessageerror\": true,\n\t\t\"onmousedown\": true,\n\t\t\"onmouseenter\": true,\n\t\t\"onmouseleave\": true,\n\t\t\"onmousemove\": true,\n\t\t\"onmouseout\": true,\n\t\t\"onmouseover\": true,\n\t\t\"onmouseup\": true,\n\t\t\"onmousewheel\": true,\n\t\t\"onoffline\": true,\n\t\t\"ononline\": true,\n\t\t\"onpagehide\": true,\n\t\t\"onpageshow\": true,\n\t\t\"onpause\": true,\n\t\t\"onplay\": true,\n\t\t\"onplaying\": true,\n\t\t\"onpointercancel\": true,\n\t\t\"onpointerdown\": true,\n\t\t\"onpointerenter\": true,\n\t\t\"onpointerleave\": true,\n\t\t\"onpointermove\": true,\n\t\t\"onpointerout\": true,\n\t\t\"onpointerover\": true,\n\t\t\"onpointerup\": true,\n\t\t\"onpopstate\": true,\n\t\t\"onprogress\": true,\n\t\t\"onratechange\": true,\n\t\t\"onrejectionhandled\": true,\n\t\t\"onreset\": true,\n\t\t\"onresize\": true,\n\t\t\"onscroll\": true,\n\t\t\"onsearch\": true,\n\t\t\"onseeked\": true,\n\t\t\"onseeking\": true,\n\t\t\"onselect\": true,\n\t\t\"onstalled\": true,\n\t\t\"onstorage\": true,\n\t\t\"onsubmit\": true,\n\t\t\"onsuspend\": true,\n\t\t\"ontimeupdate\": true,\n\t\t\"ontoggle\": true,\n\t\t\"ontransitionend\": true,\n\t\t\"onunhandledrejection\": true,\n\t\t\"onunload\": true,\n\t\t\"onvolumechange\": true,\n\t\t\"onwaiting\": true,\n\t\t\"onwheel\": true,\n\t\t\"open\": false,\n\t\t\"openDatabase\": false,\n\t\t\"opener\": false,\n\t\t\"Option\": false,\n\t\t\"origin\": false,\n\t\t\"OscillatorNode\": false,\n\t\t\"outerHeight\": false,\n\t\t\"outerWidth\": false,\n\t\t\"PageTransitionEvent\": false,\n\t\t\"pageXOffset\": false,\n\t\t\"pageYOffset\": false,\n\t\t\"PannerNode\": false,\n\t\t\"parent\": false,\n\t\t\"Path2D\": false,\n\t\t\"PaymentAddress\": false,\n\t\t\"PaymentRequest\": false,\n\t\t\"PaymentRequestUpdateEvent\": false,\n\t\t\"PaymentResponse\": false,\n\t\t\"performance\": false,\n\t\t\"Performance\": false,\n\t\t\"PerformanceEntry\": false,\n\t\t\"PerformanceLongTaskTiming\": false,\n\t\t\"PerformanceMark\": false,\n\t\t\"PerformanceMeasure\": false,\n\t\t\"PerformanceNavigation\": false,\n\t\t\"PerformanceNavigationTiming\": false,\n\t\t\"PerformanceObserver\": false,\n\t\t\"PerformanceObserverEntryList\": false,\n\t\t\"PerformancePaintTiming\": false,\n\t\t\"PerformanceResourceTiming\": false,\n\t\t\"PerformanceTiming\": false,\n\t\t\"PeriodicWave\": false,\n\t\t\"Permissions\": false,\n\t\t\"PermissionStatus\": false,\n\t\t\"personalbar\": false,\n\t\t\"PhotoCapabilities\": false,\n\t\t\"Plugin\": false,\n\t\t\"PluginArray\": false,\n\t\t\"PointerEvent\": false,\n\t\t\"PopStateEvent\": false,\n\t\t\"postMessage\": false,\n\t\t\"Presentation\": false,\n\t\t\"PresentationAvailability\": false,\n\t\t\"PresentationConnection\": false,\n\t\t\"PresentationConnectionAvailableEvent\": false,\n\t\t\"PresentationConnectionCloseEvent\": false,\n\t\t\"PresentationConnectionList\": false,\n\t\t\"PresentationReceiver\": false,\n\t\t\"PresentationRequest\": false,\n\t\t\"print\": false,\n\t\t\"ProcessingInstruction\": false,\n\t\t\"ProgressEvent\": false,\n\t\t\"PromiseRejectionEvent\": false,\n\t\t\"prompt\": false,\n\t\t\"PushManager\": false,\n\t\t\"PushSubscription\": false,\n\t\t\"PushSubscriptionOptions\": false,\n\t\t\"queueMicrotask\": false,\n\t\t\"RadioNodeList\": false,\n\t\t\"Range\": false,\n\t\t\"ReadableStream\": false,\n\t\t\"registerProcessor\": false,\n\t\t\"RemotePlayback\": false,\n\t\t\"removeEventListener\": false,\n\t\t\"Request\": false,\n\t\t\"requestAnimationFrame\": false,\n\t\t\"requestIdleCallback\": false,\n\t\t\"resizeBy\": false,\n\t\t\"ResizeObserver\": false,\n\t\t\"ResizeObserverEntry\": false,\n\t\t\"resizeTo\": false,\n\t\t\"Response\": false,\n\t\t\"RTCCertificate\": false,\n\t\t\"RTCDataChannel\": false,\n\t\t\"RTCDataChannelEvent\": false,\n\t\t\"RTCDtlsTransport\": false,\n\t\t\"RTCIceCandidate\": false,\n\t\t\"RTCIceGatherer\": false,\n\t\t\"RTCIceTransport\": false,\n\t\t\"RTCPeerConnection\": false,\n\t\t\"RTCPeerConnectionIceEvent\": false,\n\t\t\"RTCRtpContributingSource\": false,\n\t\t\"RTCRtpReceiver\": false,\n\t\t\"RTCRtpSender\": false,\n\t\t\"RTCSctpTransport\": false,\n\t\t\"RTCSessionDescription\": false,\n\t\t\"RTCStatsReport\": false,\n\t\t\"RTCTrackEvent\": false,\n\t\t\"screen\": false,\n\t\t\"Screen\": false,\n\t\t\"screenLeft\": false,\n\t\t\"ScreenOrientation\": false,\n\t\t\"screenTop\": false,\n\t\t\"screenX\": false,\n\t\t\"screenY\": false,\n\t\t\"ScriptProcessorNode\": false,\n\t\t\"scroll\": false,\n\t\t\"scrollbars\": false,\n\t\t\"scrollBy\": false,\n\t\t\"scrollTo\": false,\n\t\t\"scrollX\": false,\n\t\t\"scrollY\": false,\n\t\t\"SecurityPolicyViolationEvent\": false,\n\t\t\"Selection\": false,\n\t\t\"self\": false,\n\t\t\"ServiceWorker\": false,\n\t\t\"ServiceWorkerContainer\": false,\n\t\t\"ServiceWorkerRegistration\": false,\n\t\t\"sessionStorage\": false,\n\t\t\"setInterval\": false,\n\t\t\"setTimeout\": false,\n\t\t\"ShadowRoot\": false,\n\t\t\"SharedWorker\": false,\n\t\t\"SourceBuffer\": false,\n\t\t\"SourceBufferList\": false,\n\t\t\"speechSynthesis\": false,\n\t\t\"SpeechSynthesisEvent\": false,\n\t\t\"SpeechSynthesisUtterance\": false,\n\t\t\"StaticRange\": false,\n\t\t\"status\": false,\n\t\t\"statusbar\": false,\n\t\t\"StereoPannerNode\": false,\n\t\t\"stop\": false,\n\t\t\"Storage\": false,\n\t\t\"StorageEvent\": false,\n\t\t\"StorageManager\": false,\n\t\t\"styleMedia\": false,\n\t\t\"StyleSheet\": false,\n\t\t\"StyleSheetList\": false,\n\t\t\"SubtleCrypto\": false,\n\t\t\"SVGAElement\": false,\n\t\t\"SVGAngle\": false,\n\t\t\"SVGAnimatedAngle\": false,\n\t\t\"SVGAnimatedBoolean\": false,\n\t\t\"SVGAnimatedEnumeration\": false,\n\t\t\"SVGAnimatedInteger\": false,\n\t\t\"SVGAnimatedLength\": false,\n\t\t\"SVGAnimatedLengthList\": false,\n\t\t\"SVGAnimatedNumber\": false,\n\t\t\"SVGAnimatedNumberList\": false,\n\t\t\"SVGAnimatedPreserveAspectRatio\": false,\n\t\t\"SVGAnimatedRect\": false,\n\t\t\"SVGAnimatedString\": false,\n\t\t\"SVGAnimatedTransformList\": false,\n\t\t\"SVGAnimateElement\": false,\n\t\t\"SVGAnimateMotionElement\": false,\n\t\t\"SVGAnimateTransformElement\": false,\n\t\t\"SVGAnimationElement\": false,\n\t\t\"SVGCircleElement\": false,\n\t\t\"SVGClipPathElement\": false,\n\t\t\"SVGComponentTransferFunctionElement\": false,\n\t\t\"SVGDefsElement\": false,\n\t\t\"SVGDescElement\": false,\n\t\t\"SVGDiscardElement\": false,\n\t\t\"SVGElement\": false,\n\t\t\"SVGEllipseElement\": false,\n\t\t\"SVGFEBlendElement\": false,\n\t\t\"SVGFEColorMatrixElement\": false,\n\t\t\"SVGFEComponentTransferElement\": false,\n\t\t\"SVGFECompositeElement\": false,\n\t\t\"SVGFEConvolveMatrixElement\": false,\n\t\t\"SVGFEDiffuseLightingElement\": false,\n\t\t\"SVGFEDisplacementMapElement\": false,\n\t\t\"SVGFEDistantLightElement\": false,\n\t\t\"SVGFEDropShadowElement\": false,\n\t\t\"SVGFEFloodElement\": false,\n\t\t\"SVGFEFuncAElement\": false,\n\t\t\"SVGFEFuncBElement\": false,\n\t\t\"SVGFEFuncGElement\": false,\n\t\t\"SVGFEFuncRElement\": false,\n\t\t\"SVGFEGaussianBlurElement\": false,\n\t\t\"SVGFEImageElement\": false,\n\t\t\"SVGFEMergeElement\": false,\n\t\t\"SVGFEMergeNodeElement\": false,\n\t\t\"SVGFEMorphologyElement\": false,\n\t\t\"SVGFEOffsetElement\": false,\n\t\t\"SVGFEPointLightElement\": false,\n\t\t\"SVGFESpecularLightingElement\": false,\n\t\t\"SVGFESpotLightElement\": false,\n\t\t\"SVGFETileElement\": false,\n\t\t\"SVGFETurbulenceElement\": false,\n\t\t\"SVGFilterElement\": false,\n\t\t\"SVGForeignObjectElement\": false,\n\t\t\"SVGGElement\": false,\n\t\t\"SVGGeometryElement\": false,\n\t\t\"SVGGradientElement\": false,\n\t\t\"SVGGraphicsElement\": false,\n\t\t\"SVGImageElement\": false,\n\t\t\"SVGLength\": false,\n\t\t\"SVGLengthList\": false,\n\t\t\"SVGLinearGradientElement\": false,\n\t\t\"SVGLineElement\": false,\n\t\t\"SVGMarkerElement\": false,\n\t\t\"SVGMaskElement\": false,\n\t\t\"SVGMatrix\": false,\n\t\t\"SVGMetadataElement\": false,\n\t\t\"SVGMPathElement\": false,\n\t\t\"SVGNumber\": false,\n\t\t\"SVGNumberList\": false,\n\t\t\"SVGPathElement\": false,\n\t\t\"SVGPatternElement\": false,\n\t\t\"SVGPoint\": false,\n\t\t\"SVGPointList\": false,\n\t\t\"SVGPolygonElement\": false,\n\t\t\"SVGPolylineElement\": false,\n\t\t\"SVGPreserveAspectRatio\": false,\n\t\t\"SVGRadialGradientElement\": false,\n\t\t\"SVGRect\": false,\n\t\t\"SVGRectElement\": false,\n\t\t\"SVGScriptElement\": false,\n\t\t\"SVGSetElement\": false,\n\t\t\"SVGStopElement\": false,\n\t\t\"SVGStringList\": false,\n\t\t\"SVGStyleElement\": false,\n\t\t\"SVGSVGElement\": false,\n\t\t\"SVGSwitchElement\": false,\n\t\t\"SVGSymbolElement\": false,\n\t\t\"SVGTextContentElement\": false,\n\t\t\"SVGTextElement\": false,\n\t\t\"SVGTextPathElement\": false,\n\t\t\"SVGTextPositioningElement\": false,\n\t\t\"SVGTitleElement\": false,\n\t\t\"SVGTransform\": false,\n\t\t\"SVGTransformList\": false,\n\t\t\"SVGTSpanElement\": false,\n\t\t\"SVGUnitTypes\": false,\n\t\t\"SVGUseElement\": false,\n\t\t\"SVGViewElement\": false,\n\t\t\"TaskAttributionTiming\": false,\n\t\t\"Text\": false,\n\t\t\"TextDecoder\": false,\n\t\t\"TextEncoder\": false,\n\t\t\"TextEvent\": false,\n\t\t\"TextMetrics\": false,\n\t\t\"TextTrack\": false,\n\t\t\"TextTrackCue\": false,\n\t\t\"TextTrackCueList\": false,\n\t\t\"TextTrackList\": false,\n\t\t\"TimeRanges\": false,\n\t\t\"toolbar\": false,\n\t\t\"top\": false,\n\t\t\"Touch\": false,\n\t\t\"TouchEvent\": false,\n\t\t\"TouchList\": false,\n\t\t\"TrackEvent\": false,\n\t\t\"TransitionEvent\": false,\n\t\t\"TreeWalker\": false,\n\t\t\"UIEvent\": false,\n\t\t\"URL\": false,\n\t\t\"URLSearchParams\": false,\n\t\t\"ValidityState\": false,\n\t\t\"visualViewport\": false,\n\t\t\"VisualViewport\": false,\n\t\t\"VTTCue\": false,\n\t\t\"WaveShaperNode\": false,\n\t\t\"WebAssembly\": false,\n\t\t\"WebGL2RenderingContext\": false,\n\t\t\"WebGLActiveInfo\": false,\n\t\t\"WebGLBuffer\": false,\n\t\t\"WebGLContextEvent\": false,\n\t\t\"WebGLFramebuffer\": false,\n\t\t\"WebGLProgram\": false,\n\t\t\"WebGLQuery\": false,\n\t\t\"WebGLRenderbuffer\": false,\n\t\t\"WebGLRenderingContext\": false,\n\t\t\"WebGLSampler\": false,\n\t\t\"WebGLShader\": false,\n\t\t\"WebGLShaderPrecisionFormat\": false,\n\t\t\"WebGLSync\": false,\n\t\t\"WebGLTexture\": false,\n\t\t\"WebGLTransformFeedback\": false,\n\t\t\"WebGLUniformLocation\": false,\n\t\t\"WebGLVertexArrayObject\": false,\n\t\t\"WebSocket\": false,\n\t\t\"WheelEvent\": false,\n\t\t\"window\": false,\n\t\t\"Window\": false,\n\t\t\"Worker\": false,\n\t\t\"WritableStream\": false,\n\t\t\"XMLDocument\": false,\n\t\t\"XMLHttpRequest\": false,\n\t\t\"XMLHttpRequestEventTarget\": false,\n\t\t\"XMLHttpRequestUpload\": false,\n\t\t\"XMLSerializer\": false,\n\t\t\"XPathEvaluator\": false,\n\t\t\"XPathExpression\": false,\n\t\t\"XPathResult\": false,\n\t\t\"XSLTProcessor\": false\n\t},\n\t\"worker\": {\n\t\t\"addEventListener\": false,\n\t\t\"applicationCache\": false,\n\t\t\"atob\": false,\n\t\t\"Blob\": false,\n\t\t\"BroadcastChannel\": false,\n\t\t\"btoa\": false,\n\t\t\"Cache\": false,\n\t\t\"caches\": false,\n\t\t\"clearInterval\": false,\n\t\t\"clearTimeout\": false,\n\t\t\"close\": true,\n\t\t\"console\": false,\n\t\t\"fetch\": false,\n\t\t\"FileReaderSync\": false,\n\t\t\"FormData\": false,\n\t\t\"Headers\": false,\n\t\t\"IDBCursor\": false,\n\t\t\"IDBCursorWithValue\": false,\n\t\t\"IDBDatabase\": false,\n\t\t\"IDBFactory\": false,\n\t\t\"IDBIndex\": false,\n\t\t\"IDBKeyRange\": false,\n\t\t\"IDBObjectStore\": false,\n\t\t\"IDBOpenDBRequest\": false,\n\t\t\"IDBRequest\": false,\n\t\t\"IDBTransaction\": false,\n\t\t\"IDBVersionChangeEvent\": false,\n\t\t\"ImageData\": false,\n\t\t\"importScripts\": true,\n\t\t\"indexedDB\": false,\n\t\t\"location\": false,\n\t\t\"MessageChannel\": false,\n\t\t\"MessagePort\": false,\n\t\t\"name\": false,\n\t\t\"navigator\": false,\n\t\t\"Notification\": false,\n\t\t\"onclose\": true,\n\t\t\"onconnect\": true,\n\t\t\"onerror\": true,\n\t\t\"onlanguagechange\": true,\n\t\t\"onmessage\": true,\n\t\t\"onoffline\": true,\n\t\t\"ononline\": true,\n\t\t\"onrejectionhandled\": true,\n\t\t\"onunhandledrejection\": true,\n\t\t\"performance\": false,\n\t\t\"Performance\": false,\n\t\t\"PerformanceEntry\": false,\n\t\t\"PerformanceMark\": false,\n\t\t\"PerformanceMeasure\": false,\n\t\t\"PerformanceNavigation\": false,\n\t\t\"PerformanceResourceTiming\": false,\n\t\t\"PerformanceTiming\": false,\n\t\t\"postMessage\": true,\n\t\t\"Promise\": false,\n\t\t\"queueMicrotask\": false,\n\t\t\"removeEventListener\": false,\n\t\t\"Request\": false,\n\t\t\"Response\": false,\n\t\t\"self\": true,\n\t\t\"ServiceWorkerRegistration\": false,\n\t\t\"setInterval\": false,\n\t\t\"setTimeout\": false,\n\t\t\"TextDecoder\": false,\n\t\t\"TextEncoder\": false,\n\t\t\"URL\": false,\n\t\t\"URLSearchParams\": false,\n\t\t\"WebSocket\": false,\n\t\t\"Worker\": false,\n\t\t\"WorkerGlobalScope\": false,\n\t\t\"XMLHttpRequest\": false\n\t},\n\t\"node\": {\n\t\t\"__dirname\": false,\n\t\t\"__filename\": false,\n\t\t\"Buffer\": false,\n\t\t\"clearImmediate\": false,\n\t\t\"clearInterval\": false,\n\t\t\"clearTimeout\": false,\n\t\t\"console\": false,\n\t\t\"exports\": true,\n\t\t\"global\": false,\n\t\t\"Intl\": false,\n\t\t\"module\": false,\n\t\t\"process\": false,\n\t\t\"queueMicrotask\": false,\n\t\t\"require\": false,\n\t\t\"setImmediate\": false,\n\t\t\"setInterval\": false,\n\t\t\"setTimeout\": false,\n\t\t\"TextDecoder\": false,\n\t\t\"TextEncoder\": false,\n\t\t\"URL\": false,\n\t\t\"URLSearchParams\": false\n\t},\n\t\"commonjs\": {\n\t\t\"exports\": true,\n\t\t\"global\": false,\n\t\t\"module\": false,\n\t\t\"require\": false\n\t},\n\t\"amd\": {\n\t\t\"define\": false,\n\t\t\"require\": false\n\t},\n\t\"mocha\": {\n\t\t\"after\": false,\n\t\t\"afterEach\": false,\n\t\t\"before\": false,\n\t\t\"beforeEach\": false,\n\t\t\"context\": false,\n\t\t\"describe\": false,\n\t\t\"it\": false,\n\t\t\"mocha\": false,\n\t\t\"run\": false,\n\t\t\"setup\": false,\n\t\t\"specify\": false,\n\t\t\"suite\": false,\n\t\t\"suiteSetup\": false,\n\t\t\"suiteTeardown\": false,\n\t\t\"teardown\": false,\n\t\t\"test\": false,\n\t\t\"xcontext\": false,\n\t\t\"xdescribe\": false,\n\t\t\"xit\": false,\n\t\t\"xspecify\": false\n\t},\n\t\"jasmine\": {\n\t\t\"afterAll\": false,\n\t\t\"afterEach\": false,\n\t\t\"beforeAll\": false,\n\t\t\"beforeEach\": false,\n\t\t\"describe\": false,\n\t\t\"expect\": false,\n\t\t\"fail\": false,\n\t\t\"fdescribe\": false,\n\t\t\"fit\": false,\n\t\t\"it\": false,\n\t\t\"jasmine\": false,\n\t\t\"pending\": false,\n\t\t\"runs\": false,\n\t\t\"spyOn\": false,\n\t\t\"spyOnProperty\": false,\n\t\t\"waits\": false,\n\t\t\"waitsFor\": false,\n\t\t\"xdescribe\": false,\n\t\t\"xit\": false\n\t},\n\t\"jest\": {\n\t\t\"afterAll\": false,\n\t\t\"afterEach\": false,\n\t\t\"beforeAll\": false,\n\t\t\"beforeEach\": false,\n\t\t\"describe\": false,\n\t\t\"expect\": false,\n\t\t\"fdescribe\": false,\n\t\t\"fit\": false,\n\t\t\"it\": false,\n\t\t\"jest\": false,\n\t\t\"pit\": false,\n\t\t\"require\": false,\n\t\t\"test\": false,\n\t\t\"xdescribe\": false,\n\t\t\"xit\": false,\n\t\t\"xtest\": false\n\t},\n\t\"qunit\": {\n\t\t\"asyncTest\": false,\n\t\t\"deepEqual\": false,\n\t\t\"equal\": false,\n\t\t\"expect\": false,\n\t\t\"module\": false,\n\t\t\"notDeepEqual\": false,\n\t\t\"notEqual\": false,\n\t\t\"notOk\": false,\n\t\t\"notPropEqual\": false,\n\t\t\"notStrictEqual\": false,\n\t\t\"ok\": false,\n\t\t\"propEqual\": false,\n\t\t\"QUnit\": false,\n\t\t\"raises\": false,\n\t\t\"start\": false,\n\t\t\"stop\": false,\n\t\t\"strictEqual\": false,\n\t\t\"test\": false,\n\t\t\"throws\": false\n\t},\n\t\"phantomjs\": {\n\t\t\"console\": true,\n\t\t\"exports\": true,\n\t\t\"phantom\": true,\n\t\t\"require\": true,\n\t\t\"WebPage\": true\n\t},\n\t\"couch\": {\n\t\t\"emit\": false,\n\t\t\"exports\": false,\n\t\t\"getRow\": false,\n\t\t\"log\": false,\n\t\t\"module\": false,\n\t\t\"provides\": false,\n\t\t\"require\": false,\n\t\t\"respond\": false,\n\t\t\"send\": false,\n\t\t\"start\": false,\n\t\t\"sum\": false\n\t},\n\t\"rhino\": {\n\t\t\"defineClass\": false,\n\t\t\"deserialize\": false,\n\t\t\"gc\": false,\n\t\t\"help\": false,\n\t\t\"importClass\": false,\n\t\t\"importPackage\": false,\n\t\t\"java\": false,\n\t\t\"load\": false,\n\t\t\"loadClass\": false,\n\t\t\"Packages\": false,\n\t\t\"print\": false,\n\t\t\"quit\": false,\n\t\t\"readFile\": false,\n\t\t\"readUrl\": false,\n\t\t\"runCommand\": false,\n\t\t\"seal\": false,\n\t\t\"serialize\": false,\n\t\t\"spawn\": false,\n\t\t\"sync\": false,\n\t\t\"toint32\": false,\n\t\t\"version\": false\n\t},\n\t\"nashorn\": {\n\t\t\"__DIR__\": false,\n\t\t\"__FILE__\": false,\n\t\t\"__LINE__\": false,\n\t\t\"com\": false,\n\t\t\"edu\": false,\n\t\t\"exit\": false,\n\t\t\"java\": false,\n\t\t\"Java\": false,\n\t\t\"javafx\": false,\n\t\t\"JavaImporter\": false,\n\t\t\"javax\": false,\n\t\t\"JSAdapter\": false,\n\t\t\"load\": false,\n\t\t\"loadWithNewGlobal\": false,\n\t\t\"org\": false,\n\t\t\"Packages\": false,\n\t\t\"print\": false,\n\t\t\"quit\": false\n\t},\n\t\"wsh\": {\n\t\t\"ActiveXObject\": true,\n\t\t\"Enumerator\": true,\n\t\t\"GetObject\": true,\n\t\t\"ScriptEngine\": true,\n\t\t\"ScriptEngineBuildVersion\": true,\n\t\t\"ScriptEngineMajorVersion\": true,\n\t\t\"ScriptEngineMinorVersion\": true,\n\t\t\"VBArray\": true,\n\t\t\"WScript\": true,\n\t\t\"WSH\": true,\n\t\t\"XDomainRequest\": true\n\t},\n\t\"jquery\": {\n\t\t\"$\": false,\n\t\t\"jQuery\": false\n\t},\n\t\"yui\": {\n\t\t\"YAHOO\": false,\n\t\t\"YAHOO_config\": false,\n\t\t\"YUI\": false,\n\t\t\"YUI_config\": false\n\t},\n\t\"shelljs\": {\n\t\t\"cat\": false,\n\t\t\"cd\": false,\n\t\t\"chmod\": false,\n\t\t\"config\": false,\n\t\t\"cp\": false,\n\t\t\"dirs\": false,\n\t\t\"echo\": false,\n\t\t\"env\": false,\n\t\t\"error\": false,\n\t\t\"exec\": false,\n\t\t\"exit\": false,\n\t\t\"find\": false,\n\t\t\"grep\": false,\n\t\t\"ln\": false,\n\t\t\"ls\": false,\n\t\t\"mkdir\": false,\n\t\t\"mv\": false,\n\t\t\"popd\": false,\n\t\t\"pushd\": false,\n\t\t\"pwd\": false,\n\t\t\"rm\": false,\n\t\t\"sed\": false,\n\t\t\"set\": false,\n\t\t\"target\": false,\n\t\t\"tempdir\": false,\n\t\t\"test\": false,\n\t\t\"touch\": false,\n\t\t\"which\": false\n\t},\n\t\"prototypejs\": {\n\t\t\"$\": false,\n\t\t\"$$\": false,\n\t\t\"$A\": false,\n\t\t\"$break\": false,\n\t\t\"$continue\": false,\n\t\t\"$F\": false,\n\t\t\"$H\": false,\n\t\t\"$R\": false,\n\t\t\"$w\": false,\n\t\t\"Abstract\": false,\n\t\t\"Ajax\": false,\n\t\t\"Autocompleter\": false,\n\t\t\"Builder\": false,\n\t\t\"Class\": false,\n\t\t\"Control\": false,\n\t\t\"Draggable\": false,\n\t\t\"Draggables\": false,\n\t\t\"Droppables\": false,\n\t\t\"Effect\": false,\n\t\t\"Element\": false,\n\t\t\"Enumerable\": false,\n\t\t\"Event\": false,\n\t\t\"Field\": false,\n\t\t\"Form\": false,\n\t\t\"Hash\": false,\n\t\t\"Insertion\": false,\n\t\t\"ObjectRange\": false,\n\t\t\"PeriodicalExecuter\": false,\n\t\t\"Position\": false,\n\t\t\"Prototype\": false,\n\t\t\"Scriptaculous\": false,\n\t\t\"Selector\": false,\n\t\t\"Sortable\": false,\n\t\t\"SortableObserver\": false,\n\t\t\"Sound\": false,\n\t\t\"Template\": false,\n\t\t\"Toggle\": false,\n\t\t\"Try\": false\n\t},\n\t\"meteor\": {\n\t\t\"_\": false,\n\t\t\"$\": false,\n\t\t\"Accounts\": false,\n\t\t\"AccountsClient\": false,\n\t\t\"AccountsCommon\": false,\n\t\t\"AccountsServer\": false,\n\t\t\"App\": false,\n\t\t\"Assets\": false,\n\t\t\"Blaze\": false,\n\t\t\"check\": false,\n\t\t\"Cordova\": false,\n\t\t\"DDP\": false,\n\t\t\"DDPRateLimiter\": false,\n\t\t\"DDPServer\": false,\n\t\t\"Deps\": false,\n\t\t\"EJSON\": false,\n\t\t\"Email\": false,\n\t\t\"HTTP\": false,\n\t\t\"Log\": false,\n\t\t\"Match\": false,\n\t\t\"Meteor\": false,\n\t\t\"Mongo\": false,\n\t\t\"MongoInternals\": false,\n\t\t\"Npm\": false,\n\t\t\"Package\": false,\n\t\t\"Plugin\": false,\n\t\t\"process\": false,\n\t\t\"Random\": false,\n\t\t\"ReactiveDict\": false,\n\t\t\"ReactiveVar\": false,\n\t\t\"Router\": false,\n\t\t\"ServiceConfiguration\": false,\n\t\t\"Session\": false,\n\t\t\"share\": false,\n\t\t\"Spacebars\": false,\n\t\t\"Template\": false,\n\t\t\"Tinytest\": false,\n\t\t\"Tracker\": false,\n\t\t\"UI\": false,\n\t\t\"Utils\": false,\n\t\t\"WebApp\": false,\n\t\t\"WebAppInternals\": false\n\t},\n\t\"mongo\": {\n\t\t\"_isWindows\": false,\n\t\t\"_rand\": false,\n\t\t\"BulkWriteResult\": false,\n\t\t\"cat\": false,\n\t\t\"cd\": false,\n\t\t\"connect\": false,\n\t\t\"db\": false,\n\t\t\"getHostName\": false,\n\t\t\"getMemInfo\": false,\n\t\t\"hostname\": false,\n\t\t\"ISODate\": false,\n\t\t\"listFiles\": false,\n\t\t\"load\": false,\n\t\t\"ls\": false,\n\t\t\"md5sumFile\": false,\n\t\t\"mkdir\": false,\n\t\t\"Mongo\": false,\n\t\t\"NumberInt\": false,\n\t\t\"NumberLong\": false,\n\t\t\"ObjectId\": false,\n\t\t\"PlanCache\": false,\n\t\t\"print\": false,\n\t\t\"printjson\": false,\n\t\t\"pwd\": false,\n\t\t\"quit\": false,\n\t\t\"removeFile\": false,\n\t\t\"rs\": false,\n\t\t\"sh\": false,\n\t\t\"UUID\": false,\n\t\t\"version\": false,\n\t\t\"WriteResult\": false\n\t},\n\t\"applescript\": {\n\t\t\"$\": false,\n\t\t\"Application\": false,\n\t\t\"Automation\": false,\n\t\t\"console\": false,\n\t\t\"delay\": false,\n\t\t\"Library\": false,\n\t\t\"ObjC\": false,\n\t\t\"ObjectSpecifier\": false,\n\t\t\"Path\": false,\n\t\t\"Progress\": false,\n\t\t\"Ref\": false\n\t},\n\t\"serviceworker\": {\n\t\t\"addEventListener\": false,\n\t\t\"applicationCache\": false,\n\t\t\"atob\": false,\n\t\t\"Blob\": false,\n\t\t\"BroadcastChannel\": false,\n\t\t\"btoa\": false,\n\t\t\"Cache\": false,\n\t\t\"caches\": false,\n\t\t\"CacheStorage\": false,\n\t\t\"clearInterval\": false,\n\t\t\"clearTimeout\": false,\n\t\t\"Client\": false,\n\t\t\"clients\": false,\n\t\t\"Clients\": false,\n\t\t\"close\": true,\n\t\t\"console\": false,\n\t\t\"ExtendableEvent\": false,\n\t\t\"ExtendableMessageEvent\": false,\n\t\t\"fetch\": false,\n\t\t\"FetchEvent\": false,\n\t\t\"FileReaderSync\": false,\n\t\t\"FormData\": false,\n\t\t\"Headers\": false,\n\t\t\"IDBCursor\": false,\n\t\t\"IDBCursorWithValue\": false,\n\t\t\"IDBDatabase\": false,\n\t\t\"IDBFactory\": false,\n\t\t\"IDBIndex\": false,\n\t\t\"IDBKeyRange\": false,\n\t\t\"IDBObjectStore\": false,\n\t\t\"IDBOpenDBRequest\": false,\n\t\t\"IDBRequest\": false,\n\t\t\"IDBTransaction\": false,\n\t\t\"IDBVersionChangeEvent\": false,\n\t\t\"ImageData\": false,\n\t\t\"importScripts\": false,\n\t\t\"indexedDB\": false,\n\t\t\"location\": false,\n\t\t\"MessageChannel\": false,\n\t\t\"MessagePort\": false,\n\t\t\"name\": false,\n\t\t\"navigator\": false,\n\t\t\"Notification\": false,\n\t\t\"onclose\": true,\n\t\t\"onconnect\": true,\n\t\t\"onerror\": true,\n\t\t\"onfetch\": true,\n\t\t\"oninstall\": true,\n\t\t\"onlanguagechange\": true,\n\t\t\"onmessage\": true,\n\t\t\"onmessageerror\": true,\n\t\t\"onnotificationclick\": true,\n\t\t\"onnotificationclose\": true,\n\t\t\"onoffline\": true,\n\t\t\"ononline\": true,\n\t\t\"onpush\": true,\n\t\t\"onpushsubscriptionchange\": true,\n\t\t\"onrejectionhandled\": true,\n\t\t\"onsync\": true,\n\t\t\"onunhandledrejection\": true,\n\t\t\"performance\": false,\n\t\t\"Performance\": false,\n\t\t\"PerformanceEntry\": false,\n\t\t\"PerformanceMark\": false,\n\t\t\"PerformanceMeasure\": false,\n\t\t\"PerformanceNavigation\": false,\n\t\t\"PerformanceResourceTiming\": false,\n\t\t\"PerformanceTiming\": false,\n\t\t\"postMessage\": true,\n\t\t\"Promise\": false,\n\t\t\"queueMicrotask\": false,\n\t\t\"registration\": false,\n\t\t\"removeEventListener\": false,\n\t\t\"Request\": false,\n\t\t\"Response\": false,\n\t\t\"self\": false,\n\t\t\"ServiceWorker\": false,\n\t\t\"ServiceWorkerContainer\": false,\n\t\t\"ServiceWorkerGlobalScope\": false,\n\t\t\"ServiceWorkerMessageEvent\": false,\n\t\t\"ServiceWorkerRegistration\": false,\n\t\t\"setInterval\": false,\n\t\t\"setTimeout\": false,\n\t\t\"skipWaiting\": false,\n\t\t\"TextDecoder\": false,\n\t\t\"TextEncoder\": false,\n\t\t\"URL\": false,\n\t\t\"URLSearchParams\": false,\n\t\t\"WebSocket\": false,\n\t\t\"WindowClient\": false,\n\t\t\"Worker\": false,\n\t\t\"WorkerGlobalScope\": false,\n\t\t\"XMLHttpRequest\": false\n\t},\n\t\"atomtest\": {\n\t\t\"advanceClock\": false,\n\t\t\"fakeClearInterval\": false,\n\t\t\"fakeClearTimeout\": false,\n\t\t\"fakeSetInterval\": false,\n\t\t\"fakeSetTimeout\": false,\n\t\t\"resetTimeouts\": false,\n\t\t\"waitsForPromise\": false\n\t},\n\t\"embertest\": {\n\t\t\"andThen\": false,\n\t\t\"click\": false,\n\t\t\"currentPath\": false,\n\t\t\"currentRouteName\": false,\n\t\t\"currentURL\": false,\n\t\t\"fillIn\": false,\n\t\t\"find\": false,\n\t\t\"findAll\": false,\n\t\t\"findWithAssert\": false,\n\t\t\"keyEvent\": false,\n\t\t\"pauseTest\": false,\n\t\t\"resumeTest\": false,\n\t\t\"triggerEvent\": false,\n\t\t\"visit\": false,\n\t\t\"wait\": false\n\t},\n\t\"protractor\": {\n\t\t\"$\": false,\n\t\t\"$$\": false,\n\t\t\"browser\": false,\n\t\t\"by\": false,\n\t\t\"By\": false,\n\t\t\"DartObject\": false,\n\t\t\"element\": false,\n\t\t\"protractor\": false\n\t},\n\t\"shared-node-browser\": {\n\t\t\"clearInterval\": false,\n\t\t\"clearTimeout\": false,\n\t\t\"console\": false,\n\t\t\"setInterval\": false,\n\t\t\"setTimeout\": false,\n\t\t\"URL\": false,\n\t\t\"URLSearchParams\": false\n\t},\n\t\"webextensions\": {\n\t\t\"browser\": false,\n\t\t\"chrome\": false,\n\t\t\"opr\": false\n\t},\n\t\"greasemonkey\": {\n\t\t\"cloneInto\": false,\n\t\t\"createObjectIn\": false,\n\t\t\"exportFunction\": false,\n\t\t\"GM\": false,\n\t\t\"GM_addStyle\": false,\n\t\t\"GM_deleteValue\": false,\n\t\t\"GM_getResourceText\": false,\n\t\t\"GM_getResourceURL\": false,\n\t\t\"GM_getValue\": false,\n\t\t\"GM_info\": false,\n\t\t\"GM_listValues\": false,\n\t\t\"GM_log\": false,\n\t\t\"GM_openInTab\": false,\n\t\t\"GM_registerMenuCommand\": false,\n\t\t\"GM_setClipboard\": false,\n\t\t\"GM_setValue\": false,\n\t\t\"GM_xmlhttpRequest\": false,\n\t\t\"unsafeWindow\": false\n\t},\n\t\"devtools\": {\n\t\t\"$\": false,\n\t\t\"$_\": false,\n\t\t\"$$\": false,\n\t\t\"$0\": false,\n\t\t\"$1\": false,\n\t\t\"$2\": false,\n\t\t\"$3\": false,\n\t\t\"$4\": false,\n\t\t\"$x\": false,\n\t\t\"chrome\": false,\n\t\t\"clear\": false,\n\t\t\"copy\": false,\n\t\t\"debug\": false,\n\t\t\"dir\": false,\n\t\t\"dirxml\": false,\n\t\t\"getEventListeners\": false,\n\t\t\"inspect\": false,\n\t\t\"keys\": false,\n\t\t\"monitor\": false,\n\t\t\"monitorEvents\": false,\n\t\t\"profile\": false,\n\t\t\"profileEnd\": false,\n\t\t\"queryObjects\": false,\n\t\t\"table\": false,\n\t\t\"undebug\": false,\n\t\t\"unmonitor\": false,\n\t\t\"unmonitorEvents\": false,\n\t\t\"values\": false\n\t}\n}\n", "'use strict';\nmodule.exports = require('./globals.json');\n", "import type { Node } from \"@babel/types\";\nimport type NodePath from \"./path/index.ts\";\nimport type Scope from \"./scope/index.ts\";\nimport type { HubInterface } from \"./hub.ts\";\n\nlet pathsCache: WeakMap<\n  HubInterface | typeof nullHub,\n  WeakMap<Node, Map<Node, NodePath>>\n> = new WeakMap();\nexport { pathsCache as path };\nexport let scope: WeakMap<Node, Scope> = new WeakMap();\n\nexport function clear() {\n  clearPath();\n  clearScope();\n}\n\nexport function clearPath() {\n  pathsCache = new WeakMap();\n}\n\nexport function clearScope() {\n  scope = new WeakMap();\n}\n\n// NodePath#hub can be null, but it's not a valid weakmap key because it\n// cannot be collected by GC. Use an object, knowing tht it will not be\n// collected anyway. It's not a memory leak because pathsCache.get(nullHub)\n// is itself a weakmap, so its entries can still be collected.\nconst nullHub = Object.freeze({} as const);\n\nexport function getCachedPaths(hub: HubInterface | null, parent: Node) {\n  if (!process.env.BABEL_8_BREAKING) {\n    // Only use Hub as part of the cache key in Babel 8, because it is a\n    // breaking change (it causes incompatibilities with older `@babel/core`\n    // versions: see https://github.com/babel/babel/pull/15759)\n    hub = null;\n  }\n  return pathsCache.get(hub ?? nullHub)?.get(parent);\n}\n\nexport function getOrCreateCachedPaths(hub: HubInterface | null, parent: Node) {\n  if (!process.env.BABEL_8_BREAKING) {\n    hub = null;\n  }\n\n  let parents = pathsCache.get(hub ?? nullHub);\n  if (!parents) pathsCache.set(hub ?? nullHub, (parents = new WeakMap()));\n\n  let paths = parents.get(parent);\n  if (!paths) parents.set(parent, (paths = new Map()));\n\n  return paths;\n}\n", "import Renamer from \"./lib/renamer.ts\";\nimport type NodePath from \"../path/index.ts\";\nimport traverse from \"../index.ts\";\nimport Binding from \"./binding.ts\";\nimport type { BindingKind } from \"./binding.ts\";\nimport globals from \"globals\";\nimport {\n  NOT_LOCAL_BINDING,\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isCallExpression,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMemberExpression,\n  isMethod,\n  isModuleSpecifier,\n  isNullLiteral,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isRegExpLiteral,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  expressionStatement,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName,\n  isExportDeclaration,\n  buildUndefinedNode,\n  sequenceExpression,\n} from \"@babel/types\";\nimport * as t from \"@babel/types\";\nimport { scope as scopeCache } from \"../cache.ts\";\nimport type { Visitor } from \"../types.ts\";\nimport { isExplodedVisitor } from \"../visitors.ts\";\n\ntype NodePart = string | number | boolean;\n// Recursively gathers the identifying names of a node.\nfunction gatherNodeParts(node: t.Node, parts: NodePart[]) {\n  switch (node?.type) {\n    default:\n      if (isImportDeclaration(node) || isExportDeclaration(node)) {\n        if (\n          (isExportAllDeclaration(node) ||\n            isExportNamedDeclaration(node) ||\n            isImportDeclaration(node)) &&\n          node.source\n        ) {\n          gatherNodeParts(node.source, parts);\n        } else if (\n          (isExportNamedDeclaration(node) || isImportDeclaration(node)) &&\n          node.specifiers?.length\n        ) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (\n          (isExportDefaultDeclaration(node) ||\n            isExportNamedDeclaration(node)) &&\n          node.declaration\n        ) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        // todo(flow->ts): should condition instead be:\n        //    ```\n        //    t.isExportSpecifier(node) ||\n        //    t.isImportDefaultSpecifier(node) ||\n        //    t.isImportNamespaceSpecifier(node) ||\n        //    t.isImportSpecifier(node)\n        //    ```\n        //    allowing only nodes with `.local`?\n        // @ts-expect-error todo(flow->ts)\n        gatherNodeParts(node.local, parts);\n      } else if (\n        isLiteral(node) &&\n        !isNullLiteral(node) &&\n        !isRegExpLiteral(node) &&\n        !isTemplateLiteral(node)\n      ) {\n        parts.push(node.value);\n      }\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      gatherNodeParts(node.name, parts);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\n//\ninterface CollectVisitorState {\n  assignments: NodePath<t.AssignmentExpression>[];\n  references: NodePath<t.Identifier | t.JSXIdentifier>[];\n  constantViolations: NodePath[];\n}\n\nconst collectorVisitor: Visitor<CollectVisitorState> = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n    // delegate block scope handling to the `BlockScoped` method\n    if (declar.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    // delegate block scope handling to the `BlockScoped` method\n    if (path.isBlockScoped()) return;\n\n    // delegate import handing to the `ImportDeclaration` method\n    if (path.isImportDeclaration()) return;\n\n    // this will be hit again once we traverse into it after this iteration\n    if (path.isExportDeclaration()) return;\n\n    // we've ran into a declaration!\n    const parent =\n      path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    // import may only appear in the top level or inside a module/namespace (for TS/flow)\n    const parent = path.scope.getBlockParent();\n\n    parent.registerDeclaration(path);\n  },\n\n  TSImportEqualsDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    if (t.isTSQualifiedName(path.parent) && path.parent.right === path.node) {\n      return;\n    }\n    if (path.parentPath.isTSImportEqualsDeclaration()) return;\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n    // delegate block scope handling to the `BlockScoped` method\n    else if (left.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const { node, scope } = path;\n      // ExportAllDeclaration does not have `declaration`\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n\n        const binding = scope.getBinding(id.name);\n        binding?.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding?.reference(path);\n          }\n        }\n      }\n    },\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    // Register class identifier in class' scope if this is a class declaration.\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params: Array<NodePath> = path.get(\"params\");\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    // Register function expression id after params. When the id\n    // collides with a function param, the id effectively can't be\n    // referenced: here we registered it as a constantViolation\n    if (\n      path.isFunctionExpression() &&\n      path.node.id &&\n      // @ts-expect-error Fixme: document symbol ast properties\n      !path.node.id[NOT_LOCAL_BINDING]\n    ) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (\n      path.node.id &&\n      // @ts-expect-error Fixme: document symbol ast properties\n      !path.node.id[NOT_LOCAL_BINDING]\n    ) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  TSTypeAnnotation(path) {\n    path.skip();\n  },\n};\n\nlet uid = 0;\n\nexport type { Binding };\n\nexport { Scope as default };\nclass Scope {\n  uid;\n\n  path: NodePath;\n  block: t.Pattern | t.Scopable;\n\n  inited;\n\n  labels: Map<string, NodePath<t.LabeledStatement>>;\n  bindings: { [name: string]: Binding };\n  references: { [name: string]: true };\n  globals: { [name: string]: t.Identifier | t.JSXIdentifier };\n  uids: { [name: string]: boolean };\n  data: { [key: string | symbol]: unknown };\n  crawling: boolean;\n\n  /**\n   * This searches the current \"scope\" and collects all references/bindings\n   * within.\n   */\n  constructor(path: NodePath<t.Pattern | t.Scopable>) {\n    const { node } = path;\n    const cached = scopeCache.get(node);\n    // Sometimes, a scopable path is placed higher in the AST tree.\n    // In these cases, have to create a new Scope.\n    if (cached?.path === path) {\n      return cached;\n    }\n    scopeCache.set(node, this);\n\n    this.uid = uid++;\n\n    this.block = node;\n    this.path = path;\n\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  /**\n   * Globals.\n   */\n\n  static globals = Object.keys(globals.builtin);\n\n  /**\n   * Variables available in current context.\n   */\n\n  static contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];\n\n  get parent() {\n    let parent,\n      path = this.path;\n    do {\n      // Skip method scope if coming from inside computed key or decorator expression\n      const shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if (path?.isScope()) parent = path;\n    } while (path && !parent);\n\n    return parent?.scope;\n  }\n\n  /**\n   * Generate a unique identifier and add it to the current scope.\n   */\n\n  generateDeclaredUidIdentifier(name?: string) {\n    const id = this.generateUidIdentifier(name);\n    this.push({ id });\n    return cloneNode(id);\n  }\n\n  /**\n   * Generate a unique identifier.\n   */\n\n  generateUidIdentifier(name?: string) {\n    return identifier(this.generateUid(name));\n  }\n\n  /**\n   * Generate a unique `_id1` binding.\n   */\n\n  generateUid(name: string = \"temp\"): string {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/\\d+$/g, \"\");\n\n    let uid;\n    let i = 1;\n    do {\n      uid = `_${name}`;\n      if (i > 1) uid += i;\n      i++;\n    } while (\n      this.hasLabel(uid) ||\n      this.hasBinding(uid) ||\n      this.hasGlobal(uid) ||\n      this.hasReference(uid)\n    );\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n\n    return uid;\n  }\n\n  generateUidBasedOnNode(node: t.Node, defaultName?: string) {\n    const parts: NodePart[] = [];\n    gatherNodeParts(node, parts);\n\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  /**\n   * Generate a unique identifier based on a node.\n   */\n\n  generateUidIdentifierBasedOnNode(node: t.Node, defaultName?: string) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  /**\n   * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.\n   * evaluating it won't result in potentially arbitrary code from being ran. The following are\n   * allowed and determined not to cause side effects:\n   *\n   *  - `this` expressions\n   *  - `super` expressions\n   *  - Bound identifiers\n   */\n\n  isStatic(node: t.Node): boolean {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Possibly generate a memoised identifier if it is not static and has consequences.\n   */\n\n  maybeGenerateMemoised(node: t.Node, dontPush?: boolean) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n      if (!dontPush) {\n        this.push({ id });\n        return cloneNode(id);\n      }\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(\n    local: Binding,\n    kind: BindingKind,\n    name: string,\n    id: any,\n  ) {\n    // ignore parameters\n    if (kind === \"param\") return;\n\n    // Ignore existing binding if it's the name of the current function or\n    // class expression\n    if (local.kind === \"local\") return;\n\n    const duplicate =\n      // don't allow duplicate bindings to exist alongside\n      kind === \"let\" ||\n      local.kind === \"let\" ||\n      local.kind === \"const\" ||\n      local.kind === \"module\" ||\n      // don't allow a local of param with a kind of let\n      (local.kind === \"param\" && kind === \"const\");\n\n    if (duplicate) {\n      throw this.path.hub.buildError(\n        id,\n        `Duplicate declaration \"${name}\"`,\n        TypeError,\n      );\n    }\n  }\n\n  rename(\n    oldName: string,\n    newName?: string,\n    // prettier-ignore\n    /* Babel 7 - block?: t.Pattern | t.Scopable */\n  ) {\n    const binding = this.getBinding(oldName);\n    if (binding) {\n      newName ||= this.generateUidIdentifier(oldName).name;\n      const renamer = new Renamer(binding, oldName, newName);\n      if (process.env.BABEL_8_BREAKING) {\n        renamer.rename();\n      } else {\n        // @ts-ignore(Babel 7 vs Babel 8) TODO: Delete this\n        renamer.rename(arguments[2]);\n      }\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope: Scope = this;\n    do {\n      console.log(\"#\", scope.block.type);\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind,\n        });\n      }\n    } while ((scope = scope.parent));\n    console.log(sep);\n  }\n\n  hasLabel(name: string) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name: string) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path: NodePath<t.LabeledStatement>) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path: NodePath) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n      const { kind } = path.node;\n      for (const declar of declarations) {\n        this.registerBinding(\n          kind === \"using\" || kind === \"await using\" ? \"const\" : kind,\n          declar,\n        );\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const isTypeDeclaration =\n        path.node.importKind === \"type\" || path.node.importKind === \"typeof\";\n      const specifiers = path.get(\"specifiers\");\n      for (const specifier of specifiers) {\n        const isTypeSpecifier =\n          isTypeDeclaration ||\n          (specifier.isImportSpecifier() &&\n            (specifier.node.importKind === \"type\" ||\n              specifier.node.importKind === \"typeof\"));\n\n        this.registerBinding(isTypeSpecifier ? \"unknown\" : \"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      // todo: improve babel-types\n      const declar = path.get(\"declaration\") as NodePath;\n      if (\n        declar.isClassDeclaration() ||\n        declar.isFunctionDeclaration() ||\n        declar.isVariableDeclaration()\n      ) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return buildUndefinedNode();\n  }\n\n  registerConstantViolation(path: NodePath) {\n    const ids = path.getAssignmentIdentifiers();\n    for (const name of Object.keys(ids)) {\n      this.getBinding(name)?.reassign(path);\n    }\n  }\n\n  registerBinding(\n    kind: Binding[\"kind\"],\n    path: NodePath,\n    bindingPath: NodePath = path,\n  ) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators: Array<NodePath> = path.get(\"declarations\");\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          // same identifier so continue safely as we're likely trying to register it\n          // multiple times\n          if (local.identifier === id) continue;\n\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        // A redeclaration of an existing variable is a modification\n        if (local) {\n          local.reassign(bindingPath);\n        } else {\n          this.bindings[name] = new Binding({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind,\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node: t.Identifier | t.JSXIdentifier) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name: string): boolean {\n    let scope: Scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while ((scope = scope.parent));\n\n    return false;\n  }\n\n  hasGlobal(name: string): boolean {\n    let scope: Scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while ((scope = scope.parent));\n\n    return false;\n  }\n\n  hasReference(name: string): boolean {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node: t.Node, constantsOnly?: boolean): boolean {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (\n      isThisExpression(node) ||\n      isMetaProperty(node) ||\n      isTopicReference(node) ||\n      isPrivateName(node)\n    ) {\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isBinary(node)) {\n      return (\n        this.isPure(node.left, constantsOnly) &&\n        this.isPure(node.right, constantsOnly)\n      );\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return true;\n    } else if (isProperty(node)) {\n      // @ts-expect-error todo(flow->ts): computed in not present on private properties\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isTaggedTemplateExpression(node)) {\n      return (\n        matchesPattern(node.tag, \"String.raw\") &&\n        !this.hasBinding(\"String\", { noGlobals: true }) &&\n        this.isPure(node.quasi, constantsOnly)\n      );\n    } else if (isMemberExpression(node)) {\n      return (\n        !node.computed &&\n        isIdentifier(node.object) &&\n        node.object.name === \"Symbol\" &&\n        isIdentifier(node.property) &&\n        node.property.name !== \"for\" &&\n        !this.hasBinding(\"Symbol\", { noGlobals: true })\n      );\n    } else if (isCallExpression(node)) {\n      return (\n        matchesPattern(node.callee, \"Symbol.for\") &&\n        !this.hasBinding(\"Symbol\", { noGlobals: true }) &&\n        node.arguments.length === 1 &&\n        t.isStringLiteral(node.arguments[0])\n      );\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  /**\n   * Set some arbitrary data on the current scope.\n   */\n\n  setData(key: string | symbol, val: any) {\n    return (this.data[key] = val);\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key`.\n   */\n\n  getData(key: string | symbol): any {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while ((scope = scope.parent));\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key` and if it exists,\n   * remove it.\n   */\n\n  removeData(key: string) {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while ((scope = scope.parent));\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    let scope: Scope = this;\n    do {\n      if (scope.crawling) return;\n      if (scope.path.isProgram()) {\n        break;\n      }\n    } while ((scope = scope.parent));\n\n    const programParent = scope;\n\n    const state: CollectVisitorState = {\n      references: [],\n      constantViolations: [],\n      assignments: [],\n    };\n\n    this.crawling = true;\n    // traverse does not visit the root node, here we explicitly collect\n    // root node binding info when the root is not a Program.\n    if (path.type !== \"Program\" && isExplodedVisitor(collectorVisitor)) {\n      for (const visit of collectorVisitor.enter) {\n        visit.call(state, path, state);\n      }\n      const typeVisitors = collectorVisitor[path.type];\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit.call(state, path, state);\n        }\n      }\n    }\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    // register assignments\n    for (const path of state.assignments) {\n      // register undeclared bindings as globals\n      const ids = path.getAssignmentIdentifiers();\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      // register as constant violation\n      path.scope.registerConstantViolation(path);\n    }\n\n    // register references\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    // register constant violations\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts: {\n    id: t.ArrayPattern | t.Identifier | t.ObjectPattern;\n    init?: t.Expression;\n    unique?: boolean;\n    _blockHoist?: number | undefined;\n    kind?: \"var\" | \"let\" | \"const\";\n  }) {\n    let path = this.path;\n\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    const { init, unique, kind = \"var\", id } = opts;\n\n    // When injecting a non-const non-initialized binding inside\n    // an IIFE, if the number of call arguments is less than or\n    // equal to the number of function parameters, we can safely\n    // inject the binding into the parameter list.\n    if (\n      !init &&\n      !unique &&\n      (kind === \"var\" || kind === \"let\") &&\n      path.isFunction() &&\n      // @ts-expect-error ArrowFunctionExpression never has a name\n      !path.node.name &&\n      isCallExpression(path.parent, { callee: path.node }) &&\n      path.parent.arguments.length <= path.node.params.length &&\n      isIdentifier(id)\n    ) {\n      path.pushContainer(\"params\", id);\n      path.scope.registerBinding(\n        \"param\",\n        path.get(\"params\")[path.node.params.length - 1],\n      );\n      return;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      // @ts-expect-error todo(flow->ts): avoid modifying nodes\n      declar._blockHoist = blockHoist;\n\n      [declarPath] = (path as NodePath<t.BlockStatement>).unshiftContainer(\n        \"body\",\n        [declar],\n      );\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(id, init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n\n  /**\n   * Walk up to the top of the scope tree and get the `Program`.\n   */\n\n  getProgramParent() {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a Function or return null.\n   */\n\n  getFunctionParent(): Scope | null {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    return null;\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a BlockStatement/Loop/Program/Function/Switch or reach the\n   * very top and hit Program.\n   */\n\n  getBlockParent() {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walk up from a pattern scope (function param initializer) until we hit a non-pattern scope,\n   * then returns its block parent\n   * @returns An ancestry scope whose path is a block parent\n   */\n  getPatternParent() {\n    let scope: Scope = this;\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while ((scope = scope.parent.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walks the scope tree and gathers **all** bindings.\n   */\n\n  getAllBindings(): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    let scope: Scope = this;\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name: string, node: t.Node): boolean {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name: string): Binding | undefined {\n    let scope: Scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n      if (binding) {\n        // Check if a pattern is a part of parameter expressions.\n        // Note: for performance reason we skip checking previousPath.parentPath.isFunction()\n        // because `scope.path` is validated as scope in packages/babel-types/src/validators/isScope.js\n        // That is, if a scope path is pattern, its parent must be Function/CatchClause\n\n        // Spec 9.2.10.28: The closure created by this expression should not have visibility of\n        // declarations in the function body. If the binding is not a `param`-kind (as function parameters)\n        // or `local`-kind (as id in function expression),\n        // then it must be defined inside the function body, thus it should be skipped\n        if (\n          previousPath?.isPattern() &&\n          binding.kind !== \"param\" &&\n          binding.kind !== \"local\"\n        ) {\n          // do nothing\n        } else {\n          return binding;\n        }\n      } else if (\n        !binding &&\n        name === \"arguments\" &&\n        scope.path.isFunction() &&\n        !scope.path.isArrowFunctionExpression()\n      ) {\n        break;\n      }\n      previousPath = scope.path;\n    } while ((scope = scope.parent));\n  }\n\n  getOwnBinding(name: string): Binding | undefined {\n    return this.bindings[name];\n  }\n\n  // todo: return probably can be undefined\n  getBindingIdentifier(name: string): t.Identifier {\n    return this.getBinding(name)?.identifier;\n  }\n\n  // todo: flow->ts return probably can be undefined\n  getOwnBindingIdentifier(name: string): t.Identifier {\n    const binding = this.bindings[name];\n    return binding?.identifier;\n  }\n\n  hasOwnBinding(name: string) {\n    return !!this.getOwnBinding(name);\n  }\n\n  // By default, we consider generated UIDs as bindings.\n  // This is because they are almost always used to declare variables,\n  // and since the scope isn't always up-to-date it's better to assume that\n  // there is a variable with that name. The `noUids` option can be used to\n  // turn off this behavior, for example if you know that the generate UID\n  // was used to declare a variable in a different scope.\n  hasBinding(\n    name: string,\n    opts?: boolean | { noGlobals?: boolean; noUids?: boolean },\n  ) {\n    if (!name) return false;\n    let scope: Scope = this;\n    do {\n      if (scope.hasOwnBinding(name)) {\n        return true;\n      }\n    } while ((scope = scope.parent));\n\n    // TODO: Only accept the object form.\n    let noGlobals;\n    let noUids;\n    if (typeof opts === \"object\") {\n      noGlobals = opts.noGlobals;\n      noUids = opts.noUids;\n    } else if (typeof opts === \"boolean\") {\n      noGlobals = opts;\n    }\n\n    if (!noUids && this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(\n    name: string,\n    opts?: { noGlobals?: boolean; noUids?: boolean },\n  ) {\n    return this.parent?.hasBinding(name, opts);\n  }\n\n  /**\n   * Move a binding of `name` to another `scope`.\n   */\n\n  moveBindingTo(name: string, scope: Scope) {\n    const info = this.getBinding(name);\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name: string) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name: string) {\n    // clear literal binding\n    this.getBinding(name)?.scope.removeOwnBinding(name);\n\n    // clear uids with this name - https://github.com/babel/babel/issues/2101\n    let scope: Scope = this;\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while ((scope = scope.parent));\n  }\n\n  /**\n   * Hoist all the `var` variable to the beginning of the function/program\n   * scope where their binding will be actually defined. For exmaple,\n   *     { var x = 2 }\n   * will be transformed to\n   *     var x; { x = 2 }\n   *\n   * @param emit A custom function to emit `var` declarations, for example to\n   *   emit them in a different scope.\n   */\n  hoistVariables(\n    emit: (id: t.Identifier, hasInit: boolean) => void = id =>\n      this.push({ id }),\n  ) {\n    this.crawl();\n\n    const seen = new Set();\n    for (const name of Object.keys(this.bindings)) {\n      const binding = this.bindings[name];\n      if (!binding) continue;\n      const { path } = binding;\n      if (!path.isVariableDeclarator()) continue;\n      const { parent, parentPath } = path;\n\n      if (parent.kind !== \"var\" || seen.has(parent)) continue;\n      seen.add(path.parent);\n\n      let firstId;\n      const init = [];\n      for (const decl of parent.declarations) {\n        firstId ??= decl.id;\n        if (decl.init) {\n          init.push(assignmentExpression(\"=\", decl.id, decl.init));\n        }\n\n        const ids = Object.keys(getBindingIdentifiers(decl, false, true, true));\n        for (const name of ids) {\n          emit(identifier(name), decl.init != null);\n        }\n      }\n\n      // for (var i in test)\n      if (parentPath.parentPath.isFor({ left: parent })) {\n        parentPath.replaceWith(firstId);\n      } else if (init.length === 0) {\n        parentPath.remove();\n      } else {\n        const expr = init.length === 1 ? init[0] : sequenceExpression(init);\n        if (parentPath.parentPath.isForStatement({ init: parent })) {\n          parentPath.replaceWith(expr);\n        } else {\n          parentPath.replaceWith(expressionStatement(expr));\n        }\n      }\n    }\n  }\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /** @deprecated Not used in our codebase */\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype._renameFromMap = function _renameFromMap(\n    map: Record<string | symbol, unknown>,\n    oldName: string | symbol,\n    newName: string | symbol,\n    value: unknown,\n  ) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  };\n\n  /**\n   * Traverse node with current scope and path.\n   *\n   * !!! WARNING !!!\n   * This method assumes that `this.path` is the NodePath representing `node`.\n   * After running the traversal, the `.parentPath` of the NodePaths\n   * corresponding to `node`'s children will be set to `this.path`.\n   *\n   * There is no good reason to use this method, since the only safe way to use\n   * it is equivalent to `scope.path.traverse(opts, state)`.\n   */\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype.traverse = function <S>(\n    this: Scope,\n    node: any,\n    opts: any,\n    state?: S,\n  ) {\n    traverse(node, opts, this, state, this.path);\n  };\n\n  /**\n   * Generate an `_id1`.\n   */\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype._generateUid = function _generateUid(\n    name: string,\n    i: number,\n  ) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  };\n\n  // TODO: (Babel 8) Split i in two parameters, and use an object of flags\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype.toArray = function toArray(\n    this: Scope,\n    node: t.Node,\n    i?: number | boolean,\n    arrayLikeIsIterable?: boolean | void,\n  ) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding?.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, { name: \"arguments\" })) {\n      return callExpression(\n        memberExpression(\n          memberExpression(\n            memberExpression(identifier(\"Array\"), identifier(\"prototype\")),\n            identifier(\"slice\"),\n          ),\n          identifier(\"call\"),\n        ),\n        [node],\n      );\n    }\n\n    let helperName;\n    const args = [node];\n    if (i === true) {\n      // Used in array-spread to create an array.\n      helperName = \"toConsumableArray\";\n    } else if (typeof i === \"number\") {\n      args.push(numericLiteral(i));\n\n      // Used in array-rest to create an array from a subset of an iterable.\n      helperName = \"slicedToArray\";\n      // TODO if (this.hub.isLoose(\"es6.forOf\")) helperName += \"-loose\";\n    } else {\n      // Used in array-rest to create an array\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.path.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    // @ts-expect-error todo(flow->ts): t.Node is not valid to use in args, function argument typeneeds to be clarified\n    return callExpression(this.path.hub.addHelper(helperName), args);\n  };\n\n  /**\n   * Walks the scope tree and gathers all declarations of `kind`.\n   */\n  // @ts-expect-error Babel 7 compatibility\n  Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(\n    ...kinds: string[]\n  ): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope: Scope = this;\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  };\n\n  Object.defineProperties(Scope.prototype, {\n    parentBlock: {\n      configurable: true,\n      enumerable: true,\n      get(this: Scope) {\n        return this.path.parent;\n      },\n    },\n    hub: {\n      configurable: true,\n      enumerable: true,\n      get(this: Scope) {\n        return this.path.hub;\n      },\n    },\n  });\n}\n\ntype _Binding = Binding;\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace Scope {\n  export type Binding = _Binding;\n}\n", "// This file contains that retrieve or validate anything related to the current paths ancestry.\n\nimport { VISITOR_KEYS } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type NodePath from \"./index.ts\";\n\n/**\n * Starting at the parent path of the current `NodePath` and going up the\n * tree, return the first `NodePath` that causes the provided `callback`\n * to return a truthy value, or `null` if the `callback` never returns a\n * truthy value.\n */\n\nexport function findParent(\n  this: NodePath,\n  callback: (path: NodePath) => boolean,\n): NodePath | null {\n  let path = this;\n  while ((path = path.parentPath)) {\n    if (callback(path)) return path;\n  }\n  return null;\n}\n\n/**\n * Starting at current `NodePath` and going up the tree, return the first\n * `NodePath` that causes the provided `callback` to return a truthy value,\n * or `null` if the `callback` never returns a truthy value.\n */\n\nexport function find(\n  this: NodePath,\n  callback: (path: NodePath) => boolean,\n): NodePath | null {\n  let path = this;\n  do {\n    if (callback(path)) return path;\n  } while ((path = path.parentPath));\n  return null;\n}\n\n/**\n * Get the parent function of the current path.\n */\n\nexport function getFunctionParent(this: NodePath): NodePath<t.Function> | null {\n  return this.findParent(p => p.isFunction()) as NodePath<t.Function> | null;\n}\n\n/**\n * Walk up the tree until we hit a parent node path in a list.\n */\n\nexport function getStatementParent(this: NodePath): NodePath<t.Statement> {\n  let path = this;\n\n  do {\n    if (\n      !path.parentPath ||\n      (Array.isArray(path.container) && path.isStatement())\n    ) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\n      \"File/Program node, we can't possibly find a statement parent to this\",\n    );\n  }\n\n  return path as NodePath<t.Statement>;\n}\n\n/**\n * Get the deepest common ancestor and then from it, get the earliest relationship path\n * to that ancestor.\n *\n * Earliest is defined as being \"before\" all the other nodes in terms of list container\n * position and visiting key.\n */\n\nexport function getEarliestCommonAncestorFrom(\n  this: NodePath,\n  paths: Array<NodePath>,\n): NodePath {\n  return this.getDeepestCommonAncestorFrom(\n    paths,\n    function (deepest, i, ancestries) {\n      let earliest;\n      const keys = VISITOR_KEYS[deepest.type];\n\n      for (const ancestry of ancestries) {\n        const path = ancestry[i + 1];\n\n        // first path\n        if (!earliest) {\n          earliest = path;\n          continue;\n        }\n\n        // handle containers\n        if (path.listKey && earliest.listKey === path.listKey) {\n          // we're in the same container so check if we're earlier\n          if (path.key < earliest.key) {\n            earliest = path;\n            continue;\n          }\n        }\n\n        // handle keys\n        const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n        const currentKeyIndex = keys.indexOf(path.parentKey);\n        if (earliestKeyIndex > currentKeyIndex) {\n          // key appears before so it's earlier\n          earliest = path;\n        }\n      }\n\n      return earliest;\n    },\n  );\n}\n\n/**\n * Get the earliest path in the tree where the provided `paths` intersect.\n *\n * TODO: Possible optimisation target.\n */\n\nexport function getDeepestCommonAncestorFrom(\n  this: NodePath,\n  paths: Array<NodePath>,\n  filter?: (deepest: NodePath, i: number, ancestries: NodePath[][]) => NodePath,\n): NodePath {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  // minimum depth of the tree so we know the highest node\n  let minDepth = Infinity;\n\n  // last common ancestor\n  let lastCommonIndex, lastCommon;\n\n  // get the ancestors of the path, breaking when the parent exceeds ourselves\n  const ancestries = paths.map(path => {\n    const ancestry: NodePath[] = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    // save min depth to avoid going too far in\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n\n  // get the first ancestry so we have a seed to assess all other ancestries with\n  const first = ancestries[0];\n\n  // check ancestor equality\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        // we've hit a snag\n        break depthLoop;\n      }\n    }\n\n    // next iteration may break so store these so they can be returned\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\n/**\n * Build an array of node paths containing the entire ancestry of the current node path.\n *\n * NOTE: The current node path is included in this.\n */\n\nexport function getAncestry(this: NodePath): Array<NodePath> {\n  let path = this;\n  const paths = [];\n  do {\n    paths.push(path);\n  } while ((path = path.parentPath));\n  return paths;\n}\n\n/**\n * A helper to find if `this` path is an ancestor of @param maybeDescendant\n */\nexport function isAncestor(this: NodePath, maybeDescendant: NodePath): boolean {\n  return maybeDescendant.isDescendant(this);\n}\n\n/**\n * A helper to find if `this` path is a descendant of @param maybeAncestor\n */\nexport function isDescendant(this: NodePath, maybeAncestor: NodePath): boolean {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nexport function inType(this: NodePath, ...candidateTypes: string[]): boolean {\n  let path = this;\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n    path = path.parentPath;\n  }\n\n  return false;\n}\n", "import {\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  isFlowType,\n  isTSType,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport function createUnionType(\n  types: (t.FlowType | t.TSType)[],\n): t.FlowType | t.TSType | undefined {\n  if (process.env.BABEL_8_BREAKING) {\n    if (types.every(v => isFlowType(v))) {\n      return createFlowUnionType(types);\n    }\n    if (types.every(v => isTSType(v))) {\n      return createTSUnionType(types);\n    }\n  } else {\n    if (types.every(v => isFlowType(v))) {\n      if (createFlowUnionType) {\n        return createFlowUnionType(types);\n      }\n\n      return createUnionTypeAnnotation(types);\n    } else if (types.every(v => isTSType(v))) {\n      if (createTSUnionType) {\n        return createTSUnionType(types);\n      }\n    }\n  }\n}\n", "import type NodePath from \"../index.ts\";\nimport {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Binding from \"../../scope/binding.ts\";\n\nimport { createUnionType } from \"./util.ts\";\n\nexport default function (this: NodePath<t.Identifier>, node: t.Identifier) {\n  if (!this.isReferenced()) return;\n\n  // check if a binding exists of this value and if so then return a union type of all\n  // possible types that the binding could be\n  const binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(\n        binding,\n        this,\n        node.name,\n      );\n    }\n  }\n\n  // built-in values\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {\n    // todo\n  }\n}\n\nfunction getTypeAnnotationBindingConstantViolations(\n  binding: Binding,\n  path: NodePath<t.Identifier>,\n  name: string,\n) {\n  const types = [];\n\n  const functionConstantViolations: NodePath[] = [];\n  let constantViolations = getConstantViolationsBefore(\n    binding,\n    path,\n    functionConstantViolations,\n  );\n\n  const testType = getConditionalAnnotation(binding, path, name);\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(\n      binding,\n      testType.ifStatement,\n    );\n\n    // remove constant violations observed before the IfStatement\n    constantViolations = constantViolations.filter(\n      path => !testConstantViolations.includes(path),\n    );\n\n    // clear current types and add in observed test type\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    // pick one constant from each scope which will represent the last possible\n    // control flow path that it could've taken/been\n    /* This code is broken for the following problems:\n     * It thinks that assignments can only happen in scopes.\n     * What about conditionals, if statements without block,\n     * or guarded assignments.\n     * It also checks to see if one of the assignments is in the\n     * same scope and uses that as the only \"violation\". However,\n     * the binding is returned by `getConstantViolationsBefore` so we for\n     * sure always going to return that as the only \"violation\".\n    let rawConstantViolations = constantViolations.reverse();\n    let visitedScopes = [];\n    constantViolations = [];\n    for (let violation of (rawConstantViolations: Array<NodePath>)) {\n      let violationScope = violation.scope;\n      if (visitedScopes.indexOf(violationScope) >= 0) continue;\n\n      visitedScopes.push(violationScope);\n      constantViolations.push(violation);\n\n      if (violationScope === path.scope) {\n        constantViolations = [violation];\n        break;\n      }\n    }*/\n\n    // add back on function constant violations since we can't track calls\n    constantViolations.push(...functionConstantViolations);\n\n    // push on inferred types of violated paths\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  return createUnionType(types);\n}\n\nfunction getConstantViolationsBefore(\n  binding: Binding,\n  path: NodePath,\n  functions?: NodePath[],\n) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n    const status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(\n  name: string,\n  path: NodePath<t.BinaryExpression>,\n) {\n  const operator = path.node.operator;\n\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n\n  let target;\n  if (left.isIdentifier({ name })) {\n    target = right;\n  } else if (right.isIdentifier({ name })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n\n  let typeofPath: NodePath<t.UnaryExpression>;\n  let typePath: NodePath<t.Expression>;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right as NodePath<t.Expression>;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left as NodePath<t.Expression>;\n  }\n\n  if (!typeofPath) return;\n  // and that the argument of the typeof path references us!\n  if (!typeofPath.get(\"argument\").isIdentifier({ name })) return;\n\n  // ensure that the type path is a Literal\n  typePath = typePath.resolve() as NodePath<t.Expression>;\n  if (!typePath.isLiteral()) return;\n\n  // and that it's a string so we can infer it\n  // @ts-expect-error todo(flow->ts): value is not defined for NullLiteral and some other\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  // turn type value into a type annotation\n  // @ts-expect-error todo(flow->ts): move validation from helper or relax type constraint to just a string\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(\n  binding: Binding,\n  path: NodePath,\n  name: string,\n) {\n  let parentPath;\n  while ((parentPath = path.parentPath)) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath as NodePath<t.IfStatement | t.ConditionalExpression>;\n    }\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation<T extends t.Node>(\n  binding: Binding,\n  path: NodePath<T>,\n  name?: string,\n): {\n  typeAnnotation: t.FlowType | t.TSType;\n  ifStatement: NodePath<t.IfStatement | t.ConditionalExpression>;\n} {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    return {\n      typeAnnotation: createUnionType(types),\n      ifStatement,\n    };\n  }\n\n  return getConditionalAnnotation(binding, ifStatement, name);\n}\n", "import {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  genericTypeAnnotation,\n  identifier,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation,\n  isIdentifier,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport { default as Identifier } from \"./inferer-reference.ts\";\n\nimport { createUnionType } from \"./util.ts\";\nimport type NodePath from \"../index.ts\";\n\nexport function VariableDeclarator(this: NodePath<t.VariableDeclarator>) {\n  if (!this.get(\"id\").isIdentifier()) return;\n  return this.get(\"init\").getTypeAnnotation();\n}\n\nexport function TypeCastExpression(node: t.TypeCastExpression) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nexport function TSAsExpression(node: t.TSAsExpression) {\n  return node.typeAnnotation;\n}\n\nTSAsExpression.validParent = true;\n\nexport function TSNonNullExpression(this: NodePath<t.TSNonNullExpression>) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function NewExpression(\n  this: NodePath<t.NewExpression>,\n  node: t.NewExpression,\n) {\n  if (node.callee.type === \"Identifier\") {\n    // only resolve identifier callee\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nexport function TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function UnaryExpression(node: t.UnaryExpression) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.includes(operator)) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  }\n}\n\nexport function BinaryExpression(\n  this: NodePath<t.BinaryExpression>,\n  node: t.BinaryExpression,\n) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      // both numbers so this will be a number\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      // one is a string so the result will be a string\n      return stringTypeAnnotation();\n    }\n\n    // unsure if left and right are strings or numbers so stay on the safe side\n    return unionTypeAnnotation([\n      stringTypeAnnotation(),\n      numberTypeAnnotation(),\n    ]);\n  }\n}\n\nexport function LogicalExpression(this: NodePath<t.LogicalExpression>) {\n  const argumentTypes = [\n    this.get(\"left\").getTypeAnnotation(),\n    this.get(\"right\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function ConditionalExpression(this: NodePath<t.ConditionalExpression>) {\n  const argumentTypes = [\n    this.get(\"consequent\").getTypeAnnotation(),\n    this.get(\"alternate\").getTypeAnnotation(),\n  ];\n\n  return createUnionType(argumentTypes);\n}\n\nexport function SequenceExpression(this: NodePath<t.SequenceExpression>) {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nexport function ParenthesizedExpression(\n  this: NodePath<t.ParenthesizedExpression>,\n) {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nexport function AssignmentExpression(this: NodePath<t.AssignmentExpression>) {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nexport function UpdateExpression(\n  this: NodePath<t.UpdateExpression>,\n  node: t.UpdateExpression,\n) {\n  const operator = node.operator;\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nexport function StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nexport function NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nexport function BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nexport function NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nexport function RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nexport function ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nexport function ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nexport function RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nexport {\n  Func as FunctionExpression,\n  Func as ArrowFunctionExpression,\n  Func as FunctionDeclaration,\n  Func as ClassExpression,\n  Func as ClassDeclaration,\n};\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\nexport function CallExpression(this: NodePath<t.CallExpression>) {\n  const { callee } = this.node;\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (\n    isArrayFrom(callee) ||\n    isObjectValues(callee) ||\n    // Detect \"var foo = Array()\" calls so we can optimize for arrays vs iterables.\n    isIdentifier(callee, { name: \"Array\" })\n  ) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(\n      tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]),\n    );\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nexport function TaggedTemplateExpression(\n  this: NodePath<t.TaggedTemplateExpression>,\n) {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee: NodePath) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    const { node } = callee;\n    if (node.async) {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"Iterator\"));\n      } else if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {\n        // todo: get union type of all return arguments\n      }\n    }\n  }\n}\n", "import type NodePath from \"../index.ts\";\nimport * as inferers from \"./inferers.ts\";\nimport {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Infer the type of the current `NodePath`.\n */\n\nexport function getTypeAnnotation(this: NodePath): t.FlowType | t.TSType {\n  let type = this.getData(\"typeAnnotation\");\n  if (type != null) {\n    return type;\n  }\n  type = _getTypeAnnotation.call(this) || anyTypeAnnotation();\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {\n    type = type.typeAnnotation;\n  }\n  this.setData(\"typeAnnotation\", type);\n  return type;\n}\n\n// Used to avoid infinite recursion in cases like\n//   var b, c; if (0) { c = 1; b = c; } c = b;\n// It also works with indirect recursion.\nconst typeAnnotationInferringNodes = new WeakSet();\n\n/**\n * todo: split up this method\n */\n\nexport function _getTypeAnnotation(this: NodePath): any {\n  const node = this.node;\n\n  if (!node) {\n    // handle initializerless variables, add in checks for loop initializers too\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      // for (let NODE in bar) {}\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      // for (let NODE of bar) {}\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  // @ts-expect-error typeAnnotation may not index node\n  if (node.typeAnnotation) {\n    // @ts-expect-error typeAnnotation may not index node\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    // Bail out from type inference to avoid infinite loops\n    return;\n  }\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    let inferer =\n      // @ts-expect-error inferers do not cover all AST types\n      inferers[node.type];\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    // @ts-expect-error inferers do not cover all AST types\n    inferer = inferers[this.parentPath.type];\n    if (inferer?.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nexport function isBaseType(\n  this: NodePath,\n  baseName: string,\n  soft?: boolean,\n): boolean {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(\n  baseName: string,\n  type?: t.FlowType | t.TSType,\n  soft?: boolean,\n): boolean {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nexport function couldBeBaseType(this: NodePath, name: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nexport function baseTypeStrictlyMatches(\n  this: NodePath,\n  rightArg: NodePath,\n): boolean {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n  return false;\n}\n\nexport function isGenericType(this: NodePath, genericName: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (genericName === \"Array\") {\n    // T[]\n    if (\n      isTSArrayType(type) ||\n      isArrayTypeAnnotation(type) ||\n      isTupleTypeAnnotation(type)\n    ) {\n      return true;\n    }\n  }\n  return (\n    (isGenericTypeAnnotation(type) &&\n      isIdentifier(type.id, {\n        name: genericName,\n      })) ||\n    (isTSTypeReference(type) &&\n      isIdentifier(type.typeName, {\n        name: genericName,\n      }))\n  );\n}\n", "var x=String;\nvar create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x,blackBright:x,redBright:x,greenBright:x,yellowBright:x,blueBright:x,magentaBright:x,cyanBright:x,whiteBright:x,bgBlackBright:x,bgRedBright:x,bgGreenBright:x,bgYellowBright:x,bgBlueBright:x,bgMagentaBright:x,bgCyanBright:x,bgWhiteBright:x}};\nmodule.exports=create();\nmodule.exports.createColors = create;\n", "// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell\n// License: MIT. (See LICENSE.)\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n})\n\n// This regex comes from regex.coffee, and is inserted here by generate-index.js\n// (run `npm run build`).\nexports.default = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g\n\nexports.matchToToken = function(match) {\n  var token = {type: \"invalid\", value: match[0], closed: undefined}\n       if (match[ 1]) token.type = \"string\" , token.closed = !!(match[3] || match[4])\n  else if (match[ 5]) token.type = \"comment\"\n  else if (match[ 6]) token.type = \"comment\", token.closed = !!match[7]\n  else if (match[ 8]) token.type = \"regex\"\n  else if (match[ 9]) token.type = \"number\"\n  else if (match[10]) token.type = \"name\"\n  else if (match[11]) token.type = \"punctuator\"\n  else if (match[12]) token.type = \"whitespace\"\n  return token\n}\n", "import picocolors, { createColors } from \"picocolors\";\nimport type { Colors, Formatter } from \"picocolors/types\";\n\nexport function isColorSupported() {\n  return (\n    // See https://github.com/alexeyraspopov/picocolors/issues/62\n    typeof process === \"object\" &&\n      (process.env.FORCE_COLOR === \"0\" || process.env.FORCE_COLOR === \"false\")\n      ? false\n      : picocolors.isColorSupported\n  );\n}\n\nexport type InternalTokenType =\n  | \"keyword\"\n  | \"capitalized\"\n  | \"jsxIdentifier\"\n  | \"punctuator\"\n  | \"number\"\n  | \"string\"\n  | \"regex\"\n  | \"comment\"\n  | \"invalid\";\n\ntype UITokens = \"gutter\" | \"marker\" | \"message\";\n\nexport type Defs = {\n  [_ in InternalTokenType | UITokens | \"reset\"]: Formatter;\n};\n\nconst compose: <T, U, V>(f: (gv: U) => V, g: (v: T) => U) => (v: T) => V =\n  (f, g) => v =>\n    f(g(v));\n\n/**\n * Styles for token types.\n */\nfunction buildDefs(colors: Colors): Defs {\n  return {\n    keyword: colors.cyan,\n    capitalized: colors.yellow,\n    jsxIdentifier: colors.yellow,\n    punctuator: colors.yellow,\n    number: colors.magenta,\n    string: colors.green,\n    regex: colors.magenta,\n    comment: colors.gray,\n    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),\n\n    gutter: colors.gray,\n    marker: compose(colors.red, colors.bold),\n    message: compose(colors.red, colors.bold),\n\n    reset: colors.reset,\n  };\n}\n\nconst defsOn = buildDefs(createColors(true));\nconst defsOff = buildDefs(createColors(false));\n\nexport function getDefs(enabled: boolean): Defs {\n  return enabled ? defsOn : defsOff;\n}\n", "import type { Token as JSToken, JSXToken } from \"js-tokens\";\nimport jsTokens from \"js-tokens\";\n\nimport {\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nimport { getDefs, type InternalTokenType } from \"./defs.ts\";\n\n/**\n * Names that are always allowed as identifiers, but also appear as keywords\n * within certain syntactic productions.\n *\n * https://tc39.es/ecma262/#sec-keywords-and-reserved-words\n *\n * `target` has been omitted since it is very likely going to be a false\n * positive.\n */\nconst sometimesKeywords = new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\n\ntype Token = {\n  type: InternalTokenType | \"uncolored\";\n  value: string;\n};\n\n/**\n * RegExp to test for newlines in terminal.\n */\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * RegExp to test for the three types of brackets.\n */\nconst BRACKET = /^[()[\\]{}]$/;\n\nlet tokenize: (\n  text: string,\n) => Generator<{ type: InternalTokenType | \"uncolored\"; value: string }>;\n\nif (process.env.BABEL_8_BREAKING) {\n  /**\n   * Get the type of token, specifying punctuator type.\n   */\n  const getTokenType = function (\n    token: JSToken | JSXToken,\n  ): InternalTokenType | \"uncolored\" {\n    if (token.type === \"IdentifierName\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"Punctuator\" && BRACKET.test(token.value)) {\n      return \"uncolored\";\n    }\n\n    if (token.type === \"Invalid\" && token.value === \"@\") {\n      return \"punctuator\";\n    }\n\n    switch (token.type) {\n      case \"NumericLiteral\":\n        return \"number\";\n\n      case \"StringLiteral\":\n      case \"JSXString\":\n      case \"NoSubstitutionTemplate\":\n        return \"string\";\n\n      case \"RegularExpressionLiteral\":\n        return \"regex\";\n\n      case \"Punctuator\":\n      case \"JSXPunctuator\":\n        return \"punctuator\";\n\n      case \"MultiLineComment\":\n      case \"SingleLineComment\":\n        return \"comment\";\n\n      case \"Invalid\":\n      case \"JSXInvalid\":\n        return \"invalid\";\n\n      case \"JSXIdentifier\":\n        return \"jsxIdentifier\";\n\n      default:\n        return \"uncolored\";\n    }\n  };\n\n  /**\n   * Turn a string of JS into an array of objects.\n   */\n  tokenize = function* (text: string): Generator<Token> {\n    for (const token of jsTokens(text, { jsx: true })) {\n      switch (token.type) {\n        case \"TemplateHead\":\n          yield { type: \"string\", value: token.value.slice(0, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateMiddle\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateTail\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1) };\n          break;\n\n        default:\n          yield {\n            type: getTokenType(token),\n            value: token.value,\n          };\n      }\n    }\n  };\n} else {\n  /**\n   * RegExp to test for what seems to be a JSX tag name.\n   */\n  const JSX_TAG = /^[a-z][\\w-]*$/i;\n\n  // The token here is defined in js-tokens@4. However we don't bother\n  // typing it since the whole block will be removed in Babel 8\n  const getTokenType = function (token: any, offset: number, text: string) {\n    if (token.type === \"name\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (\n        JSX_TAG.test(token.value) &&\n        (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) === \"</\")\n      ) {\n        return \"jsxIdentifier\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n      return \"bracket\";\n    }\n\n    if (\n      token.type === \"invalid\" &&\n      (token.value === \"@\" || token.value === \"#\")\n    ) {\n      return \"punctuator\";\n    }\n\n    return token.type;\n  };\n\n  tokenize = function* (text: string) {\n    let match;\n    while ((match = (jsTokens as any).default.exec(text))) {\n      const token = (jsTokens as any).matchToToken(match);\n\n      yield {\n        type: getTokenType(token, match.index, text),\n        value: token.value,\n      };\n    }\n  };\n}\n\nexport function highlight(text: string) {\n  if (text === \"\") return \"\";\n\n  const defs = getDefs(true);\n\n  let highlighted = \"\";\n\n  for (const { type, value } of tokenize(text)) {\n    if (type in defs) {\n      highlighted += value\n        .split(NEWLINE)\n        .map(str => defs[type as InternalTokenType](str))\n        .join(\"\\n\");\n    } else {\n      highlighted += value;\n    }\n  }\n\n  return highlighted;\n}\n", "import { getDefs, isColorSupported } from \"./defs.ts\";\nimport { highlight } from \"./highlight.ts\";\n\nexport { highlight };\n\nlet deprecationWarningShown = false;\n\ntype Location = {\n  column: number;\n  line: number;\n};\n\ntype NodeLocation = {\n  end?: Location;\n  start: Location;\n};\n\nexport interface Options {\n  /** Syntax highlight the code as JavaScript for terminals. default: false */\n  highlightCode?: boolean;\n  /**  The number of lines to show above the error. default: 2 */\n  linesAbove?: number;\n  /**  The number of lines to show below the error. default: 3 */\n  linesBelow?: number;\n  /**\n   * Forcibly syntax highlight the code as JavaScript (for non-terminals);\n   * overrides highlightCode.\n   * default: false\n   */\n  forceColor?: boolean;\n  /**\n   * Pass in a string to be displayed inline (if possible) next to the\n   * highlighted location in the code. If it can't be positioned inline,\n   * it will be placed above the code frame.\n   * default: nothing\n   */\n  message?: string;\n}\n\n/**\n * RegExp to test for newlines in terminal.\n */\n\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * Extract what lines should be marked and highlighted.\n */\n\ntype MarkerLines = Record<number, true | [number, number]>;\n\nfunction getMarkerLines(\n  loc: NodeLocation,\n  source: Array<string>,\n  opts: Options,\n): {\n  start: number;\n  end: number;\n  markerLines: MarkerLines;\n} {\n  const startLoc: Location = {\n    column: 0,\n    line: -1,\n    ...loc.start,\n  };\n  const endLoc: Location = {\n    ...startLoc,\n    ...loc.end,\n  };\n  const { linesAbove = 2, linesBelow = 3 } = opts || {};\n  const startLine = startLoc.line;\n  const startColumn = startLoc.column;\n  const endLine = endLoc.line;\n  const endColumn = endLoc.column;\n\n  let start = Math.max(startLine - (linesAbove + 1), 0);\n  let end = Math.min(source.length, endLine + linesBelow);\n\n  if (startLine === -1) {\n    start = 0;\n  }\n\n  if (endLine === -1) {\n    end = source.length;\n  }\n\n  const lineDiff = endLine - startLine;\n  const markerLines: MarkerLines = {};\n\n  if (lineDiff) {\n    for (let i = 0; i <= lineDiff; i++) {\n      const lineNumber = i + startLine;\n\n      if (!startColumn) {\n        markerLines[lineNumber] = true;\n      } else if (i === 0) {\n        const sourceLength = source[lineNumber - 1].length;\n\n        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n      } else if (i === lineDiff) {\n        markerLines[lineNumber] = [0, endColumn];\n      } else {\n        const sourceLength = source[lineNumber - i].length;\n\n        markerLines[lineNumber] = [0, sourceLength];\n      }\n    }\n  } else {\n    if (startColumn === endColumn) {\n      if (startColumn) {\n        markerLines[startLine] = [startColumn, 0];\n      } else {\n        markerLines[startLine] = true;\n      }\n    } else {\n      markerLines[startLine] = [startColumn, endColumn - startColumn];\n    }\n  }\n\n  return { start, end, markerLines };\n}\n\nexport function codeFrameColumns(\n  rawLines: string,\n  loc: NodeLocation,\n  opts: Options = {},\n): string {\n  const shouldHighlight =\n    opts.forceColor || (isColorSupported() && opts.highlightCode);\n  const defs = getDefs(shouldHighlight);\n\n  const lines = rawLines.split(NEWLINE);\n  const { start, end, markerLines } = getMarkerLines(loc, lines, opts);\n  const hasColumns = loc.start && typeof loc.start.column === \"number\";\n\n  const numberMaxWidth = String(end).length;\n\n  const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;\n\n  let frame = highlightedLines\n    .split(NEWLINE, end)\n    .slice(start, end)\n    .map((line, index) => {\n      const number = start + 1 + index;\n      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n      const gutter = ` ${paddedNumber} |`;\n      const hasMarker = markerLines[number];\n      const lastMarkerLine = !markerLines[number + 1];\n      if (hasMarker) {\n        let markerLine = \"\";\n        if (Array.isArray(hasMarker)) {\n          const markerSpacing = line\n            .slice(0, Math.max(hasMarker[0] - 1, 0))\n            .replace(/[^\\t]/g, \" \");\n          const numberOfMarkers = hasMarker[1] || 1;\n\n          markerLine = [\n            \"\\n \",\n            defs.gutter(gutter.replace(/\\d/g, \" \")),\n            \" \",\n            markerSpacing,\n            defs.marker(\"^\").repeat(numberOfMarkers),\n          ].join(\"\");\n\n          if (lastMarkerLine && opts.message) {\n            markerLine += \" \" + defs.message(opts.message);\n          }\n        }\n        return [\n          defs.marker(\">\"),\n          defs.gutter(gutter),\n          line.length > 0 ? ` ${line}` : \"\",\n          markerLine,\n        ].join(\"\");\n      } else {\n        return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : \"\"}`;\n      }\n    })\n    .join(\"\\n\");\n\n  if (opts.message && !hasColumns) {\n    frame = `${\" \".repeat(numberMaxWidth + 1)}${opts.message}\\n${frame}`;\n  }\n\n  if (shouldHighlight) {\n    return defs.reset(frame);\n  } else {\n    return frame;\n  }\n}\n\n/**\n * Create a code frame, adding line numbers, code highlighting, and pointing to a given position.\n */\n\nexport default function (\n  rawLines: string,\n  lineNumber: number,\n  colNumber?: number | null,\n  opts: Options = {},\n): string {\n  if (!deprecationWarningShown) {\n    deprecationWarningShown = true;\n\n    const message =\n      \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n\n    if (process.emitWarning) {\n      // A string is directly supplied to emitWarning, because when supplying an\n      // Error object node throws in the tests because of different contexts\n      process.emitWarning(message, \"DeprecationWarning\");\n    } else {\n      const deprecationError = new Error(message);\n      deprecationError.name = \"DeprecationWarning\";\n      console.warn(new Error(message));\n    }\n  }\n\n  colNumber = Math.max(colNumber, 0);\n\n  const location: NodeLocation = {\n    start: { column: colNumber, line: lineNumber },\n  };\n\n  return codeFrameColumns(rawLines, location, opts);\n}\n", "// Remove this file in Babel 8\n\nimport { react } from \"@babel/types\";\nimport {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../../scope/index.ts\";\nimport type NodePath from \"../index.ts\";\nimport type Binding from \"../../scope/binding.ts\";\nimport type { Visitor } from \"../../types.ts\";\n\nconst referenceVisitor: Visitor<PathHoister> = {\n  // This visitor looks for bindings to establish a topmost scope for hoisting.\n  ReferencedIdentifier(path, state) {\n    // Don't hoist regular JSX identifiers ('div', 'span', etc).\n    // We do have to consider member expressions for hoisting (e.g. `this.component`)\n    if (\n      path.isJSXIdentifier() &&\n      react.isCompatTag(path.node.name) &&\n      !path.parentPath.isJSXMemberExpression()\n    ) {\n      return;\n    }\n\n    // If the identifier refers to `this`, we need to break on the closest non-arrow scope.\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n      do {\n        if (\n          scope.path.isFunction() &&\n          !scope.path.isArrowFunctionExpression()\n        ) {\n          break;\n        }\n      } while ((scope = scope.parent));\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    // direct references that we need to track to hoist this to the highest scope we can\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    // we can handle reassignments only if they happen in the same scope as the declaration\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    // this binding isn't accessible from the parent scope so we can safely ignore it\n    // eg. it's in a closure etc\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n\n    state.bindings[path.node.name] = binding;\n  },\n};\n\nexport default class PathHoister<T extends t.Node = t.Node> {\n  breakOnScopePaths: NodePath[];\n  bindings: { [k: string]: Binding };\n  mutableBinding: boolean;\n  private scopes: Scope[];\n  scope: Scope;\n  private path: NodePath<T>;\n  private attachAfter: boolean;\n\n  constructor(path: NodePath<T>, scope: Scope) {\n    // Storage for scopes we can't hoist above.\n    this.breakOnScopePaths = [];\n    // Storage for bindings that may affect what path we can hoist to.\n    this.bindings = {};\n    // \"true\" if the current path contains a reference to a binding whose\n    // value can change and thus can't be safely hoisted.\n    this.mutableBinding = false;\n    // Storage for eligible scopes.\n    this.scopes = [];\n    // Our original scope and path.\n    this.scope = scope;\n    this.path = path;\n    // By default, we attach as far up as we can; but if we're trying\n    // to avoid referencing a binding, we may have to go after.\n    this.attachAfter = false;\n  }\n\n  // A scope is compatible if all required bindings are reachable.\n  isCompatibleScope(scope: Scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Look through all scopes and push compatible ones.\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      // deopt: These scopes are set in the visitor on const violations\n      if (this.breakOnScopePaths.includes(scope.path)) {\n        break;\n      }\n    } while ((scope = scope.parent));\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n    if (!path) return;\n\n    let targetScope = path.scope;\n\n    // don't allow paths that have their own lexical environments to pollute\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    // avoid hoisting to a scope that contains bindings that are executed after our attachment path\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        // check binding is a direct child of this paths scope\n        if (!targetScope.hasOwnBinding(name)) continue;\n\n        const binding = this.bindings[name];\n\n        // allow parameter references and expressions in params (like destructuring rest)\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        // For each binding, get its attachment parent. This gives us an idea of where we might\n        // introduce conflicts.\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        // If the binding's attachment appears at or after our attachment point, then we move after it.\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          // We also move past any constant violations.\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n\n    const scope = scopes.pop();\n    // deopt: no compatible scopes\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        // deopt: should ignore this scope since it's ourselves\n        if (this.scope === scope) return;\n\n        // needs to be attached to the body\n        const bodies = scope.path.get(\"body\").get(\"body\") as NodePath[];\n        for (let i = 0; i < bodies.length; i++) {\n          // Don't attach to something that's going to get hoisted,\n          // like a default parameter\n          // @ts-expect-error todo(flow->ts): avoid mutating the node, introducing new fields\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n        // deopt: If here, no attachment path found\n      } else {\n        // doesn't need to be be attached to this scope\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  // Find an attachment for this path.\n  getAttachmentParentForPath(path: NodePath) {\n    do {\n      if (\n        // Beginning of the scope\n        !path.parentPath ||\n        // Has siblings and is a statement\n        (Array.isArray(path.container) && path.isStatement())\n      ) {\n        return path;\n      }\n    } while ((path = path.parentPath));\n  }\n\n  // Returns true if a scope has param bindings.\n  hasOwnParamBindings(scope: Scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n\n      const binding = this.bindings[name];\n      // Ensure constant; without it we could place behind a reassignment\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n    return false;\n  }\n\n  run(): NodePath<t.Expression> | undefined {\n    this.path.traverse(referenceVisitor, this);\n\n    if (this.mutableBinding) return;\n\n    this.getCompatibleScopes();\n\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n\n    // don't bother hoisting to the same function as this will cause multiple branches to be\n    // evaluated more than once leading to a bad optimisation\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n\n    // generate declaration and insert it to our point\n    let uid: t.Identifier | t.JSXExpressionContainer =\n      attachTo.scope.generateUidIdentifier(\"ref\");\n\n    // @ts-expect-error todo(flow->ts): more specific type for this.path\n    const declarator = variableDeclarator(uid, this.path.node);\n\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([\n      attachTo.isVariableDeclarator()\n        ? declarator\n        : variableDeclaration(\"var\", [declarator]),\n    ]);\n\n    const parent = this.path.parentPath;\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      // turning the `span` in `<div><span /></div>` to an expression so we need to wrap it with\n      // an expression container\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n\n    // @ts-expect-error TS cannot refine the type of `attached`\n    // TODO: Should we use `attached.isVariableDeclaration()`?\n    return attachTo.isVariableDeclarator()\n      ? attached.get(\"init\")\n      : attached.get(\"declarations.0.init\");\n  }\n}\n", "// this file contains hooks that handle ancestry cleanup of parent nodes when removing children\n\nimport type NodePath from \"../index.ts\";\nimport type * as t from \"@babel/types\";\n/**\n * Pre hooks should be used for either rejecting removal or delegating removal\n */\n\nexport const hooks = [\n  function (self: NodePath, parent: NodePath) {\n    const removeParent =\n      // while (NODE);\n      // removing the test of a while/switch, we can either just remove it entirely *or* turn the\n      // `test` into `true` unlikely that the latter will ever be what's wanted so we just remove\n      // the loop to avoid infinite recursion\n      (self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase())) ||\n      // export NODE;\n      // just remove a declaration for an export as this is no longer valid\n      (self.key === \"declaration\" && parent.isExportDeclaration()) ||\n      // label: NODE\n      // stray labeled statement with no body\n      (self.key === \"body\" && parent.isLabeledStatement()) ||\n      // let NODE;\n      // remove an entire declaration if there are no declarators left\n      (self.listKey === \"declarations\" &&\n        parent.isVariableDeclaration() &&\n        parent.node.declarations.length === 1) ||\n      // NODE;\n      // remove the entire expression statement if there's no expression\n      (self.key === \"expression\" && parent.isExpressionStatement());\n\n    if (removeParent) {\n      parent.remove();\n      return true;\n    }\n  },\n\n  function (self: NodePath, parent: NodePath) {\n    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n      // (node, NODE);\n      // we've just removed the second element of a sequence expression so let's turn that sequence\n      // expression into a regular expression\n      parent.replaceWith(parent.node.expressions[0]);\n      return true;\n    }\n  },\n\n  function (self: NodePath, parent: NodePath) {\n    if (parent.isBinary()) {\n      // left + NODE;\n      // NODE + right;\n      // we're in a binary expression, better remove it and replace it with the last expression\n      if (self.key === \"left\") {\n        parent.replaceWith(parent.node.right);\n      } else {\n        // key === \"right\"\n        parent.replaceWith(parent.node.left);\n      }\n      return true;\n    }\n  },\n\n  function (self: NodePath, parent: NodePath) {\n    if (\n      (parent.isIfStatement() && self.key === \"consequent\") ||\n      (self.key === \"body\" &&\n        (parent.isLoop() || parent.isArrowFunctionExpression()))\n    ) {\n      self.replaceWith({\n        type: \"BlockStatement\",\n        body: [],\n      } as t.BlockStatement);\n      return true;\n    }\n  },\n];\n", "// This file contains methods responsible for removing a node.\n\nimport { hooks } from \"./lib/removal-hooks.ts\";\nimport { getCachedPaths } from \"../cache.ts\";\nimport { _replaceWith } from \"./replacement.ts\";\nimport type NodePath from \"./index.ts\";\nimport { REMOVED, SHOULD_SKIP } from \"./index.ts\";\nimport { getBindingIdentifiers } from \"@babel/types\";\nimport { updateSiblingKeys } from \"./modification.ts\";\nimport { resync } from \"./context.ts\";\n\nexport function remove(this: NodePath) {\n  _assertUnremoved.call(this);\n\n  resync.call(this);\n\n  if (_callRemovalHooks.call(this)) {\n    _markRemoved.call(this);\n    return;\n  }\n\n  if (!this.opts?.noScope) {\n    _removeFromScope.call(this);\n  }\n\n  this.shareCommentsWithSiblings();\n  _remove.call(this);\n  _markRemoved.call(this);\n}\n\nexport function _removeFromScope(this: NodePath) {\n  const bindings = getBindingIdentifiers(this.node, false, false, true);\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nexport function _callRemovalHooks(this: NodePath) {\n  if (this.parentPath) {\n    for (const fn of hooks) {\n      if (fn(this, this.parentPath)) return true;\n    }\n  }\n}\n\nexport function _remove(this: NodePath) {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key as number, 1);\n    updateSiblingKeys.call(this, this.key as number, -1);\n  } else {\n    _replaceWith.call(this, null);\n  }\n}\n\nexport function _markRemoved(this: NodePath) {\n  // this.shouldSkip = true; this.removed = true;\n  this._traverseFlags |= SHOULD_SKIP | REMOVED;\n  if (this.parent) {\n    getCachedPaths(this.hub, this.parent).delete(this.node);\n  }\n  this.node = null;\n}\n\nexport function _assertUnremoved(this: NodePath) {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\n      \"NodePath has been removed so is read-only.\",\n    );\n  }\n}\n", "// This file contains methods that modify the path/node in some ways.\n\nimport { getCachedPaths } from \"../cache.ts\";\nimport PathHoister from \"./lib/hoister.ts\";\nimport NodePath from \"./index.ts\";\nimport { _getQueueContexts, pushContext, setScope } from \"./context.ts\";\nimport { _assertUnremoved } from \"./removal.ts\";\nimport {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExportNamedDeclaration,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../scope/index.ts\";\n\n/**\n * Insert the provided nodes before the current one.\n */\n\nexport function insertBefore(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  _assertUnremoved.call(this);\n\n  const nodes = _verifyNodeList.call(this, nodes_);\n\n  const { parentPath, parent } = this;\n\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // https://github.com/babel/babel/issues/15293\n    // When Babel transforms `export class String { field }`, the class properties plugin will inject the defineProperty\n    // helper, which depends on the builtins e.g. String, Number, Symbol, etc. To prevent them from being shadowed by local\n    // exports, the helper injector replaces the named export into `class _String { field }; export { _String as String }`,\n    // with `parentPath` here changed to the moved ClassDeclaration, causing rare inconsistency between `parent` and `parentPath`.\n    // Here we retrieve the parent type from the `parent` property. This is a temporary fix and we should revisit when\n    // helpers should get injected.\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertBefore(nodes);\n  } else if (\n    (this.isNodeType(\"Expression\") && !this.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    if (this.node) nodes.push(this.node);\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertBefore.call(this, nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return (this as NodePath<t.BlockStatement>).unshiftContainer(\n      \"body\",\n      // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n      nodes,\n    );\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\nexport function _containerInsert<N extends t.Node>(\n  this: NodePath,\n  from: number,\n  nodes: N[],\n): NodePath<N>[] {\n  updateSiblingKeys.call(this, from, nodes.length);\n\n  const paths: NodePath<N>[] = [];\n\n  // @ts-expect-error todo(flow->ts): this.container could be a NodePath\n  this.container.splice(from, 0, ...nodes);\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to) as NodePath<N>;\n    paths.push(path);\n\n    if (this.context?.queue) {\n      pushContext.call(path, this.context);\n    }\n  }\n\n  const contexts = _getQueueContexts.call(this);\n\n  for (const path of paths) {\n    setScope.call(path);\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nexport function _containerInsertBefore<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return _containerInsert.call(this, this.key as number, nodes);\n}\n\nexport function _containerInsertAfter<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return _containerInsert.call(this, (this.key as number) + 1, nodes);\n}\n\nconst last = <T>(arr: T[]) => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path: NodePath): boolean {\n  return (\n    isSequenceExpression(path.parent) &&\n    (last(path.parent.expressions) !== path.node ||\n      isHiddenInSequenceExpression(path.parentPath))\n  );\n}\n\nfunction isAlmostConstantAssignment(\n  node: t.Node,\n  scope: Scope,\n): node is t.AssignmentExpression & { left: t.Identifier } {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  // Not every scope can contain variables. For example, we might be in\n  // a ClassScope either in the ClassHeritage or in a computed key.\n  const blockScope = scope.getBlockParent();\n\n  // If the variable is defined in the current scope and only assigned here,\n  // we can be sure that its value won't change.\n  return (\n    blockScope.hasOwnBinding(node.left.name) &&\n    blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1\n  );\n}\n\n/**\n * Insert the provided nodes after the current one. When inserting nodes after an\n * expression, ensure that the completion record is correct by pushing the current node.\n */\n\nexport function insertAfter(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  _assertUnremoved.call(this);\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = _verifyNodeList.call(this, nodes_);\n\n  const { parentPath, parent } = this;\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // see insertBefore\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertAfter(\n      nodes.map(node => {\n        // Usually after an expression we can safely insert another expression:\n        //   A.insertAfter(B)\n        //     foo = A;  -> foo = (A, B);\n        // If A is an expression statement, it isn't safe anymore so we need to\n        // convert B to an expression statement\n        //     A;        -> A; B // No semicolon! It could break if followed by [!\n        return isExpression(node) ? expressionStatement(node) : node;\n      }),\n    );\n  } else if (\n    (this.isNodeType(\"Expression\") &&\n      !this.isJSXElement() &&\n      !parentPath.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    const self = this as NodePath<t.Expression | t.VariableDeclaration>;\n    if (self.node) {\n      const node = self.node;\n      let { scope } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n\n        self.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        (self.get(\"callee.body\") as NodePath<t.Expression>).insertAfter(nodes);\n        return [self];\n      }\n\n      if (isHiddenInSequenceExpression(self)) {\n        nodes.unshift(node);\n      }\n      // We need to preserve the value of this expression.\n      else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        // `super(...)` always evaluates to `this`.\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        // Insert the nodes before rather than after; it's not observable.\n        nodes.push(node);\n      } else {\n        // Inserting after the computed key of a method should insert the\n        // temporary binding in the method's parent's scope.\n        if (parentPath.isMethod({ computed: true, key: node })) {\n          scope = scope.parent;\n        }\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(\n          expressionStatement(\n            // @ts-expect-error todo(flow->ts): This can be a variable\n            // declaration in the \"init\" of a for statement, but that's\n            // invalid here.\n            assignmentExpression(\"=\", cloneNode(temp), node),\n          ),\n        );\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertAfter.call(this, nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\n/**\n * Update all sibling node paths after `fromIndex` by `incrementBy`.\n */\n\nexport function updateSiblingKeys(\n  this: NodePath,\n  fromIndex: number,\n  incrementBy: number,\n) {\n  if (!this.parent) return;\n\n  const paths = getCachedPaths(this.hub, this.parent) || ([] as never[]);\n\n  for (const [, path] of paths) {\n    if (\n      typeof path.key === \"number\" &&\n      path.container === this.container &&\n      path.key >= fromIndex\n    ) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nexport function _verifyNodeList<N extends t.Node>(\n  this: NodePath,\n  nodes: N | N[],\n): N[] {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof NodePath) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(\n        `Node list ${msg} with the index of ${i} and type of ${type}`,\n      );\n    }\n  }\n\n  return nodes;\n}\n\nexport function unshiftContainer<N extends t.Node, K extends keyof N & string>(\n  this: NodePath<N>,\n  listKey: K,\n  nodes: N[K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  // todo: NodePaths<Nodes>\n  _assertUnremoved.call(this);\n\n  // @ts-expect-error fixme\n  nodes = _verifyNodeList.call(this, nodes);\n\n  // get the first path and insert our nodes before it, if it doesn't exist then it\n  // doesn't matter, our nodes will be inserted anyway\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: (this.node as N)[listKey] as unknown as t.Node | t.Node[],\n    listKey,\n    key: 0,\n  }).setContext(this.context);\n\n  return _containerInsertBefore.call(\n    path,\n    // @ts-expect-error typings needed to narrow down nodes as t.Node[]\n    nodes,\n  );\n}\n\nexport function pushContainer<\n  P extends NodePath,\n  K extends string & keyof P[\"node\"],\n>(\n  this: P,\n  listKey: K,\n  nodes: P[\"node\"][K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  _assertUnremoved.call(this);\n\n  const verifiedNodes = _verifyNodeList.call(\n    this,\n    // @ts-expect-error refine typings\n    nodes,\n  );\n\n  // get an invisible path that represents the last node + 1 and replace it with our\n  // nodes, effectively inlining it\n\n  const container = (this.node as P[\"node\"])[listKey] as t.Node[];\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: container as unknown as t.Node | t.Node[],\n    listKey,\n    key: container.length,\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Hoist the current node to the highest scope possible and return a UID\n   * referencing it.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.hoist = function hoist<T extends t.Node>(\n    this: NodePath<T>,\n    scope: Scope = this.scope,\n  ) {\n    const hoister = new PathHoister<T>(this, scope);\n    return hoister.run();\n  };\n}\n", "// This file contains methods responsible for replacing a node with another.\n\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport traverse from \"../index.ts\";\nimport NodePath from \"./index.ts\";\nimport { getCachedPaths } from \"../cache.ts\";\nimport { _verifyNodeList, _containerInsertAfter } from \"./modification.ts\";\nimport { parse } from \"@babel/parser\";\nimport {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  buildUndefinedNode,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  expressionStatement,\n  getBindingIdentifiers,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isBlockStatement,\n  isEmptyStatement,\n  isExpression,\n  isExpressionStatement,\n  isIfStatement,\n  isProgram,\n  isStatement,\n  isVariableDeclaration,\n  removeComments,\n  returnStatement,\n  sequenceExpression,\n  validate,\n  yieldExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { resync, setScope } from \"./context.ts\";\n\n/**\n * Replace a node with an array of multiple. This method performs the following steps:\n *\n *  - Inherit the comments of first provided node with that of the current node.\n *  - Insert the provided nodes after the current node.\n *  - Remove the current node.\n */\n\nexport function replaceWithMultiple(\n  this: NodePath,\n  nodes: t.Node | t.Node[],\n): NodePath[] {\n  resync.call(this);\n\n  nodes = _verifyNodeList.call(this, nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  getCachedPaths(this.hub, this.parent)?.delete(this.node);\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n  return paths;\n}\n\n/**\n * Parse a string as an expression and replace the current node with the result.\n *\n * NOTE: This is typically not a good idea to use. Building source strings when\n * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's\n * easier to use, your transforms will be extremely brittle.\n */\n\nexport function replaceWithSourceString(this: NodePath, replacement: string) {\n  resync.call(this);\n  let ast: t.File;\n\n  try {\n    replacement = `(${replacement})`;\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    ast = parse(replacement);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message +=\n        \" - make sure this is an expression.\\n\" +\n        codeFrameColumns(replacement, {\n          start: {\n            line: loc.line,\n            column: loc.column + 1,\n          },\n        });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n    throw err;\n  }\n\n  const expressionAST = (ast.program.body[0] as t.ExpressionStatement)\n    .expression;\n  traverse.removeProperties(expressionAST);\n  return this.replaceWith(expressionAST);\n}\n\n/**\n * Replace the current node with another.\n */\nexport function replaceWith<R extends t.Node>(\n  this: NodePath,\n  replacementPath: R,\n): [NodePath<R>];\nexport function replaceWith<R extends NodePath>(\n  this: NodePath,\n  replacementPath: R,\n): [R];\nexport function replaceWith(\n  this: NodePath,\n  replacementPath: t.Node | NodePath,\n): [NodePath] {\n  resync.call(this);\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  let replacement: t.Node =\n    replacementPath instanceof NodePath\n      ? replacementPath.node\n      : replacementPath;\n\n  if (!replacement) {\n    throw new Error(\n      \"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\",\n    );\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\n      \"You can only replace a Program root node with another Program node\",\n    );\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\n      \"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\",\n    );\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\n      \"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\",\n    );\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (\n      !this.canHaveVariableDeclarationOrExpression() &&\n      !this.canSwapBetweenExpressionAndStatement(replacement) &&\n      !this.parentPath.isExportDefaultDeclaration()\n    ) {\n      // replacing a statement with an expression so wrap it in an expression statement\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (\n      !this.canHaveVariableDeclarationOrExpression() &&\n      !this.canSwapBetweenExpressionAndStatement(replacement)\n    ) {\n      // replacing an expression with a statement so let's explode it\n      return this.replaceExpressionWithStatements([replacement]) as [NodePath];\n    }\n  }\n\n  const oldNode = this.node;\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  // replace the node\n  _replaceWith.call(this, replacement);\n  this.type = replacement.type;\n\n  // potentially create new scope\n  setScope.call(this);\n\n  // requeue for visiting\n  this.requeue();\n\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nexport function _replaceWith(this: NodePath, node: t.Node) {\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    // @ts-expect-error todo(flow->ts): check if validate accepts a numeric key\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key as string, node);\n  }\n\n  this.debug(`Replace with ${node?.type}`);\n  getCachedPaths(this.hub, this.parent)?.set(node, this).delete(this.node);\n\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key] = node;\n}\n\n/**\n * This method takes an array of statements nodes and then explodes it\n * into expressions. This method retains completion records which is\n * extremely important to retain original semantics.\n */\n\nexport function replaceExpressionWithStatements(\n  this: NodePath,\n  nodes: Array<t.Statement>,\n) {\n  resync.call(this);\n\n  const declars: t.Identifier[] = [];\n  const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);\n  if (nodesAsSingleExpression) {\n    for (const id of declars) this.scope.push({ id });\n    return this.replaceWith(nodesAsSingleExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent?.node.async;\n  const isParentGenerator = functionParent?.node.generator;\n\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n\n  this.replaceWith(callExpression(container, []));\n  // replaceWith changes the type of \"this\", but it isn't trackable by TS\n  type ThisType = NodePath<\n    t.CallExpression & {\n      callee: t.ArrowFunctionExpression & { body: t.BlockStatement };\n    }\n  >;\n\n  // hoist variable declaration in do block\n  // `(do { var x = 1; x;})` -> `var x; (() => { x = 1; return x; })()`\n  const callee = (this as ThisType).get(\"callee\");\n  callee.get(\"body\").scope.hoistVariables(id => this.scope.push({ id }));\n\n  // add implicit returns to all ending expression statements\n  const completionRecords: Array<NodePath> = callee.getCompletionRecords();\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n\n    const loop = path.findParent(path => path.isLoop());\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee\n          .get(\"body\")\n          .pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path\n        .get(\"expression\")\n        .replaceWith(\n          assignmentExpression(\"=\", cloneNode(uid), path.node.expression),\n        );\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  // This is an IIFE, so we don't need to worry about the noNewArrows assumption\n  callee.arrowFunctionToExpression();\n  // Fixme: we can not `assert this is NodePath<t.FunctionExpression>` in `arrowFunctionToExpression`\n  // because it is not a class method known at compile time.\n  const newCallee = callee as unknown as NodePath<t.FunctionExpression>;\n\n  // (() => await xxx)() -> await (async () => await xxx)();\n  const needToAwaitFunction =\n    isParentAsync &&\n    traverse.hasType(\n      (this.get(\"callee.body\") as NodePath<t.BlockStatement>).node,\n      \"AwaitExpression\",\n      FUNCTION_TYPES,\n    );\n  const needToYieldFunction =\n    isParentGenerator &&\n    traverse.hasType(\n      (this.get(\"callee.body\") as NodePath<t.BlockStatement>).node,\n      \"YieldExpression\",\n      FUNCTION_TYPES,\n    );\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n    // yield* will await the generator return result\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression((this as ThisType).node));\n    }\n  }\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression((this as ThisType).node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction gatherSequenceExpressions(\n  nodes: ReadonlyArray<t.Node>,\n  declars: Array<t.Identifier>,\n) {\n  const exprs: t.Expression[] = [];\n  let ensureLastUndefined = true;\n\n  for (const node of nodes) {\n    // if we encounter emptyStatement before a non-emptyStatement\n    // we want to disregard that\n    if (!isEmptyStatement(node)) {\n      ensureLastUndefined = false;\n    }\n\n    if (isExpression(node)) {\n      exprs.push(node);\n    } else if (isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return; // bailed\n\n      for (const declar of node.declarations) {\n        const bindings = getBindingIdentifiers(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push(cloneNode(bindings[key]));\n        }\n\n        if (declar.init) {\n          exprs.push(assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (isIfStatement(node)) {\n      const consequent = node.consequent\n        ? gatherSequenceExpressions([node.consequent], declars)\n        : buildUndefinedNode();\n      const alternate = node.alternate\n        ? gatherSequenceExpressions([node.alternate], declars)\n        : buildUndefinedNode();\n      if (!consequent || !alternate) return; // bailed\n\n      exprs.push(conditionalExpression(node.test, consequent, alternate));\n    } else if (isBlockStatement(node)) {\n      const body = gatherSequenceExpressions(node.body, declars);\n      if (!body) return; // bailed\n\n      exprs.push(body);\n    } else if (isEmptyStatement(node)) {\n      // empty statement so ensure the last item is undefined if we're last\n      // checks if emptyStatement is first\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      // bailed, we can't turn this statement into an expression\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) exprs.push(buildUndefinedNode());\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return sequenceExpression(exprs);\n  }\n}\n\nexport function replaceInline(this: NodePath, nodes: t.Node | Array<t.Node>) {\n  resync.call(this);\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = _verifyNodeList.call(this, nodes);\n      const paths = _containerInsertAfter.call(this, nodes);\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}\n", "import type NodePath from \"./index.ts\";\nimport type * as t from \"@babel/types\";\n\n// This file contains Babels metainterpreter that can evaluate static code.\n\nconst VALID_OBJECT_CALLEES = [\"Number\", \"String\", \"Math\"] as const;\nconst VALID_IDENTIFIER_CALLEES = [\n  \"isFinite\",\n  \"isNaN\",\n  \"parseFloat\",\n  \"parseInt\",\n  \"decodeURI\",\n  \"decodeURIComponent\",\n  \"encodeURI\",\n  \"encodeURIComponent\",\n  process.env.BABEL_8_BREAKING ? \"btoa\" : null,\n  process.env.BABEL_8_BREAKING ? \"atob\" : null,\n] as const;\n\nconst INVALID_METHODS = [\"random\"] as const;\n\nfunction isValidObjectCallee(\n  val: string,\n): val is (typeof VALID_OBJECT_CALLEES)[number] {\n  return VALID_OBJECT_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isValidIdentifierCallee(\n  val: string,\n): val is (typeof VALID_IDENTIFIER_CALLEES)[number] {\n  return VALID_IDENTIFIER_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isInvalidMethod(val: string): val is (typeof INVALID_METHODS)[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nexport function evaluateTruthy(this: NodePath): boolean {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\ntype State = {\n  confident: boolean;\n  deoptPath: NodePath | null;\n  seen: Map<t.Node, Result>;\n};\n\ntype Result = {\n  resolved: boolean;\n  value?: any;\n};\n/**\n * Deopts the evaluation\n */\nfunction deopt(path: NodePath, state: State) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nconst Globals = new Map([\n  [\"undefined\", undefined],\n  [\"Infinity\", Infinity],\n  [\"NaN\", NaN],\n]);\n\n/**\n * We wrap the _evaluate method so we can track `seen` nodes, we push an item\n * to the map before we actually evaluate it so we can deopt on self recursive\n * nodes such as:\n *\n *   var g = a ? 1 : 2,\n *       a = g * this.foo\n */\nfunction evaluateCached(path: NodePath, state: State): any {\n  const { node } = path;\n  const { seen } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item: Result = { resolved: false };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (\n    path.isStringLiteral() ||\n    path.isNumericLiteral() ||\n    path.isBooleanLiteral()\n  ) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (\n    path.isTaggedTemplateExpression() &&\n    path.get(\"tag\").isMemberExpression()\n  ) {\n    const object = path.get(\"tag.object\") as NodePath;\n    const {\n      // @ts-expect-error todo(flow->ts): possible bug, object is can be any expression and so name might be undefined\n      node: { name },\n    } = object;\n    const property = path.get(\"tag.property\") as NodePath;\n\n    if (\n      object.isIdentifier() &&\n      name === \"String\" &&\n      // todo(flow->ts): was changed from getBinding(name, true)\n      //  should this be hasBinding(name, true) as the binding is never used later?\n      !path.scope.getBinding(name) &&\n      property.isIdentifier() &&\n      property.node.name === \"raw\"\n    ) {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    // TypeCastExpression, ExpressionStatement etc\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  // \"foo\".length, \"foo\"[0]\n  if (\n    path.isMemberExpression() &&\n    !path.parentPath.isCallExpression({ callee: path.node })\n  ) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral()) {\n      // @ts-expect-error todo(flow->ts): instead of typeof - would it be better to check type of ast node?\n      const value = object.node.value;\n      const type = typeof value;\n\n      let key = null;\n      if (path.node.computed) {\n        key = evaluateCached(property, state);\n        if (!state.confident) return;\n      } else if (property.isIdentifier()) {\n        key = property.node.name;\n      }\n      if (\n        (type === \"number\" || type === \"string\") &&\n        key != null &&\n        (typeof key === \"number\" || typeof key === \"string\")\n      ) {\n        return value[key];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding) {\n      if (\n        binding.constantViolations.length > 0 ||\n        path.node.start < binding.path.node.end\n      ) {\n        deopt(binding.path, state);\n        return;\n      }\n      if (binding.hasValue) {\n        return binding.value;\n      }\n    }\n\n    const name = path.node.name;\n    if (Globals.has(name)) {\n      if (!binding) {\n        return Globals.get(name);\n      }\n      deopt(binding.path, state);\n      return;\n    }\n\n    const resolved = path.resolve();\n    if (resolved === path) {\n      deopt(path, state);\n      return;\n    } else {\n      return evaluateCached(resolved, state);\n    }\n  }\n\n  if (path.isUnaryExpression({ prefix: true })) {\n    if (path.node.operator === \"void\") {\n      // we don't need to evaluate the argument to know what this will return\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n    if (\n      path.node.operator === \"typeof\" &&\n      (argument.isFunction() || argument.isClass())\n    ) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems: Array<NodePath> = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        deopt(elemValue.deopt, state);\n        return;\n      }\n    }\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        deopt(prop, state);\n        return;\n      }\n      const keyPath = prop.get(\"key\");\n      let key;\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          deopt(key.deopt, state);\n          return;\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        deopt(value.deopt, state);\n        return;\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    // If we are confident that the left side of an && is false, or the left\n    // side of an || is true, we can be confident about the entire expression\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        // TODO consider having a \"truthy type\" that doesn't bail on\n        // left uncertainty but can still evaluate to truthy.\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n\n        return left ?? right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right; // eslint-disable-line eqeqeq\n      case \"!=\":\n        return left != right; // eslint-disable-line eqeqeq\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      (isValidObjectCallee(callee.node.name) ||\n        isValidIdentifierCallee(callee.node.name))\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidObjectCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        const key = property.node.name;\n        if (Object.hasOwn(context, key)) {\n          func = context[key as keyof typeof context];\n        }\n      }\n\n      // \"abc\".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(\n  path: NodePath<t.TaggedTemplateExpression | t.TemplateLiteral>,\n  quasis: Array<any>,\n  state: State,\n  raw = false,\n) {\n  let str = \"\";\n\n  let i = 0;\n  const exprs: Array<NodePath<t.Node>> = path.isTemplateLiteral()\n    ? path.get(\"expressions\")\n    : path.get(\"quasi.expressions\");\n\n  for (const elem of quasis) {\n    // not confident, evaluated an expression we don't like\n    if (!state.confident) break;\n\n    // add on element\n    str += raw ? elem.value.raw : elem.value.cooked;\n\n    // add on interpolated expression if it's present\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn't confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n", "import { assertExpressionStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport type Formatter<T> = {\n  code: (source: string) => string;\n  validate: (ast: t.File) => void;\n  unwrap: (ast: t.File) => T;\n};\n\nfunction makeStatementFormatter<T>(\n  fn: (statements: Array<t.Statement>) => T,\n): Formatter<T> {\n  return {\n    // We need to prepend a \";\" to force statement parsing so that\n    // ExpressionStatement strings won't be parsed as directives.\n    // Alongside that, we also prepend a comment so that when a syntax error\n    // is encountered, the user will be less likely to get confused about\n    // where the random semicolon came from.\n    code: str => `/* @babel/template */;\\n${str}`,\n    validate: () => {},\n    unwrap: (ast: t.File): T => {\n      return fn(ast.program.body.slice(1));\n    },\n  };\n}\n\nexport const smart = makeStatementFormatter(body => {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\n\nexport const statements = makeStatementFormatter(body => body);\n\nexport const statement = makeStatementFormatter(body => {\n  // We do this validation when unwrapping since the replacement process\n  // could have added or removed statements.\n  if (body.length === 0) {\n    throw new Error(\"Found nothing to return.\");\n  }\n  if (body.length > 1) {\n    throw new Error(\"Found multiple statements but wanted one\");\n  }\n\n  return body[0];\n});\n\nexport const expression: Formatter<t.Expression> = {\n  code: str => `(\\n${str}\\n)`,\n  validate: ast => {\n    if (ast.program.body.length > 1) {\n      throw new Error(\"Found multiple statements but wanted one\");\n    }\n    if (expression.unwrap(ast).start === 0) {\n      throw new Error(\"Parse result included parens.\");\n    }\n  },\n  unwrap: ({ program }) => {\n    const [stmt] = program.body;\n    assertExpressionStatement(stmt);\n    return stmt.expression;\n  },\n};\n\nexport const program: Formatter<t.Program> = {\n  code: str => str,\n  validate: () => {},\n  unwrap: ast => ast.program,\n};\n", "import type { ParserOptions as ParserOpts } from \"@babel/parser\";\n\nexport type { ParserOpts };\n\n/**\n * These are the options that 'babel-template' actually accepts and typechecks\n * when called. All other options are passed through to the parser.\n */\nexport type PublicOpts = {\n  /**\n   * A set of placeholder names to automatically accept, ignoring the given\n   * pattern entirely.\n   *\n   * This option can be used when using %%foo%% style placeholders.\n   */\n  placeholderWhitelist?: Set<string>;\n  /**\n   * A pattern to search for when looking for Identifier and StringLiteral\n   * nodes that can be replaced.\n   *\n   * 'false' will disable placeholder searching entirely, leaving only the\n   * 'placeholderWhitelist' value to find replacements.\n   *\n   * Defaults to /^[_$A-Z0-9]+$/.\n   *\n   * This option can be used when using %%foo%% style placeholders.\n   */\n  placeholderPattern?: RegExp | false;\n  /**\n   * 'true' to pass through comments from the template into the resulting AST,\n   * or 'false' to automatically discard comments. Defaults to 'false'.\n   */\n  preserveComments?: boolean;\n  /**\n   * 'true' to use %%foo%% style placeholders, 'false' to use legacy placeholders\n   * described by placeholderPattern or placeholderWhitelist.\n   * When it is not set, it behaves as 'true' if there are syntactic placeholders,\n   * otherwise as 'false'.\n   */\n  syntacticPlaceholders?: boolean | null;\n};\n\nexport type TemplateOpts = {\n  parser: ParserOpts;\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  preserveComments?: boolean;\n  syntacticPlaceholders?: boolean;\n};\n\nexport function merge(a: TemplateOpts, b: TemplateOpts): TemplateOpts {\n  const {\n    placeholderWhitelist = a.placeholderWhitelist,\n    placeholderPattern = a.placeholderPattern,\n    preserveComments = a.preserveComments,\n    syntacticPlaceholders = a.syntacticPlaceholders,\n  } = b;\n\n  return {\n    parser: {\n      ...a.parser,\n      ...b.parser,\n    },\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  };\n}\n\nexport function validate(opts: unknown): TemplateOpts {\n  if (opts != null && typeof opts !== \"object\") {\n    throw new Error(\"Unknown template options.\");\n  }\n\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n    ...parser\n  } = opts || ({} as any);\n\n  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {\n    throw new Error(\n      \"'.placeholderWhitelist' must be a Set, null, or undefined\",\n    );\n  }\n\n  if (\n    placeholderPattern != null &&\n    !(placeholderPattern instanceof RegExp) &&\n    placeholderPattern !== false\n  ) {\n    throw new Error(\n      \"'.placeholderPattern' must be a RegExp, false, null, or undefined\",\n    );\n  }\n\n  if (preserveComments != null && typeof preserveComments !== \"boolean\") {\n    throw new Error(\n      \"'.preserveComments' must be a boolean, null, or undefined\",\n    );\n  }\n\n  if (\n    syntacticPlaceholders != null &&\n    typeof syntacticPlaceholders !== \"boolean\"\n  ) {\n    throw new Error(\n      \"'.syntacticPlaceholders' must be a boolean, null, or undefined\",\n    );\n  }\n  if (\n    syntacticPlaceholders === true &&\n    (placeholderWhitelist != null || placeholderPattern != null)\n  ) {\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  return {\n    parser,\n    placeholderWhitelist: placeholderWhitelist || undefined,\n    placeholderPattern:\n      placeholderPattern == null ? undefined : placeholderPattern,\n    preserveComments: preserveComments == null ? undefined : preserveComments,\n    syntacticPlaceholders:\n      syntacticPlaceholders == null ? undefined : syntacticPlaceholders,\n  };\n}\n\nexport type PublicReplacements = { [x: string]: unknown } | Array<unknown>;\nexport type TemplateReplacements = { [x: string]: unknown } | void;\n\nexport function normalizeReplacements(\n  replacements: unknown,\n): TemplateReplacements {\n  if (Array.isArray(replacements)) {\n    return replacements.reduce((acc, replacement, i) => {\n      acc[\"$\" + i] = replacement;\n      return acc;\n    }, {});\n  } else if (typeof replacements === \"object\" || replacements == null) {\n    return (replacements as any) || undefined;\n  }\n\n  throw new Error(\n    \"Template replacements must be an array, object, null, or undefined\",\n  );\n}\n", "import {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { TraversalAncestors } from \"@babel/types\";\nimport { parse } from \"@babel/parser\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport type { TemplateOpts, ParserOpts } from \"./options.ts\";\nimport type { Formatter } from \"./formatters.ts\";\n\nexport type Metadata = {\n  ast: t.File;\n  placeholders: Array<Placeholder>;\n  placeholderNames: Set<string>;\n};\n\ntype PlaceholderType = \"string\" | \"param\" | \"statement\" | \"other\";\nexport type Placeholder = {\n  name: string;\n  resolve: (a: t.File) => { parent: t.Node; key: string; index?: number };\n  type: PlaceholderType;\n  isDuplicate: boolean;\n};\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nexport default function parseAndBuildMetadata<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): Metadata {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  } = opts;\n\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n\n  removePropertiesDeep(ast, {\n    preserveComments,\n  });\n\n  formatter.validate(ast);\n\n  const state: MetadataState = {\n    syntactic: { placeholders: [], placeholderNames: new Set() },\n    legacy: { placeholders: [], placeholderNames: new Set() },\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders,\n  };\n\n  traverse(ast, placeholderVisitorHandler, state);\n\n  return {\n    ast,\n    ...(state.syntactic.placeholders.length ? state.syntactic : state.legacy),\n  };\n}\n\nfunction placeholderVisitorHandler(\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: MetadataState,\n) {\n  let name: string;\n\n  let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\n        \"%%foo%%-style placeholders can't be used when \" +\n          \"'.syntacticPlaceholders' is false.\",\n      );\n    }\n    name = node.name.name;\n    hasSyntacticPlaceholders = true;\n  } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n  } else {\n    return;\n  }\n\n  if (\n    hasSyntacticPlaceholders &&\n    (state.placeholderPattern != null || state.placeholderWhitelist != null)\n  ) {\n    // This check is also in options.js. We need it there to handle the default\n    // .syntacticPlaceholders behavior.\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  if (\n    !hasSyntacticPlaceholders &&\n    (state.placeholderPattern === false ||\n      !(state.placeholderPattern || PATTERN).test(name)) &&\n    !state.placeholderWhitelist?.has(name)\n  ) {\n    return;\n  }\n\n  // Keep our own copy of the ancestors so we can use it in .resolve().\n  ancestors = ancestors.slice();\n\n  const { node: parent, key } = ancestors[ancestors.length - 1];\n\n  let type: PlaceholderType;\n  if (\n    isStringLiteral(node) ||\n    isPlaceholder(node, { expectedNode: \"StringLiteral\" })\n  ) {\n    type = \"string\";\n  } else if (\n    (isNewExpression(parent) && key === \"arguments\") ||\n    (isCallExpression(parent) && key === \"arguments\") ||\n    (isFunction(parent) && key === \"params\")\n  ) {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const { placeholders, placeholderNames } = !hasSyntacticPlaceholders\n    ? state.legacy\n    : state.syntactic;\n\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name),\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast: t.File, ancestors: TraversalAncestors) {\n  let parent: t.Node = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const { key, index } = ancestors[i];\n\n    if (index === undefined) {\n      parent = (parent as any)[key];\n    } else {\n      parent = (parent as any)[key][index];\n    }\n  }\n\n  const { key, index } = ancestors[ancestors.length - 1];\n\n  return { parent, key, index };\n}\n\ntype MetadataState = {\n  syntactic: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  legacy: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  syntacticPlaceholders?: boolean;\n};\n\nfunction parseWithCodeFrame(\n  code: string,\n  parserOpts: ParserOpts,\n  syntacticPlaceholders?: boolean,\n): t.File {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = {\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\",\n    ...parserOpts,\n    plugins,\n  };\n\n  try {\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    return parse(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + codeFrameColumns(code, { start: loc });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}\n", "import {\n  blockStatement,\n  cloneNode,\n  emptyStatement,\n  expressionStatement,\n  identifier,\n  isStatement,\n  isStringLiteral,\n  stringLiteral,\n  validate,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { TemplateReplacements } from \"./options.ts\";\nimport type { Metadata, Placeholder } from \"./parse.ts\";\n\nexport default function populatePlaceholders(\n  metadata: Metadata,\n  replacements: TemplateReplacements,\n): t.File {\n  const ast = cloneNode(metadata.ast);\n\n  if (replacements) {\n    metadata.placeholders.forEach(placeholder => {\n      if (!Object.hasOwn(replacements, placeholder.name)) {\n        const placeholderName = placeholder.name;\n\n        throw new Error(\n          `Error: No substitution given for \"${placeholderName}\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`,\n        );\n      }\n    });\n    Object.keys(replacements).forEach(key => {\n      if (!metadata.placeholderNames.has(key)) {\n        throw new Error(`Unknown substitution \"${key}\" given`);\n      }\n    });\n  }\n\n  // Process in reverse order so AST mutation doesn't change indices that\n  // will be needed for later calls to `placeholder.resolve()`.\n  metadata.placeholders\n    .slice()\n    .reverse()\n    .forEach(placeholder => {\n      try {\n        applyReplacement(\n          placeholder,\n          ast,\n          (replacements && replacements[placeholder.name]) || null,\n        );\n      } catch (e) {\n        e.message = `@babel/template placeholder \"${placeholder.name}\": ${e.message}`;\n        throw e;\n      }\n    });\n\n  return ast;\n}\n\nfunction applyReplacement(\n  placeholder: Placeholder,\n  ast: t.File,\n  replacement: any,\n) {\n  // Track inserted nodes and clone them if they are inserted more than\n  // once to avoid injecting the same node multiple times.\n  if (placeholder.isDuplicate) {\n    if (Array.isArray(replacement)) {\n      replacement = replacement.map(node => cloneNode(node));\n    } else if (typeof replacement === \"object\") {\n      replacement = cloneNode(replacement);\n    }\n  }\n\n  const { parent, key, index } = placeholder.resolve(ast);\n\n  if (placeholder.type === \"string\") {\n    if (typeof replacement === \"string\") {\n      replacement = stringLiteral(replacement);\n    }\n    if (!replacement || !isStringLiteral(replacement)) {\n      throw new Error(\"Expected string substitution\");\n    }\n  } else if (placeholder.type === \"statement\") {\n    if (index === undefined) {\n      if (!replacement) {\n        replacement = emptyStatement();\n      } else if (Array.isArray(replacement)) {\n        replacement = blockStatement(replacement);\n      } else if (typeof replacement === \"string\") {\n        replacement = expressionStatement(identifier(replacement));\n      } else if (!isStatement(replacement)) {\n        replacement = expressionStatement(replacement);\n      }\n    } else {\n      if (replacement && !Array.isArray(replacement)) {\n        if (typeof replacement === \"string\") {\n          replacement = identifier(replacement);\n        }\n        if (!isStatement(replacement)) {\n          replacement = expressionStatement(replacement);\n        }\n      }\n    }\n  } else if (placeholder.type === \"param\") {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n\n    if (index === undefined) throw new Error(\"Assertion failure.\");\n  } else {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n    if (Array.isArray(replacement)) {\n      throw new Error(\"Cannot replace single expression with an array.\");\n    }\n  }\n\n  function set(parent: any, key: any, value: any) {\n    const node = parent[key] as t.Node;\n    parent[key] = value;\n    if (node.type === \"Identifier\" || node.type === \"Placeholder\") {\n      if (node.typeAnnotation) {\n        value.typeAnnotation = node.typeAnnotation;\n      }\n      if (node.optional) {\n        value.optional = node.optional;\n      }\n      if (node.decorators) {\n        value.decorators = node.decorators;\n      }\n    }\n  }\n\n  if (index === undefined) {\n    validate(parent, key, replacement);\n\n    set(parent, key, replacement);\n  } else {\n    const items: Array<t.Node> = (parent as any)[key].slice();\n\n    if (placeholder.type === \"statement\" || placeholder.type === \"param\") {\n      if (replacement == null) {\n        items.splice(index, 1);\n      } else if (Array.isArray(replacement)) {\n        items.splice(index, 1, ...replacement);\n      } else {\n        set(items, index, replacement);\n      }\n    } else {\n      set(items, index, replacement);\n    }\n\n    validate(parent, key, items);\n    (parent as any)[key] = items;\n  }\n}\n", "import type { Formatter } from \"./formatters.ts\";\nimport type { TemplateOpts } from \"./options.ts\";\nimport type { Metadata } from \"./parse.ts\";\nimport { normalizeReplacements } from \"./options.ts\";\nimport parseAndBuildMetadata from \"./parse.ts\";\nimport populatePlaceholders from \"./populate.ts\";\n\nexport default function stringTemplate<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): (arg?: unknown) => T {\n  code = formatter.code(code);\n\n  let metadata: Metadata;\n\n  return (arg?: unknown) => {\n    const replacements = normalizeReplacements(arg);\n\n    if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);\n\n    return formatter.unwrap(populatePlaceholders(metadata, replacements));\n  };\n}\n", "import type { Formatter } from \"./formatters.ts\";\nimport type { TemplateReplacements, TemplateOpts } from \"./options.ts\";\nimport { normalizeReplacements } from \"./options.ts\";\nimport parseAndBuildMetadata from \"./parse.ts\";\nimport populatePlaceholders from \"./populate.ts\";\n\nexport default function literalTemplate<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n): (_: Array<unknown>) => (_: unknown) => T {\n  const { metadata, names } = buildLiteralData(formatter, tpl, opts);\n\n  return arg => {\n    const defaultReplacements: TemplateReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n\n    return (arg: unknown) => {\n      const replacements = normalizeReplacements(arg);\n\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.hasOwn(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n\n      return formatter.unwrap(\n        populatePlaceholders(\n          metadata,\n          replacements\n            ? Object.assign(replacements, defaultReplacements)\n            : defaultReplacements,\n        ),\n      );\n    };\n  };\n}\n\nfunction buildLiteralData<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n) {\n  let prefix = \"BABEL_TPL$\";\n\n  const raw = tpl.join(\"\");\n\n  do {\n    // If there are cases where the template already contains $$BABEL_TPL$0 or any other\n    // matching pattern, we keep adding \"$$\" characters until a unique prefix\n    // is found.\n    prefix = \"$$\" + prefix;\n  } while (raw.includes(prefix));\n\n  const { names, code } = buildTemplateCode(tpl, prefix);\n\n  const metadata = parseAndBuildMetadata(formatter, formatter.code(code), {\n    parser: opts.parser,\n\n    // Explicitly include our generated names in the whitelist so users never\n    // have to think about whether their placeholder pattern will match.\n    placeholderWhitelist: new Set(\n      names.concat(\n        opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [],\n      ),\n    ),\n    placeholderPattern: opts.placeholderPattern,\n    preserveComments: opts.preserveComments,\n    syntacticPlaceholders: opts.syntacticPlaceholders,\n  });\n\n  return { metadata, names };\n}\n\nfunction buildTemplateCode(\n  tpl: Array<string>,\n  prefix: string,\n): { names: Array<string>; code: string } {\n  const names = [];\n\n  let code = tpl[0];\n\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n\n    code += value + tpl[i];\n  }\n\n  return { names, code };\n}\n", "import { merge, validate } from \"./options.ts\";\nimport type {\n  TemplateOpts,\n  PublicOpts,\n  PublicReplacements,\n} from \"./options.ts\";\nimport type { Formatter } from \"./formatters.ts\";\n\nimport stringTemplate from \"./string.ts\";\nimport literalTemplate from \"./literal.ts\";\n\nexport type TemplateBuilder<T> = {\n  // Build a new builder, merging the given options with the previous ones.\n  (opts: PublicOpts): TemplateBuilder<T>;\n\n  // Building from a string produces an AST builder function by default.\n  (tpl: string, opts?: PublicOpts): (replacements?: PublicReplacements) => T;\n\n  // Building from a template literal produces an AST builder function by default.\n  (\n    tpl: TemplateStringsArray,\n    ...args: Array<unknown>\n  ): (replacements?: PublicReplacements) => T;\n\n  // Allow users to explicitly create templates that produce ASTs, skipping\n  // the need for an intermediate function.\n  ast: {\n    (tpl: string, opts?: PublicOpts): T;\n    (tpl: TemplateStringsArray, ...args: Array<unknown>): T;\n  };\n};\n\n// Prebuild the options that will be used when parsing a `.ast` template.\n// These do not use a pattern because there is no way for users to pass in\n// replacement patterns to begin with, and disabling pattern matching means\n// users have more flexibility in what type of content they have in their\n// template JS.\nconst NO_PLACEHOLDER: TemplateOpts = validate({\n  placeholderPattern: false,\n});\n\nexport default function createTemplateBuilder<T>(\n  formatter: Formatter<T>,\n  defaultOpts?: TemplateOpts,\n): TemplateBuilder<T> {\n  const templateFnCache = new WeakMap();\n  const templateAstCache = new WeakMap();\n  const cachedOpts = defaultOpts || validate(null);\n\n  return Object.assign(\n    ((tpl, ...args) => {\n      if (typeof tpl === \"string\") {\n        if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n        return extendedTrace(\n          stringTemplate(formatter, tpl, merge(cachedOpts, validate(args[0]))),\n        );\n      } else if (Array.isArray(tpl)) {\n        let builder = templateFnCache.get(tpl);\n        if (!builder) {\n          builder = literalTemplate(formatter, tpl, cachedOpts);\n          templateFnCache.set(tpl, builder);\n        }\n        return extendedTrace(builder(args));\n      } else if (typeof tpl === \"object\" && tpl) {\n        if (args.length > 0) throw new Error(\"Unexpected extra params.\");\n        return createTemplateBuilder(\n          formatter,\n          merge(cachedOpts, validate(tpl)),\n        );\n      }\n      throw new Error(`Unexpected template param ${typeof tpl}`);\n    }) as TemplateBuilder<T>,\n    {\n      ast: (tpl: string | Array<string>, ...args: Array<unknown>) => {\n        if (typeof tpl === \"string\") {\n          if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n          return stringTemplate(\n            formatter,\n            tpl,\n            merge(merge(cachedOpts, validate(args[0])), NO_PLACEHOLDER),\n          )();\n        } else if (Array.isArray(tpl)) {\n          let builder = templateAstCache.get(tpl);\n          if (!builder) {\n            builder = literalTemplate(\n              formatter,\n              tpl,\n              merge(cachedOpts, NO_PLACEHOLDER),\n            );\n            templateAstCache.set(tpl, builder);\n          }\n          return builder(args)();\n        }\n\n        throw new Error(`Unexpected template param ${typeof tpl}`);\n      },\n    },\n  );\n}\n\nfunction extendedTrace<Arg, Result>(\n  fn: (_: Arg) => Result,\n): (_: Arg) => Result {\n  // Since we lazy parse the template, we get the current stack so we have the\n  // original stack to append if it errors when parsing\n  let rootStack = \"\";\n  try {\n    // error stack gets populated in IE only on throw\n    // (https://msdn.microsoft.com/en-us/library/hh699850(v=vs.94).aspx)\n    throw new Error();\n  } catch (error) {\n    if (error.stack) {\n      // error.stack does not exists in IE <= 9\n      // We slice off the top 3 items in the stack to remove the call to\n      // 'extendedTrace', and the anonymous builder function, with the final\n      // stripped line being the error message itself since we threw it\n      // in the first place and it doesn't matter.\n      rootStack = error.stack.split(\"\\n\").slice(3).join(\"\\n\");\n    }\n  }\n\n  return (arg: Arg) => {\n    try {\n      return fn(arg);\n    } catch (err) {\n      err.stack += `\\n    =============\\n${rootStack}`;\n      throw err;\n    }\n  };\n}\n", "import * as formatters from \"./formatters.ts\";\nimport createTemplateBuilder from \"./builder.ts\";\n\nexport const smart = createTemplateBuilder(formatters.smart);\nexport const statement = createTemplateBuilder(formatters.statement);\nexport const statements = createTemplateBuilder(formatters.statements);\nexport const expression = createTemplateBuilder(formatters.expression);\nexport const program = createTemplateBuilder(formatters.program);\n\ntype DefaultTemplateBuilder = typeof smart & {\n  smart: typeof smart;\n  statement: typeof statement;\n  statements: typeof statements;\n  expression: typeof expression;\n  program: typeof program;\n};\n\nexport default Object.assign(smart.bind(undefined) as DefaultTemplateBuilder, {\n  smart,\n  statement,\n  statements,\n  expression,\n  program,\n  ast: smart.ast,\n});\n\nexport type {\n  PublicOpts as Options,\n  PublicReplacements as Replacements,\n} from \"./options.ts\";\n", "// This file contains methods that convert the path node into another node or some other type of data.\n\nimport {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super as _super,\n  thisExpression,\n  toExpression,\n  unaryExpression,\n  toBindingIdentifierName,\n  isFunction,\n  isAssignmentPattern,\n  isRestElement,\n  getFunctionName,\n  cloneNode,\n  variableDeclaration,\n  variableDeclarator,\n  exportNamedDeclaration,\n  exportSpecifier,\n  inherits,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport template from \"@babel/template\";\nimport { environmentVisitor } from \"../visitors.ts\";\nimport type NodePath from \"./index.ts\";\nimport type { Visitor } from \"../types.ts\";\nimport { setup } from \"./context.ts\";\n\nexport function toComputedKey(this: NodePath) {\n  let key;\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  // @ts-expect-error todo(flow->ts) computed does not exist in ClassPrivateProperty\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nexport function ensureBlock(\n  this: NodePath<\n    t.Loop | t.WithStatement | t.Function | t.LabeledStatement | t.CatchClause\n  >,\n): void {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    // @ts-expect-error TS throws because ensureBlock returns the body node path\n    // however, we don't use the return value and treat it as a transform and\n    // assertion utilities. For better type inference we annotate it as an\n    // assertion method\n    // TODO: Unify the implementation with the type definition\n    return bodyNode;\n  }\n\n  const statements: Array<t.Statement> = [];\n\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node as t.Expression));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node as t.Expression));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath) as NodePath;\n  setup.call(\n    body,\n    parentPath,\n    listKey\n      ? // @ts-expect-error listKey must present in parent path\n        parentPath.node[listKey]\n      : parentPath.node,\n    listKey,\n    key,\n  );\n\n  // @ts-expect-error TS throws because ensureBlock returns the body node path\n  // however, we don't use the return value and treat it as a transform and\n  // assertion utilities. For better type inference we annotate it as an\n  // assertion method\n  // TODO: Unify the implementation with the type definition\n  return this.node;\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Keeping this for backward-compatibility. You should use arrowFunctionToExpression() for >=7.x.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.arrowFunctionToShadowed = function (this: NodePath) {\n    if (!this.isArrowFunctionExpression()) return;\n\n    this.arrowFunctionToExpression();\n  };\n}\n\n/**\n * Given an arbitrary function, process its content as if it were an arrow function, moving references\n * to \"this\", \"arguments\", \"super\", and such into the function's parent scope. This method is useful if\n * you have wrapped some set of items in an IIFE or other function, but want \"this\", \"arguments\", and super\"\n * to continue behaving as expected.\n */\nexport function unwrapFunctionEnvironment(this: NodePath) {\n  if (\n    !this.isArrowFunctionExpression() &&\n    !this.isFunctionExpression() &&\n    !this.isFunctionDeclaration()\n  ) {\n    throw this.buildCodeFrameError(\n      \"Can only unwrap the environment of a function.\",\n    );\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction setType<N extends t.Node, T extends N[\"type\"]>(\n  path: NodePath<N>,\n  type: T,\n): asserts path is NodePath<Extract<N, { type: T }>> {\n  path.node.type = type;\n}\n\n/**\n * Convert a given arrow function into a normal ES5 function expression.\n */\nexport function arrowFunctionToExpression(\n  this: NodePath<t.ArrowFunctionExpression>,\n  {\n    allowInsertArrow = true,\n    allowInsertArrowWithRest = allowInsertArrow,\n    noNewArrows = process.env.BABEL_8_BREAKING\n      ? // TODO(Babel 8): Consider defaulting to `false` for spec compliance\n        true\n      : !arguments[0]?.specCompliant,\n  }: {\n    allowInsertArrow?: boolean | void;\n    allowInsertArrowWithRest?: boolean | void;\n    noNewArrows?: boolean;\n  } = {},\n): NodePath<\n  Exclude<t.Function, t.Method | t.ArrowFunctionExpression> | t.CallExpression\n> {\n  if (!this.isArrowFunctionExpression()) {\n    throw (this as NodePath).buildCodeFrameError(\n      \"Cannot convert non-arrow function to a function expression.\",\n    );\n  }\n\n  let self = this;\n  if (!noNewArrows) {\n    // @ts-expect-error This is technicallynot valid on arrow functions\n    // because it adds an .id property, but we are going to convert it\n    // to a function expression anyway\n    self = self.ensureFunctionName(false) ?? self;\n  }\n\n  const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(\n    self,\n    noNewArrows,\n    allowInsertArrow,\n    allowInsertArrowWithRest,\n  );\n\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding\n      ? null\n      : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([]),\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\n      \"body\",\n      expressionStatement(\n        callExpression(this.hub.addHelper(\"newArrowCheck\"), [\n          thisExpression(),\n          checkBinding\n            ? identifier(checkBinding.name)\n            : identifier(thisBinding),\n        ]),\n      ),\n    );\n\n    fn.replaceWith(\n      callExpression(memberExpression(fn.node, identifier(\"bind\")), [\n        checkBinding ? identifier(checkBinding.name) : thisExpression(),\n      ]),\n    );\n\n    return fn.get(\"callee.object\");\n  }\n\n  return fn;\n}\n\nconst getSuperCallsVisitor = environmentVisitor<{\n  allSuperCalls: NodePath<t.CallExpression>[];\n}>({\n  CallExpression(child, { allSuperCalls }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  },\n});\n\n/**\n * Given a function, traverse its contents, and if there are references to \"this\", \"arguments\", \"super\",\n * or \"new.target\", ensure that these references reference the parent environment around this function.\n *\n * @returns `thisBinding`: the name of the injected reference to `this`; for example \"_this\"\n * @returns `fnPath`: the new path to the function node. This is different from the fnPath\n *                    parameter when the function node is wrapped in another node.\n */\nfunction hoistFunctionEnvironment(\n  fnPath: NodePath<t.Function>,\n  // TODO(Babel 8): Consider defaulting to `false` for spec compliance\n  noNewArrows: boolean | void = true,\n  allowInsertArrow: boolean | void = true,\n  allowInsertArrowWithRest: boolean | void = true,\n): { thisBinding: string; fnPath: NodePath<t.Function> } {\n  let arrowParent;\n  let thisEnvFn: NodePath<t.Function> = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      arrowParent ??= p;\n      return false;\n    }\n    return (\n      p.isFunction() ||\n      p.isProgram() ||\n      p.isClassProperty({ static: false }) ||\n      p.isClassPrivateProperty({ static: false })\n    );\n  }) as NodePath<t.Function>;\n  const inConstructor = thisEnvFn.isClassMethod({ kind: \"constructor\" });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      // It's safe to wrap this function in another and not hoist to the\n      // top level because the 'this' binding is constant in class\n      // properties (since 'super()' has already been called), so we don't\n      // need to capture/reassign it at the top level.\n      fnPath.replaceWith(\n        callExpression(\n          arrowFunctionExpression([], toExpression(fnPath.node)),\n          [],\n        ),\n      );\n      thisEnvFn = fnPath.get(\"callee\") as NodePath<t.ArrowFunctionExpression>;\n      fnPath = thisEnvFn.get(\"body\") as NodePath<t.FunctionExpression>;\n    } else {\n      throw fnPath.buildCodeFrameError(\n        \"Unable to transform arrow inside class property\",\n      );\n    }\n  }\n\n  const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } =\n    getScopeInformation(fnPath);\n\n  // Convert all super() calls in the constructor, if super is used in an arrow.\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-arrow-functions', \" +\n          \"it's not possible to compile `super()` in an arrow function without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n    if (!allowInsertArrowWithRest) {\n      // preset-env with target `since 2017` enables `transform-parameters` without `transform-classes`.\n      throw superCalls[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-parameters', \" +\n          \"it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n    const allSuperCalls: NodePath<t.CallExpression>[] = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, { allSuperCalls });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  // Convert all \"arguments\" references in the arrow to point at the alias.\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(\n          binaryExpression(\n            \"===\",\n            unaryExpression(\"typeof\", args()),\n            stringLiteral(\"undefined\"),\n          ),\n          thisEnvFn.scope.buildUndefinedNode(),\n          args(),\n        );\n      } else {\n        return args();\n      }\n    });\n\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  // Convert all \"new.target\" references in the arrow to point at the alias.\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () =>\n      metaProperty(identifier(\"new\"), identifier(\"target\")),\n    );\n\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  // Convert all \"super.prop\" references to point at aliases.\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\n        \"When using '@babel/plugin-transform-arrow-functions', \" +\n          \"it's not possible to compile `super.prop` in an arrow function without compiling classes.\\n\" +\n          \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n      );\n    }\n\n    const flatSuperProps: NodePath<t.MemberExpression>[] = superProps.reduce(\n      (acc, superProp) => acc.concat(standardizeSuperProperty(superProp)),\n      [],\n    );\n\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed\n        ? \"\"\n        : // @ts-expect-error super property must not contain private name\n          superProp.get(\"property\").node.name;\n\n      const superParentPath = superProp.parentPath;\n\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node,\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node,\n      });\n      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({\n        tag: superProp.node,\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n\n      const args: t.Expression[] = [];\n      if (superProp.node.computed) {\n        // SuperProperty must not be a private name\n        args.push(superProp.get(\"property\").node as t.Expression);\n      }\n\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n\n        thisPaths.push(\n          superParentPath.get(\"arguments.0\") as NodePath<t.ThisExpression>,\n        );\n      } else if (isAssignment) {\n        // Replace not only the super.prop, but the whole assignment\n        superParentPath.replaceWith(call);\n      } else if (isTaggedTemplate) {\n        superProp.replaceWith(\n          callExpression(memberExpression(call, identifier(\"bind\"), false), [\n            thisExpression(),\n          ]),\n        );\n\n        thisPaths.push(\n          superProp.get(\"arguments.0\") as NodePath<t.ThisExpression>,\n        );\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  // Convert all \"this\" references in the arrow to point at the alias.\n  let thisBinding: string | null;\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (\n      noNewArrows ||\n      // In subclass constructors, still need to rewrite because \"this\" can't be bound in spec mode\n      // because it might not have been initialized yet.\n      (inConstructor && hasSuperClass(thisEnvFn))\n    ) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX()\n          ? jsxIdentifier(thisBinding)\n          : identifier(thisBinding);\n\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return { thisBinding, fnPath };\n}\n\ntype LogicalOp = Parameters<typeof logicalExpression>[0];\ntype BinaryOp = Parameters<typeof binaryExpression>[0];\n\nfunction isLogicalOp(op: string): op is LogicalOp {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(\n  superProp: NodePath<t.MemberExpression>,\n):\n  | [NodePath<t.MemberExpression>]\n  | [NodePath<t.MemberExpression>, NodePath<t.MemberExpression>] {\n  if (\n    superProp.parentPath.isAssignmentExpression() &&\n    superProp.parentPath.node.operator !== \"=\"\n  ) {\n    const assignmentPath = superProp.parentPath;\n\n    const op = assignmentPath.node.operator.slice(0, -1) as\n      | LogicalOp\n      | BinaryOp;\n\n    const value = assignmentPath.node.right;\n\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      // from: super[foo] **= 4;\n      // to:   super[tmp = foo] = super[tmp] ** 4;\n\n      // from: super[foo] ??= 4;\n      // to:   super[tmp = foo] ?? super[tmp] = 4;\n\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n\n      const object = superProp.node.object;\n      const property = superProp.node.property as t.Expression;\n\n      assignmentPath\n        .get(\"left\")\n        .replaceWith(\n          memberExpression(\n            object,\n            assignmentExpression(\"=\", tmp, property),\n            true /* computed */,\n          ),\n        );\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(tmp.name), true /* computed */),\n            value,\n          ),\n        );\n    } else {\n      // from: super.foo **= 4;\n      // to:   super.foo = super.foo ** 4;\n\n      // from: super.foo ??= 4;\n      // to:   super.foo ?? super.foo = 4;\n\n      const object = superProp.node.object;\n      const property = superProp.node.property as t.Identifier;\n\n      assignmentPath\n        .get(\"left\")\n        .replaceWith(memberExpression(object, property));\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(property.name)),\n            value,\n          ),\n        );\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(\n        logicalExpression(\n          op,\n          assignmentPath.node.left as t.MemberExpression,\n          assignmentPath.node.right,\n        ),\n      );\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [\n      assignmentPath.get(\"left\") as NodePath<t.MemberExpression>,\n      assignmentPath.get(\"right\").get(\"left\") as NodePath<t.MemberExpression>,\n    ];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed\n      ? superProp.scope.generateDeclaredUidIdentifier(\"prop\")\n      : null;\n\n    const parts: t.Expression[] = [\n      assignmentExpression(\n        \"=\",\n        tmp,\n        memberExpression(\n          superProp.node.object,\n          computedKey\n            ? assignmentExpression(\n                \"=\",\n                computedKey,\n                superProp.node.property as t.Expression,\n              )\n            : superProp.node.property,\n          superProp.node.computed,\n        ),\n      ),\n      assignmentExpression(\n        \"=\",\n        memberExpression(\n          superProp.node.object,\n          computedKey ? identifier(computedKey.name) : superProp.node.property,\n          superProp.node.computed,\n        ),\n        binaryExpression(\n          // map `++` to `+`, and `--` to `-`\n          superProp.parentPath.node.operator[0] as \"+\" | \"-\",\n          identifier(tmp.name),\n          numericLiteral(1),\n        ),\n      ),\n    ];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n\n    const left = updateExpr.get(\n      \"expressions.0.right\",\n    ) as NodePath<t.MemberExpression>;\n    const right = updateExpr.get(\n      \"expressions.1.left\",\n    ) as NodePath<t.MemberExpression>;\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(\n    op: BinaryOp | \"=\",\n    left: t.MemberExpression,\n    right: t.Expression,\n  ) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn: NodePath<t.Function>) {\n  return (\n    thisEnvFn.isClassMethod() &&\n    !!(thisEnvFn.parentPath.parentPath.node as t.Class).superClass\n  );\n}\n\nconst assignSuperThisVisitor = environmentVisitor<{\n  supers: WeakSet<t.CallExpression>;\n  thisBinding: string;\n}>({\n  CallExpression(child, { supers, thisBinding }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n\n    child.replaceWithMultiple([\n      child.node,\n      assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\")),\n    ]);\n  },\n});\n\n// Create a binding that evaluates to the \"this\" of the given function.\nfunction getThisBinding(\n  thisEnvFn: NodePath<t.Function>,\n  inConstructor: boolean,\n) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding,\n    });\n  });\n}\n\n// Create a binding for a function that will call \"super()\" with arguments passed through.\nfunction getSuperBinding(thisEnvFn: NodePath<t.Function>) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression(\n      [restElement(argsBinding)],\n      callExpression(_super(), [spreadElement(identifier(argsBinding.name))]),\n    );\n  });\n}\n\n// Create a binding for a function that will call \"super.foo\" or \"super[foo]\".\nfunction getSuperPropBinding(\n  thisEnvFn: NodePath<t.Function>,\n  isAssignment: boolean,\n  propName: string,\n) {\n  const op = isAssignment ? \"set\" : \"get\";\n\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n\n    let fnBody;\n    if (propName) {\n      // () => super.foo\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      // (method) => super[method]\n      argsList.unshift(method);\n      fnBody = memberExpression(\n        _super(),\n        identifier(method.name),\n        true /* computed */,\n      );\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(\n  thisEnvFn: NodePath,\n  key: string,\n  init: (name: string) => t.Expression,\n) {\n  const cacheKey = \"binding:\" + key;\n  let data: string | undefined = thisEnvFn.getData(cacheKey);\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data),\n    });\n  }\n\n  return data;\n}\n\ntype ScopeInfo = {\n  thisPaths: NodePath<t.ThisExpression | t.JSXIdentifier>[];\n  superCalls: NodePath<t.CallExpression>[];\n  superProps: NodePath<t.MemberExpression>[];\n  argumentsPaths: NodePath<t.Identifier | t.JSXIdentifier>[];\n  newTargetPaths: NodePath<t.MetaProperty>[];\n};\n\nconst getScopeInformationVisitor = environmentVisitor<ScopeInfo>({\n  ThisExpression(child, { thisPaths }) {\n    thisPaths.push(child);\n  },\n  JSXIdentifier(child, { thisPaths }) {\n    if (child.node.name !== \"this\") return;\n    if (\n      !child.parentPath.isJSXMemberExpression({ object: child.node }) &&\n      !child.parentPath.isJSXOpeningElement({ name: child.node })\n    ) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n  CallExpression(child, { superCalls }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n  MemberExpression(child, { superProps }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n  Identifier(child, { argumentsPaths }) {\n    if (!child.isReferencedIdentifier({ name: \"arguments\" })) return;\n\n    let curr = child.scope;\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while ((curr = curr.parent));\n\n    argumentsPaths.push(child);\n  },\n  MetaProperty(child, { newTargetPaths }) {\n    if (!child.get(\"meta\").isIdentifier({ name: \"new\" })) return;\n    if (!child.get(\"property\").isIdentifier({ name: \"target\" })) return;\n\n    newTargetPaths.push(child);\n  },\n});\n\nfunction getScopeInformation(fnPath: NodePath) {\n  const thisPaths: ScopeInfo[\"thisPaths\"] = [];\n  const argumentsPaths: ScopeInfo[\"argumentsPaths\"] = [];\n  const newTargetPaths: ScopeInfo[\"newTargetPaths\"] = [];\n  const superProps: ScopeInfo[\"superProps\"] = [];\n  const superCalls: ScopeInfo[\"superCalls\"] = [];\n\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  });\n\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  };\n}\n\nexport function splitExportDeclaration(\n  this: NodePath<t.ExportDefaultDeclaration | t.ExportNamedDeclaration>,\n): NodePath<t.Declaration> {\n  if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n  if (this.isExportNamedDeclaration() && this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const declaration = this.get(\"declaration\");\n\n  if (this.isExportDefaultDeclaration()) {\n    const standaloneDeclaration =\n      declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const exportExpr =\n      declaration.isFunctionExpression() || declaration.isClassExpression();\n\n    const scope = declaration.isScope()\n      ? declaration.scope.parent\n      : declaration.scope;\n\n    // @ts-expect-error id is not defined in expressions other than function/class\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || exportExpr) {\n        declaration.node.id = cloneNode(id);\n      }\n    } else if (exportExpr && scope.hasBinding(id.name)) {\n      needBindingRegistration = true;\n\n      id = scope.generateUidIdentifier(id.name);\n    }\n\n    const updatedDeclaration = standaloneDeclaration\n      ? declaration.node\n      : variableDeclaration(\"var\", [\n          variableDeclarator(\n            cloneNode(id),\n            // @ts-expect-error When `standaloneDeclaration` is false, declaration must not be a Function/ClassDeclaration\n            declaration.node,\n          ),\n        ]);\n\n    const updatedExportDeclaration = exportNamedDeclaration(null, [\n      exportSpecifier(cloneNode(id), identifier(\"default\")),\n    ]);\n\n    this.insertAfter(updatedExportDeclaration);\n    this.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(this);\n    }\n\n    return this;\n  } else if (this.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n\n  this.insertAfter(aliasDeclar);\n  this.replaceWith(declaration.node);\n  return this;\n}\n\nconst refersOuterBindingVisitor: Visitor<{\n  needsRename: boolean;\n  name: string;\n}> = {\n  \"ReferencedIdentifier|BindingIdentifier\"(\n    path: NodePath<t.Identifier>,\n    state,\n  ) {\n    // check if this node matches our function id\n    if (path.node.name !== state.name) return;\n    state.needsRename = true;\n    path.stop();\n  },\n  Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.name)) {\n      path.skip();\n    }\n  },\n};\n\nexport function ensureFunctionName<\n  N extends t.FunctionExpression | t.ClassExpression,\n>(this: NodePath<N>, supportUnicodeId: boolean): null | NodePath<N> {\n  if (this.node.id) return this;\n\n  const res = getFunctionName(this.node, this.parent);\n  if (res == null) return this;\n  let { name } = res;\n\n  if (!supportUnicodeId && /[\\uD800-\\uDFFF]/.test(name)) {\n    return null;\n  }\n\n  if (name.startsWith(\"get \") || name.startsWith(\"set \")) {\n    // TODO: Remove this to support naming getters and setters\n    return null;\n  }\n\n  name = toBindingIdentifierName(name.replace(/[/ ]/g, \"_\"));\n  const id = identifier(name);\n  inherits(id, res.originalNode);\n\n  const state = { needsRename: false, name };\n\n  // check to see if we have a local binding of the id we're setting inside of\n  // the function, this is important as there are caveats associated\n\n  const { scope } = this;\n  const binding = scope.getOwnBinding(name);\n  if (binding) {\n    if (binding.kind === \"param\") {\n      // safari will blow up in strict mode with code like:\n      //\n      //   let t = function t(t) {};\n      //\n      // with the error:\n      //\n      //   Cannot declare a parameter named 't' as it shadows the name of a\n      //   strict mode function.\n      //\n      // this isn't to the spec and they've invented this behaviour which is\n      // **extremely** annoying so we avoid setting the name if it has a param\n      // with the same id\n      state.needsRename = true;\n    } else {\n      // otherwise it's defined somewhere in scope like:\n      //\n      //   let t = function () {\n      //     let t = 2;\n      //   };\n      //\n      // so we can safely just set the id and move along as it shadows the\n      // bound function id\n    }\n  } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {\n    this.traverse(refersOuterBindingVisitor, state);\n  }\n\n  if (!state.needsRename) {\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n\n  if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n    // we can just munge the local binding\n    scope.rename(id.name);\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n\n  // TODO: we don't currently support wrapping class expressions\n  if (!isFunction(this.node)) return null;\n\n  // need to add a wrapper since we can't change the references\n\n  const key = scope.generateUidIdentifier(id.name);\n  // shim in dummy params to retain function arity, if you try to read the\n  // source then you'll get the original since it's proxied so it's all good\n  const params = [];\n  for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {\n    params.push(scope.generateUidIdentifier(\"x\"));\n  }\n  const call = template.expression.ast`\n    (function (${key}) {\n      function ${id}(${params}) {\n        return ${cloneNode(key)}.apply(this, arguments);\n      }\n\n      ${cloneNode(id)}.toString = function () {\n        return ${cloneNode(key)}.toString();\n      }\n\n      return ${cloneNode(id)};\n    })(${toExpression(this.node)})\n  ` as t.CallExpression;\n\n  return this.replaceWith(call)[0].get(\"arguments.0\") as NodePath<N>;\n}\n\nfunction getFunctionArity(node: t.Function): number {\n  const count = node.params.findIndex(\n    param => isAssignmentPattern(param) || isRestElement(param),\n  );\n  return count === -1 ? node.params.length : count;\n}\n", "// This file contains methods responsible for introspecting the current path for certain values.\n\nimport type NodePath from \"./index.ts\";\nimport {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern as _matchesPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Match the current node if it matches the provided `pattern`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nexport function matchesPattern(\n  this: NodePath,\n  pattern: string,\n  allowPartial?: boolean,\n): boolean {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Check whether we have the input `key`. If the `key` references an array then we check\n   * if the array has any items, otherwise we just check if it's falsy.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.has = function has<N extends t.Node>(\n    this: NodePath<N>,\n    key: keyof N,\n  ): boolean {\n    const val = (this.node as N)?.[key];\n    if (val && Array.isArray(val)) {\n      return !!val.length;\n    } else {\n      return !!val;\n    }\n  };\n}\n\nexport function isStatic(this: NodePath): boolean {\n  return this.scope.isStatic(this.node);\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Alias of `has`.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.is = exports.has;\n\n  /**\n   * Opposite of `has`.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.isnt = function isnt<N extends t.Node>(\n    this: NodePath<N>,\n    key: keyof N,\n  ): boolean {\n    // @ts-expect-error Babel 7\n    return !this.has(key);\n  };\n\n  /**\n   * Check whether the path node `key` strict equals `value`.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.equals = function equals<N extends t.Node>(\n    this: NodePath<N>,\n    key: keyof N,\n    value: any,\n  ): boolean {\n    return (this.node as N)[key] === value;\n  };\n}\n\n/**\n * Check the type against our stored internal type of the node. This is handy when a node has\n * been removed yet we still internally know the type and need it to calculate node replacement.\n */\n\nexport function isNodeType(this: NodePath, type: string): boolean {\n  return isType(this.type, type);\n}\n\n/**\n * This checks whether or not we're in one of the following positions:\n *\n *   for (KEY in right);\n *   for (KEY;;);\n *\n * This is because these spots allow VariableDeclarations AND normal expressions so we need\n * to tell the path replacement that it's ok to replace this with an expression.\n */\n\nexport function canHaveVariableDeclarationOrExpression(this: NodePath) {\n  return (\n    (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor()\n  );\n}\n\n/**\n * This checks whether we are swapping an arrow function's body between an\n * expression and a block statement (or vice versa).\n *\n * This is because arrow functions may implicitly return an expression, which\n * is the same as containing a block statement.\n */\n\nexport function canSwapBetweenExpressionAndStatement(\n  this: NodePath,\n  replacement: t.Node,\n): boolean {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n\n  return false;\n}\n\n/**\n * Check whether the current path references a completion record\n */\n\nexport function isCompletionRecord(\n  this: NodePath,\n  allowInsideFunction?: boolean,\n): boolean {\n  let path = this;\n  let first = true;\n\n  do {\n    const { type, container } = path;\n\n    // we're in a function so can't be a completion record\n    if (!first && (path.isFunction() || type === \"StaticBlock\")) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    // check to see if we're the last item in the container and if we are\n    // we're a completion record!\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while (\n    (path = path.parentPath) &&\n    !path.isProgram() &&\n    !path.isDoExpression()\n  );\n\n  return true;\n}\n\n/**\n * Check whether or not the current `key` allows either a single statement or block statement\n * so we can explode it if necessary.\n */\n\nexport function isStatementOrBlock(this: NodePath): boolean {\n  if (\n    this.parentPath.isLabeledStatement() ||\n    isBlockStatement(this.container as t.Node)\n  ) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key as string);\n  }\n}\n\n/**\n * Check if the currently assigned path references the `importName` of `moduleSource`.\n */\n\nexport function referencesImport(\n  this: NodePath,\n  moduleSource: string,\n  importName: string,\n): boolean {\n  if (!this.isReferencedIdentifier()) {\n    if (\n      (this.isJSXMemberExpression() &&\n        this.node.property.name === importName) ||\n      ((this.isMemberExpression() || this.isOptionalMemberExpression()) &&\n        (this.node.computed\n          ? isStringLiteral(this.node.property, { value: importName })\n          : (this.node.property as t.Identifier).name === importName))\n    ) {\n      const object = (\n        this as NodePath<t.MemberExpression | t.OptionalMemberExpression>\n      ).get(\"object\");\n      return (\n        object.isReferencedIdentifier() &&\n        object.referencesImport(moduleSource, \"*\")\n      );\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding((this.node as t.Identifier).name);\n  if (!binding || binding.kind !== \"module\") return false;\n\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  // check moduleSource\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (\n    path.isImportSpecifier() &&\n    isIdentifier(path.node.imported, { name: importName })\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the source code associated with this node.\n */\n\nexport function getSource(this: NodePath): string {\n  const node = this.node;\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n  return \"\";\n}\n\nexport function willIMaybeExecuteBefore(\n  this: NodePath,\n  target: NodePath,\n): boolean {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path: NodePath) {\n  return path.isProgram()\n    ? path\n    : (\n        path.parentPath.scope.getFunctionParent() ||\n        path.parentPath.scope.getProgramParent()\n      ).path;\n}\n\nfunction isExecutionUncertain(type: t.Node[\"type\"], key: string) {\n  switch (type) {\n    // a && FOO\n    // a || FOO\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    // a ? FOO : FOO\n    // if (a) FOO; else FOO;\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    // while (a) FOO;\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    // for (a; b; FOO) FOO;\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    // switch (a) { FOO }\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    // try { a } catch FOO finally { b }\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    // var [ x = FOO ]\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    // a?.[FOO]\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    // a?.(FOO)\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths: NodePath[], maxIndex: number) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// TODO(Babel 8)\n// This can be { before: boolean, after: boolean, unknown: boolean }.\n// This allows transforms like the tdz one to treat cases when the status\n// is both before and unknown/after like if it were before.\ntype RelativeExecutionStatus = \"before\" | \"after\" | \"unknown\";\n\n// Used to avoid infinite recursion in cases like\n//   function f() { if (false) f(); }\n//   f();\n// It also works with indirect recursion.\nconst SYMBOL_CHECKING = Symbol();\n\ntype ExecutionStatusCache = Map<\n  t.Node,\n  Map<t.Node, RelativeExecutionStatus | typeof SYMBOL_CHECKING>\n>;\n\n/**\n * Given a `target` check the execution status of it relative to the current path.\n *\n * \"Execution status\" simply refers to where or not we **think** this will execute\n * before or after the input `target` element.\n */\n\nexport function _guessExecutionStatusRelativeTo(\n  this: NodePath,\n  target: NodePath,\n): RelativeExecutionStatus {\n  return _guessExecutionStatusRelativeToCached(this, target, new Map());\n}\n\nfunction _guessExecutionStatusRelativeToCached(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  // check if the two paths are in different functions, we can't track execution of these\n  const funcParent = {\n    this: getOuterFunction(base),\n    target: getOuterFunction(target),\n  };\n\n  // here we check the `node` equality as sometimes we may have different paths for the\n  // same node due to path thrashing\n  if (funcParent.target.node !== funcParent.this.node) {\n    return _guessExecutionStatusRelativeToDifferentFunctionsCached(\n      base,\n      funcParent.target,\n      cache,\n    );\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: base.getAncestry(),\n  };\n\n  // If this is an ancestor of the target path,\n  // e.g. f(g); where this is f and target is g.\n  if (paths.target.includes(base)) return \"after\";\n  if (paths.this.includes(target)) return \"before\";\n\n  // get ancestor where the branches intersect\n  let commonPath;\n  const commonIndex = { target: 0, this: 0 };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\n      \"Internal Babel error - The two compared nodes\" +\n        \" don't appear to belong to the same program.\",\n    );\n  }\n\n  if (\n    isExecutionUncertainInList(paths.this, commonIndex.this - 1) ||\n    isExecutionUncertainInList(paths.target, commonIndex.target - 1)\n  ) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1],\n  };\n\n  // container list so let's see which one is after the other\n  // e.g. [ THIS, TARGET ]\n  if (\n    divergence.target.listKey &&\n    divergence.this.listKey &&\n    divergence.target.container === divergence.this.container\n  ) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  // otherwise we're associated by a parent node, check which key comes before the other\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey),\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nfunction _guessExecutionStatusRelativeToDifferentFunctionsInternal(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  if (!target.isFunctionDeclaration()) {\n    if (\n      _guessExecutionStatusRelativeToCached(base, target, cache) === \"before\"\n    ) {\n      return \"before\";\n    }\n    return \"unknown\";\n  } else if (target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  // so we're in a completely different function, if this is a function declaration\n  // then we can be a bit smarter and handle cases where the function is either\n  // a. not called at all (part of an export)\n  // b. called directly\n  const binding = target.scope.getBinding(target.node.id.name);\n\n  // no references!\n  if (!binding.references) return \"before\";\n\n  const referencePaths: Array<NodePath> = binding.referencePaths;\n\n  let allStatus;\n\n  // verify that all the calls have the same execution status\n  for (const path of referencePaths) {\n    // if a reference is a child of the function we're checking against then we can\n    // safely ignore it\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      // This function is passed as a reference, so we don't\n      // know when it will be called.\n      return \"unknown\";\n    }\n\n    const status = _guessExecutionStatusRelativeToCached(base, path, cache);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction _guessExecutionStatusRelativeToDifferentFunctionsCached(\n  base: NodePath,\n  target: NodePath,\n  cache: ExecutionStatusCache,\n): RelativeExecutionStatus {\n  let nodeMap = cache.get(base.node);\n  let cached;\n\n  if (!nodeMap) {\n    cache.set(base.node, (nodeMap = new Map()));\n  } else if ((cached = nodeMap.get(target.node))) {\n    if (cached === SYMBOL_CHECKING) {\n      return \"unknown\";\n    }\n    return cached;\n  }\n\n  nodeMap.set(target.node, SYMBOL_CHECKING);\n\n  const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(\n    base,\n    target,\n    cache,\n  );\n\n  nodeMap.set(target.node, result);\n  return result;\n}\n\n/**\n * Resolve a \"pointer\" `NodePath` to it's absolute path.\n */\nexport function resolve(\n  this: NodePath,\n  dangerous?: boolean,\n  resolved?: NodePath[],\n) {\n  return _resolve.call(this, dangerous, resolved) || this;\n}\n\nexport function _resolve(\n  this: NodePath,\n  dangerous?: boolean,\n  resolved?: NodePath[],\n): NodePath | undefined | null {\n  // detect infinite recursion\n  // todo: possibly have a max length on this just to be safe\n  if (resolved?.includes(this)) return;\n\n  // we store all the paths we've \"resolved\" in this array to prevent infinite recursion\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {\n      // otherwise it's a request for a pattern and that's a bit more tricky\n    }\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n\n    // reassigned so we can't really resolve it\n    if (!binding.constant) return;\n\n    // todo - lookup module in dependency graph\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      // If the identifier resolves to parent node then we can't really resolve it.\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    // @ ts-ignore todo: babel-types\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    // this is dangerous, as non-direct target assignments will mutate it's state\n    // making this resolution inaccurate\n\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n\n    // @ts-expect-error todo(flow->ts): NullLiteral\n    const targetName = targetKey.value;\n\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n      for (const prop of props as any[]) {\n        if (!prop.isProperty()) continue;\n\n        const key = prop.get(\"key\");\n\n        // { foo: obj }\n        let match =\n          prop.isnt(\"computed\") && key.isIdentifier({ name: targetName });\n\n        // { \"foo\": \"obj\" } or { [\"foo\"]: \"obj\" }\n        match = match || key.isLiteral({ value: targetName });\n\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nexport function isConstantExpression(this: NodePath): boolean {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression =>\n        expression.isConstantExpression(),\n      );\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    const { operator } = this.node;\n    return (\n      operator !== \"in\" &&\n      operator !== \"instanceof\" &&\n      this.get(\"left\").isConstantExpression() &&\n      this.get(\"right\").isConstantExpression()\n    );\n  }\n\n  if (this.isMemberExpression()) {\n    return (\n      !this.node.computed &&\n      this.get(\"object\").isIdentifier({ name: \"Symbol\" }) &&\n      !this.scope.hasBinding(\"Symbol\", { noGlobals: true })\n    );\n  }\n\n  if (this.isCallExpression()) {\n    return (\n      this.node.arguments.length === 1 &&\n      this.get(\"callee\").matchesPattern(\"Symbol.for\") &&\n      !this.scope.hasBinding(\"Symbol\", { noGlobals: true }) &&\n      this.get(\"arguments\")[0].isStringLiteral()\n    );\n  }\n\n  return false;\n}\n\nexport function isInStrictMode(this: NodePath) {\n  const start = this.isProgram() ? this : this.parentPath;\n\n  const strictParent = start.find(path => {\n    if (path.isProgram({ sourceType: \"module\" })) return true;\n\n    if (path.isClass()) return true;\n\n    if (\n      path.isArrowFunctionExpression() &&\n      !path.get(\"body\").isBlockStatement()\n    ) {\n      return false;\n    }\n\n    let body: t.BlockStatement | t.Program;\n    if (path.isFunction()) {\n      body = path.node.body as t.BlockStatement;\n    } else if (path.isProgram()) {\n      // @ts-expect-error TODO: TS thinks that `path` here cannot be\n      // Program due to the `isProgram()` check at the beginning of\n      // the function\n      body = path.node;\n    } else {\n      return false;\n    }\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n\n  return !!strictParent;\n}\n", "// This file contains methods responsible for dealing with/retrieving children or siblings.\n\nimport type TraversalContext from \"../context.ts\";\nimport NodePath from \"./index.ts\";\nimport {\n  getAssignmentIdentifiers as _getAssignmentIdentifiers,\n  getBindingIdentifiers as _getBindingIdentifiers,\n  getOuterBindingIdentifiers as _getOuterBindingIdentifiers,\n  numericLiteral,\n  unaryExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\ntype Completion = {\n  path: NodePath;\n  type: 0 | 1;\n};\n\ntype CompletionContext = {\n  // whether the current context allows `break` statement. When it allows, we have\n  // to search all the statements for potential `break`\n  canHaveBreak: boolean;\n  // whether the statement is an immediate descendant of a switch case clause\n  inCaseClause: boolean;\n  // whether the `break` statement record should be populated to upper level\n  // when a `break` statement is an immediate descendant of a block statement, e.g.\n  // `{ break }`, it can influence the control flow in the upper levels.\n  shouldPopulateBreak: boolean;\n};\n\nfunction NormalCompletion(path: NodePath): Completion {\n  return { type: NORMAL_COMPLETION, path };\n}\n\nfunction BreakCompletion(path: NodePath): Completion {\n  return { type: BREAK_COMPLETION, path };\n}\n\nexport function getOpposite(this: NodePath): NodePath | null {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n  return null;\n}\n\nfunction addCompletionRecords(\n  path: NodePath | null | undefined,\n  records: Completion[],\n  context: CompletionContext,\n): Completion[] {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n  return records;\n}\n\nfunction completionRecordForSwitch(\n  cases: NodePath<t.SwitchCase>[],\n  records: Completion[],\n  context: CompletionContext,\n): Completion[] {\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation\n  let lastNormalCompletions: Completion[] = [];\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n    const caseCompletions = _getCompletionRecords(casePath, context);\n    const normalCompletions = [];\n    const breakCompletions = [];\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n    records.push(...breakCompletions);\n  }\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions: Completion[]) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\n/**\n * Determine how we should handle the break statement for break completions\n *\n * @param {Completion[]} completions\n * @param {boolean} reachable Whether the break statement is reachable after\n   we mark the normal completions _before_ the given break completions as the final\n   completions. For example,\n   `{ 0 }; break;` is transformed to `{ return 0 }; break;`, the `break` here is unreachable\n   and thus can be removed without consequences. We may in the future reserve them instead since\n   we do not consistently remove unreachable statements _after_ break\n   `{ var x = 0 }; break;` is transformed to `{ var x = 0 }; return void 0;`, the `break` is reachable\n   because we can not wrap variable declaration under a return statement\n */\nfunction replaceBreakStatementInBreakCompletion(\n  completions: Completion[],\n  reachable: boolean,\n) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({ label: null })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(\n  paths: NodePath[],\n  context: CompletionContext,\n): Completion[] {\n  const completions = [];\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = { ...context, inCaseClause: false };\n      if (\n        path.isBlockStatement() &&\n        (context.inCaseClause || // case test: { break }\n          context.shouldPopulateBreak) // case test: { { break } }\n      ) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n      const statementCompletions = _getCompletionRecords(path, newContext);\n      if (\n        statementCompletions.length > 0 &&\n        // we can stop search `paths` when we have seen a `path` that is\n        // effectively a `break` statement. Examples are\n        // - `break`\n        // - `if (true) { 1; break } else { 2; break }`\n        // - `{ break }```\n        // In other words, the paths after this `path` are unreachable\n        statementCompletions.every(c => c.type === BREAK_COMPLETION)\n      ) {\n        if (\n          lastNormalCompletions.length > 0 &&\n          statementCompletions.every(c =>\n            c.path.isBreakStatement({ label: null }),\n          )\n        ) {\n          // when a break completion has a path as BreakStatement, it must be `{ break }`\n          // whose completion value we can not determine, otherwise it would have been\n          // replaced by `replaceBreakStatementInBreakCompletion`\n          // When we have seen normal completions from the last statement\n          // it is safe to stop populating break and mark normal completions as break\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n          // Declarations have empty completion record, however they can not be nested\n          // directly in return statement, i.e. `return (var a = 1)` is invalid.\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(\n              statementCompletions,\n              /* reachable */ true,\n            );\n          }\n          replaceBreakStatementInBreakCompletion(\n            statementCompletions,\n            /* reachable */ false,\n          );\n        } else {\n          completions.push(...statementCompletions);\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(\n              statementCompletions,\n              /* reachable */ true,\n            );\n          }\n        }\n        break;\n      }\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    // When we are in a context where `break` must not exist, we can skip linear\n    // search on statement lists and assume that the last\n    // non-variable-declaration statement determines the completion.\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n      if (\n        pathCompletions.length > 1 ||\n        (pathCompletions.length === 1 &&\n          !pathCompletions[0].path.isVariableDeclaration())\n      ) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n  return completions;\n}\n\nfunction _getCompletionRecords(\n  path: NodePath,\n  context: CompletionContext,\n): Completion[] {\n  let records: Completion[] = [];\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (\n    path.isDoExpression() ||\n    path.isFor() ||\n    path.isWhile() ||\n    path.isLabeledStatement()\n  ) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true,\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\n/**\n * Retrieve the completion records of a given path.\n * Note: to ensure proper support on `break` statement, this method\n * will manipulate the AST around the break statement. Do not call the method\n * twice for the same path.\n *\n * @export\n * @param {NodePath} this\n * @returns {NodePath[]} Completion records\n */\nexport function getCompletionRecords(this: NodePath): NodePath[] {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false,\n  });\n  return records.map(r => r.path);\n}\n\nexport function getSibling(this: NodePath, key: string | number): NodePath {\n  return NodePath.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key,\n  }).setContext(this.context);\n}\n\nexport function getPrevSibling(this: NodePath): NodePath {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  return this.getSibling(this.key - 1);\n}\n\nexport function getNextSibling(this: NodePath): NodePath {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  return this.getSibling(this.key + 1);\n}\n\nexport function getAllNextSiblings(this: NodePath): NodePath[] {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  let _key: number = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n  return siblings;\n}\n\nexport function getAllPrevSiblings(this: NodePath): NodePath[] {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  let _key: number = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n  return siblings;\n}\n\n// convert \"1\" to 1 (string index to number index)\ntype MaybeToIndex<T extends string> = T extends `${bigint}` ? number : T;\n\ntype Pattern<Obj extends string, Prop extends string> = `${Obj}.${Prop}`;\n\n// split \"body.body.1\" to [\"body\", \"body\", 1]\ntype Split<P extends string> =\n  P extends Pattern<infer O, infer U>\n    ? [MaybeToIndex<O>, ...Split<U>]\n    : [MaybeToIndex<P>];\n\n// traverse the Node with tuple path [\"body\", \"body\", 1]\n// Path should be created with Split\ntype Trav<\n  Node extends t.Node | t.Node[],\n  Path extends unknown[],\n> = Path extends [infer K, ...infer R]\n  ? K extends keyof Node\n    ? Node[K] extends t.Node | t.Node[]\n      ? R extends []\n        ? Node[K]\n        : Trav<Node[K], R>\n      : never\n    : never\n  : never;\n\ntype ToNodePath<T> =\n  T extends Array<t.Node | null | undefined>\n    ? Array<NodePath<T[number]>>\n    : T extends t.Node | null | undefined\n      ? NodePath<T>\n      : never;\n\nfunction get<T extends NodePath, K extends keyof T[\"node\"]>(\n  this: T,\n  key: K,\n  context?: boolean | TraversalContext,\n): T extends any\n  ? T[\"node\"][K] extends Array<t.Node | null | undefined>\n    ? Array<NodePath<T[\"node\"][K][number]>>\n    : T[\"node\"][K] extends t.Node | null | undefined\n      ? NodePath<T[\"node\"][K]>\n      : never\n  : never;\n\nfunction get<T extends NodePath, K extends string>(\n  this: T,\n  key: K,\n  context?: boolean | TraversalContext,\n): T extends any ? ToNodePath<Trav<T[\"node\"], Split<K>>> : never;\n\nfunction get(\n  this: NodePath,\n  key: string,\n  context?: true | TraversalContext,\n): NodePath | NodePath[];\n\nfunction get(\n  this: NodePath,\n  key: string,\n  context: true | TraversalContext = true,\n): NodePath | NodePath[] {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n  if (parts.length === 1) {\n    // \"foo\"\n    // @ts-expect-error key may not index T\n    return _getKey.call(this, key, context);\n  } else {\n    // \"foo.bar\"\n    return _getPattern.call(this, parts, context);\n  }\n}\n\nexport { get };\n\nexport function _getKey<T extends t.Node>(\n  this: NodePath<T>,\n  key: keyof T & string,\n  context?: TraversalContext,\n): NodePath | NodePath[] {\n  const node = this.node as T;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    // requested a container so give them all the paths\n    return container.map((_, i) => {\n      return NodePath.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i,\n      }).setContext(context);\n    });\n  } else {\n    return NodePath.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key,\n    }).setContext(context);\n  }\n}\n\nexport function _getPattern(\n  this: NodePath,\n  parts: string[],\n  context?: TraversalContext,\n): NodePath | NodePath[] {\n  let path: NodePath | NodePath[] = this;\n  for (const part of parts) {\n    if (part === \".\") {\n      // @ts-expect-error todo(flow-ts): Can path be an array here?\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        // @ts-expect-error part may not index path\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n  return path;\n}\n\nexport function getAssignmentIdentifiers(this: NodePath) {\n  return _getAssignmentIdentifiers(this.node);\n}\n\nfunction getBindingIdentifiers(\n  duplicates: true,\n): Record<string, t.Identifier[]>;\nfunction getBindingIdentifiers(\n  duplicates?: false,\n): Record<string, t.Identifier>;\nfunction getBindingIdentifiers(\n  duplicates: boolean,\n): Record<string, t.Identifier[] | t.Identifier>;\n\nfunction getBindingIdentifiers(\n  this: NodePath,\n  duplicates?: boolean,\n): Record<string, t.Identifier[] | t.Identifier> {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nexport { getBindingIdentifiers };\n\nfunction getOuterBindingIdentifiers(\n  duplicates: true,\n): Record<string, t.Identifier[]>;\nfunction getOuterBindingIdentifiers(\n  duplicates?: false,\n): Record<string, t.Identifier>;\nfunction getOuterBindingIdentifiers(\n  duplicates: boolean,\n): Record<string, t.Identifier[] | t.Identifier>;\n\nfunction getOuterBindingIdentifiers(\n  this: NodePath,\n  duplicates?: boolean,\n): Record<string, t.Identifier[] | t.Identifier> {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nexport { getOuterBindingIdentifiers };\n\nfunction getBindingIdentifierPaths(\n  duplicates: true,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier>[]>;\nfunction getBindingIdentifierPaths(\n  duplicates: false,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier>>;\nfunction getBindingIdentifierPaths(\n  duplicates?: boolean,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]>;\n\n// original source - https://github.com/babel/babel/blob/main/packages/babel-types/src/retrievers/getBindingIdentifiers.js\n// path.getBindingIdentifiers returns nodes where the following re-implementation returns paths\nfunction getBindingIdentifierPaths(\n  this: NodePath,\n  duplicates: boolean = false,\n  outerOnly: boolean = false,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]> {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = (ids[id.node.name] = ids[id.node.name] || []);\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nexport { getBindingIdentifierPaths };\n\nfunction getOuterBindingIdentifierPaths(\n  duplicates: true,\n): Record<string, NodePath<t.Identifier>[]>;\nfunction getOuterBindingIdentifierPaths(\n  duplicates?: false,\n): Record<string, NodePath<t.Identifier>>;\nfunction getOuterBindingIdentifierPaths(\n  duplicates?: boolean,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]>;\n\nfunction getOuterBindingIdentifierPaths(\n  this: NodePath,\n  duplicates: boolean = false,\n) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}\n\nexport { getOuterBindingIdentifierPaths };\n", "// This file contains methods responsible for dealing with comments.\nimport type * as t from \"@babel/types\";\nimport type NodePath from \"./index.ts\";\nimport {\n  addComment as _addComment,\n  addComments as _addComments,\n} from \"@babel/types\";\n\n/**\n * Share comments amongst siblings.\n */\n\nexport function shareCommentsWithSiblings(this: NodePath) {\n  // NOTE: this assumes numbered keys\n  if (typeof this.key === \"string\") return;\n\n  const node = this.node;\n  if (!node) return;\n\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev) {\n    if (leading) {\n      prev.addComments(\n        \"trailing\",\n        removeIfExisting(leading, prev.node.trailingComments),\n      );\n    }\n    if (trailing && !hasNext) prev.addComments(\"trailing\", trailing);\n  }\n  if (hasNext) {\n    if (trailing) {\n      next.addComments(\n        \"leading\",\n        removeIfExisting(trailing, next.node.leadingComments),\n      );\n    }\n    if (leading && !hasPrev) next.addComments(\"leading\", leading);\n  }\n}\n\nfunction removeIfExisting<T>(list: T[], toRemove?: T[]): T[] {\n  if (!toRemove?.length) return list;\n  const set = new Set(toRemove);\n  return list.filter(el => {\n    return !set.has(el);\n  });\n}\n\nexport function addComment(\n  this: NodePath,\n  type: t.CommentTypeShorthand,\n  content: string,\n  line?: boolean,\n) {\n  _addComment(this.node, type, content, line);\n}\n\n/**\n * Give node `comments` of the specified `type`.\n */\n\nexport function addComments(\n  this: NodePath,\n  type: t.CommentTypeShorthand,\n  comments: t.Comment[],\n) {\n  _addComments(this.node, type, comments);\n}\n", "import type { HubInterface } from \"../hub.ts\";\nimport type TraversalContext from \"../context.ts\";\nimport type { ExplodedTraverseOptions } from \"../index.ts\";\nimport * as virtualTypes from \"./lib/virtual-types.ts\";\nimport buildDebug from \"debug\";\nimport traverse from \"../index.ts\";\nimport type { Visitor } from \"../types.ts\";\nimport Scope from \"../scope/index.ts\";\nimport { validate } from \"@babel/types\";\nimport * as t from \"@babel/types\";\nimport * as cache from \"../cache.ts\";\nimport generator from \"@babel/generator\";\n\n// NodePath is split across many files.\nimport * as NodePath_ancestry from \"./ancestry.ts\";\nimport * as NodePath_inference from \"./inference/index.ts\";\nimport * as NodePath_replacement from \"./replacement.ts\";\nimport * as NodePath_evaluation from \"./evaluation.ts\";\nimport * as NodePath_conversion from \"./conversion.ts\";\nimport * as NodePath_introspection from \"./introspection.ts\";\nimport * as NodePath_context from \"./context.ts\";\nimport * as NodePath_removal from \"./removal.ts\";\nimport * as NodePath_modification from \"./modification.ts\";\nimport * as NodePath_family from \"./family.ts\";\nimport * as NodePath_comments from \"./comments.ts\";\nimport * as NodePath_virtual_types_validator from \"./lib/virtual-types-validator.ts\";\nimport type { NodePathAssertions } from \"./generated/asserts.ts\";\nimport type { NodePathValidators } from \"./generated/validators.ts\";\nimport { setup } from \"./context.ts\";\n\nconst debug = buildDebug(\"babel\");\n\nexport const REMOVED = 1 << 0;\nexport const SHOULD_STOP = 1 << 1;\nexport const SHOULD_SKIP = 1 << 2;\n\ndeclare const bit: import(\"../../../../scripts/babel-plugin-bit-decorator/types.d.ts\").BitDecorator<any>;\n\nconst NodePath_Final = class NodePath {\n  constructor(hub: HubInterface, parent: t.Node | null) {\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n\n    this.context = null;\n    this.scope = null;\n  }\n\n  declare parent: t.Node;\n  declare hub: HubInterface;\n  declare data: Record<string | symbol, unknown>;\n  // TraversalContext is configured by setContext\n  declare context: TraversalContext;\n  declare scope: Scope;\n\n  contexts: Array<TraversalContext> = [];\n  state: any = null;\n  opts: ExplodedTraverseOptions | null = null;\n\n  @bit.storage _traverseFlags: number;\n  @bit(REMOVED) accessor removed = false;\n  @bit(SHOULD_STOP) accessor shouldStop = false;\n  @bit(SHOULD_SKIP) accessor shouldSkip = false;\n\n  skipKeys: Record<string, boolean> | null = null;\n  parentPath: NodePath_Final | null = null;\n  container: t.Node | Array<t.Node> | null = null;\n  listKey: string | null = null;\n  key: string | number | null = null;\n  node: t.Node | null = null;\n  type: t.Node[\"type\"] | null = null;\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key,\n  }: {\n    hub?: HubInterface;\n    parentPath: NodePath_Final | null;\n    parent: t.Node;\n    container: t.Node | t.Node[];\n    listKey?: string;\n    key: string | number;\n  }): NodePath_Final {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode =\n      // @ts-expect-error key must present in container\n      container[key];\n\n    const paths = cache.getOrCreateCachedPaths(hub, parent);\n\n    let path = paths.get(targetNode);\n    if (!path) {\n      path = new NodePath(hub, parent) as NodePath_Final;\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    setup.call(path, parentPath, container, listKey, key);\n\n    return path;\n  }\n\n  getScope(this: NodePath_Final, scope: Scope): Scope {\n    return this.isScope() ? new Scope(this) : scope;\n  }\n\n  setData(key: string | symbol, val: any): any {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    return (this.data[key] = val);\n  }\n\n  getData(key: string | symbol, def?: any): any {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  hasNode(): boolean {\n    return this.node != null;\n  }\n\n  buildCodeFrameError(\n    msg: string,\n    Error: new () => Error = SyntaxError,\n  ): Error {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse<T>(this: NodePath_Final, visitor: Visitor<T>, state: T): void;\n  traverse(this: NodePath_Final, visitor: Visitor): void;\n  traverse(this: NodePath_Final, visitor: any, state?: any) {\n    traverse(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key: string, node: any) {\n    validate(this.node, key, node);\n    // @ts-expect-error key must present in this.node\n    this.node[key] = node;\n  }\n\n  getPathLocation(this: NodePath_Final): string {\n    const parts = [];\n    let path: NodePath_Final = this;\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while ((path = path.parentPath));\n    return parts.join(\".\");\n  }\n\n  debug(this: NodePath_Final, message: string) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return generator(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n    // ignore inList = true as it should depend on `listKey`\n  }\n\n  get parentKey(): string {\n    return (this.listKey || this.key) as string;\n  }\n};\n\nconst methods = {\n  // NodePath_ancestry\n  findParent: NodePath_ancestry.findParent,\n  find: NodePath_ancestry.find,\n  getFunctionParent: NodePath_ancestry.getFunctionParent,\n  getStatementParent: NodePath_ancestry.getStatementParent,\n  getEarliestCommonAncestorFrom:\n    NodePath_ancestry.getEarliestCommonAncestorFrom,\n  getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,\n  getAncestry: NodePath_ancestry.getAncestry,\n  isAncestor: NodePath_ancestry.isAncestor,\n  isDescendant: NodePath_ancestry.isDescendant,\n  inType: NodePath_ancestry.inType,\n\n  // NodePath_inference\n  getTypeAnnotation: NodePath_inference.getTypeAnnotation,\n  isBaseType: NodePath_inference.isBaseType,\n  couldBeBaseType: NodePath_inference.couldBeBaseType,\n  baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,\n  isGenericType: NodePath_inference.isGenericType,\n\n  // NodePath_replacement\n  replaceWithMultiple: NodePath_replacement.replaceWithMultiple,\n  replaceWithSourceString: NodePath_replacement.replaceWithSourceString,\n  replaceWith: NodePath_replacement.replaceWith,\n  replaceExpressionWithStatements:\n    NodePath_replacement.replaceExpressionWithStatements,\n  replaceInline: NodePath_replacement.replaceInline,\n\n  // NodePath_evaluation\n  evaluateTruthy: NodePath_evaluation.evaluateTruthy,\n  evaluate: NodePath_evaluation.evaluate,\n\n  // NodePath_conversion\n  toComputedKey: NodePath_conversion.toComputedKey,\n  ensureBlock: NodePath_conversion.ensureBlock,\n  unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,\n  arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,\n  splitExportDeclaration: NodePath_conversion.splitExportDeclaration,\n  ensureFunctionName: NodePath_conversion.ensureFunctionName,\n\n  // NodePath_introspection\n  matchesPattern: NodePath_introspection.matchesPattern,\n  isStatic: NodePath_introspection.isStatic,\n  isNodeType: NodePath_introspection.isNodeType,\n  canHaveVariableDeclarationOrExpression:\n    NodePath_introspection.canHaveVariableDeclarationOrExpression,\n  canSwapBetweenExpressionAndStatement:\n    NodePath_introspection.canSwapBetweenExpressionAndStatement,\n  isCompletionRecord: NodePath_introspection.isCompletionRecord,\n  isStatementOrBlock: NodePath_introspection.isStatementOrBlock,\n  referencesImport: NodePath_introspection.referencesImport,\n  getSource: NodePath_introspection.getSource,\n  willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,\n  _guessExecutionStatusRelativeTo:\n    NodePath_introspection._guessExecutionStatusRelativeTo,\n  resolve: NodePath_introspection.resolve,\n  isConstantExpression: NodePath_introspection.isConstantExpression,\n  isInStrictMode: NodePath_introspection.isInStrictMode,\n\n  // NodePath_context\n  isDenylisted: NodePath_context.isDenylisted,\n  visit: NodePath_context.visit,\n  skip: NodePath_context.skip,\n  skipKey: NodePath_context.skipKey,\n  stop: NodePath_context.stop,\n  setContext: NodePath_context.setContext,\n  requeue: NodePath_context.requeue,\n  requeueComputedKeyAndDecorators:\n    NodePath_context.requeueComputedKeyAndDecorators,\n\n  // NodePath_removal\n  remove: NodePath_removal.remove,\n\n  // NodePath_modification\n  insertBefore: NodePath_modification.insertBefore,\n  insertAfter: NodePath_modification.insertAfter,\n  unshiftContainer: NodePath_modification.unshiftContainer,\n  pushContainer: NodePath_modification.pushContainer,\n\n  // NodePath_family\n  getOpposite: NodePath_family.getOpposite,\n  getCompletionRecords: NodePath_family.getCompletionRecords,\n  getSibling: NodePath_family.getSibling,\n  getPrevSibling: NodePath_family.getPrevSibling,\n  getNextSibling: NodePath_family.getNextSibling,\n  getAllNextSiblings: NodePath_family.getAllNextSiblings,\n  getAllPrevSiblings: NodePath_family.getAllPrevSiblings,\n  get: NodePath_family.get,\n  getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,\n  getBindingIdentifiers: NodePath_family.getBindingIdentifiers,\n  getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,\n  getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,\n  getOuterBindingIdentifierPaths:\n    NodePath_family.getOuterBindingIdentifierPaths,\n\n  // NodePath_comments\n  shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,\n  addComment: NodePath_comments.addComment,\n  addComments: NodePath_comments.addComments,\n};\n\nObject.assign(NodePath_Final.prototype, methods);\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // String(x) is workaround for rollup\n\n  // @ts-expect-error babel 7 only\n  NodePath_Final.prototype.arrowFunctionToShadowed =\n    // @ts-expect-error babel 7 only\n    NodePath_conversion[String(\"arrowFunctionToShadowed\")];\n\n  Object.assign(NodePath_Final.prototype, {\n    // @ts-expect-error Babel 7 only\n    has: NodePath_introspection[String(\"has\")],\n    // @ts-expect-error Babel 7 only\n    is: NodePath_introspection[String(\"is\")],\n    // @ts-expect-error Babel 7 only\n    isnt: NodePath_introspection[String(\"isnt\")],\n    // @ts-expect-error Babel 7 only\n    equals: NodePath_introspection[String(\"equals\")],\n    // @ts-expect-error Babel 7 only\n    hoist: NodePath_modification[String(\"hoist\")],\n    updateSiblingKeys: NodePath_modification.updateSiblingKeys,\n    call: NodePath_context.call,\n    // @ts-expect-error Babel 7 only\n    isBlacklisted: NodePath_context[String(\"isBlacklisted\")],\n    setScope: NodePath_context.setScope,\n    resync: NodePath_context.resync,\n    popContext: NodePath_context.popContext,\n    pushContext: NodePath_context.pushContext,\n    setup: NodePath_context.setup,\n    setKey: NodePath_context.setKey,\n  });\n}\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-expect-error The original _guessExecutionStatusRelativeToDifferentFunctions only worked for paths in\n  // different functions, but _guessExecutionStatusRelativeTo works as a replacement in those cases.\n  NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions =\n    NodePath_introspection._guessExecutionStatusRelativeTo;\n\n  // @ts-expect-error The original _guessExecutionStatusRelativeToDifferentFunctions only worked for paths in\n  // different functions, but _guessExecutionStatusRelativeTo works as a replacement in those cases.\n  NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions =\n    NodePath_introspection._guessExecutionStatusRelativeTo;\n\n  Object.assign(NodePath_Final.prototype, {\n    // NodePath_inference\n    _getTypeAnnotation: NodePath_inference._getTypeAnnotation,\n\n    // NodePath_replacement\n    _replaceWith: NodePath_replacement._replaceWith,\n\n    // NodePath_introspection\n    _resolve: NodePath_introspection._resolve,\n\n    // NodePath_context\n    _call: NodePath_context._call,\n    _resyncParent: NodePath_context._resyncParent,\n    _resyncKey: NodePath_context._resyncKey,\n    _resyncList: NodePath_context._resyncList,\n    _resyncRemoved: NodePath_context._resyncRemoved,\n    _getQueueContexts: NodePath_context._getQueueContexts,\n\n    // NodePath_removal\n    _removeFromScope: NodePath_removal._removeFromScope,\n    _callRemovalHooks: NodePath_removal._callRemovalHooks,\n    _remove: NodePath_removal._remove,\n    _markRemoved: NodePath_removal._markRemoved,\n    _assertUnremoved: NodePath_removal._assertUnremoved,\n\n    // NodePath_modification\n    _containerInsert: NodePath_modification._containerInsert,\n    _containerInsertBefore: NodePath_modification._containerInsertBefore,\n    _containerInsertAfter: NodePath_modification._containerInsertAfter,\n    _verifyNodeList: NodePath_modification._verifyNodeList,\n\n    // NodePath_family\n    _getKey: NodePath_family._getKey,\n    _getPattern: NodePath_family._getPattern,\n  });\n}\n\n// we can not use `import { TYPES } from \"@babel/types\"` here\n// because the transformNamedBabelTypesImportToDestructuring plugin in babel.config.js\n// does not offer live bindings for `TYPES`\n// we can change to `import { TYPES }` when we are publishing ES modules only\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  // @ts-expect-error typeKey must present in t\n  const fn = t[typeKey];\n  // @ts-expect-error augmenting NodePath prototype\n  NodePath_Final.prototype[typeKey] = function (opts: any) {\n    return fn(this.node, opts);\n  };\n\n  // @ts-expect-error augmenting NodePath prototype\n  NodePath_Final.prototype[`assert${type}`] = function (opts: any) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\n// Register virtual types validators after base types validators\nObject.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);\n\nfor (const type of Object.keys(virtualTypes) as (keyof typeof virtualTypes)[]) {\n  if (type[0] === \"_\") continue;\n  if (!t.TYPES.includes(type)) t.TYPES.push(type);\n}\n\ninterface NodePathOverwrites {\n  // We need to re-define these predicate and assertion\n  // methods here, because we cannot refine `this` in\n  // a function declaration.\n  // See https://github.com/microsoft/TypeScript/issues/38150\n\n  /**\n   * NOTE: This assertion doesn't narrow the type on unions of\n   * NodePaths, due to https://github.com/microsoft/TypeScript/issues/44212\n   *\n   * @see ./conversion.ts for implementation.\n   */\n  ensureBlock(\n    this: NodePath_Final,\n  ): asserts this is NodePath_Final<\n    (\n      | t.Loop\n      | t.WithStatement\n      | t.Function\n      | t.LabeledStatement\n      | t.CatchClause\n    ) & { body: t.BlockStatement }\n  >;\n  /**\n   * @see ./introspection.ts for implementation.\n   */\n  isStatementOrBlock(\n    this: NodePath_Final,\n  ): this is NodePath_Final<t.Statement | t.Block>;\n}\n\ntype NodePathMixins = Omit<typeof methods, keyof NodePathOverwrites>;\n\ninterface NodePath<T extends t.Node>\n  extends InstanceType<typeof NodePath_Final>,\n    NodePathAssertions,\n    NodePathValidators,\n    NodePathMixins,\n    NodePathOverwrites {\n  type: T[\"type\"] | null;\n  node: T;\n  parent: t.ParentMaps[T[\"type\"]];\n  parentPath: t.ParentMaps[T[\"type\"]] extends null\n    ? null\n    : NodePath_Final<t.ParentMaps[T[\"type\"]]> | null;\n}\n\n// This trick is necessary so that\n// NodePath_Final<A | B> is the same as NodePath_Final<A> | NodePath_Final<B>\ntype NodePath_Final<T extends t.Node = t.Node> = T extends any\n  ? NodePath<T>\n  : never;\n\nexport { NodePath_Final as default, type NodePath as NodePath_Internal };\n", "import NodePath from \"./path/index.ts\";\nimport { VISITOR_KEYS } from \"@babel/types\";\nimport type Scope from \"./scope/index.ts\";\nimport type { ExplodedTraverseOptions } from \"./index.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Visitor } from \"./types.ts\";\nimport { popContext, pushContext, resync } from \"./path/context.ts\";\n\nexport default class TraversalContext<S = unknown> {\n  constructor(\n    scope: Scope,\n    opts: ExplodedTraverseOptions<S>,\n    state: S,\n    parentPath: NodePath,\n  ) {\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  declare parentPath: NodePath;\n  declare scope: Scope;\n  declare state: S;\n  declare opts: ExplodedTraverseOptions<S>;\n  queue: Array<NodePath> | null = null;\n  priorityQueue: Array<NodePath> | null = null;\n\n  /**\n   * This method does a simple check to determine whether or not we really need to attempt\n   * visit a node. This will prevent us from constructing a NodePath.\n   */\n\n  shouldVisit(node: t.Node): boolean {\n    const opts = this.opts as Visitor;\n    if (opts.enter || opts.exit) return true;\n\n    // check if we have a visitor for this node\n    if (opts[node.type]) return true;\n\n    // check if we're going to traverse into this node\n    const keys: Array<string> | undefined = VISITOR_KEYS[node.type];\n    if (!keys?.length) return false;\n\n    // we need to traverse into this node so ensure that it has children to traverse into!\n    for (const key of keys) {\n      if (\n        // @ts-expect-error key is from visitor keys\n        node[key]\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  create(\n    node: t.Node,\n    container: t.Node | t.Node[],\n    key: string | number,\n    listKey?: string,\n  ): NodePath {\n    // We don't need to `.setContext()` here, since `.visitQueue()` already\n    // calls `.pushContext`.\n    return NodePath.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container,\n      key: key,\n      listKey,\n    });\n  }\n\n  maybeQueue(path: NodePath, notPriority?: boolean) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container: t.Node[], parent: t.Node, listKey: string) {\n    // nothing to traverse!\n    if (container.length === 0) return false;\n\n    const queue = [];\n\n    // build up initial queue\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node: t.Node, key: string): boolean {\n    if (\n      this.shouldVisit(\n        // @ts-expect-error key may not index node\n        node[key],\n      )\n    ) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue: Array<NodePath>): boolean {\n    // set queue\n    this.queue = queue;\n    this.priorityQueue = [];\n\n    const visited = new WeakSet();\n    let stop = false;\n    let visitIndex = 0;\n\n    // visit the queue\n    for (; visitIndex < queue.length; ) {\n      const path = queue[visitIndex];\n      visitIndex++;\n      resync.call(path);\n\n      if (\n        path.contexts.length === 0 ||\n        path.contexts[path.contexts.length - 1] !== this\n      ) {\n        // The context might already have been pushed when this path was inserted and queued.\n        // If we always re-pushed here, we could get duplicates and risk leaving contexts\n        // on the stack after the traversal has completed, which could break things.\n        pushContext.call(path, this);\n      }\n\n      // this path no longer belongs to the tree\n      if (path.key === null) continue;\n\n      // ensure we don't visit the same node twice\n      const { node } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    // pop contexts\n    for (let i = 0; i < visitIndex; i++) {\n      popContext.call(queue[i]);\n    }\n\n    // clear queue\n    this.queue = null;\n\n    return stop;\n  }\n\n  visit(node: t.Node, key: string) {\n    // @ts-expect-error key may not index node\n    const nodes = node[key] as t.Node | t.Node[] | null;\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n}\n", "import TraversalContext from \"./context.ts\";\nimport type { ExplodedTraverseOptions } from \"./index.ts\";\nimport type NodePath from \"./path/index.ts\";\nimport type Scope from \"./scope/index.ts\";\nimport type * as t from \"@babel/types\";\nimport { VISITOR_KEYS } from \"@babel/types\";\n\n/**\n * Traverse the children of given node\n * @param {Node} node\n * @param {TraverseOptions} opts The traverse options used to create a new traversal context\n * @param {scope} scope A traversal scope used to create a new traversal context. When opts.noScope is true, scope should not be provided\n * @param {any} state A user data storage provided as the second callback argument for traversal visitors\n * @param {NodePath} path A NodePath of given node\n * @param {Record<string, boolean>} skipKeys A map from key names to whether that should be skipped during traversal. The skipKeys are applied to every descendants\n * @returns {boolean} Whether the traversal stops early\n\n * @note This function does not visit the given `node`.\n */\nexport function traverseNode<S = unknown>(\n  node: t.Node,\n  opts: ExplodedTraverseOptions<S>,\n  scope?: Scope,\n  state?: S,\n  path?: NodePath,\n  skipKeys?: Record<string, boolean>,\n  visitSelf?: boolean,\n): boolean {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return false;\n\n  const context = new TraversalContext<S>(scope, opts, state, path);\n  if (visitSelf) {\n    if (skipKeys?.[path.parentKey]) return false;\n    return context.visitQueue([path]);\n  }\n\n  for (const key of keys) {\n    if (skipKeys?.[key]) continue;\n    if (context.visit(node, key)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n", "// This file contains methods responsible for maintaining a TraversalContext.\n\nimport { traverseNode } from \"../traverse-node.ts\";\nimport { SHOULD_SKIP, SHOULD_STOP } from \"./index.ts\";\nimport { _markRemoved } from \"./removal.ts\";\nimport type TraversalContext from \"../context.ts\";\nimport type { VisitPhase } from \"../types.ts\";\nimport type NodePath from \"./index.ts\";\nimport * as t from \"@babel/types\";\n\nexport function call(this: NodePath, key: VisitPhase): boolean {\n  const opts = this.opts;\n\n  this.debug(key);\n\n  if (this.node) {\n    if (_call.call(this, opts[key])) return true;\n  }\n\n  if (this.node) {\n    return _call.call(this, opts[this.node.type]?.[key]);\n  }\n\n  return false;\n}\n\nexport function _call(this: NodePath, fns?: Array<Function>): boolean {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n\n    const node = this.node;\n    if (!node) return true;\n\n    const ret = fn.call(this.state, this, this.state);\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(\n        `You appear to be using a plugin with an async traversal visitor, ` +\n          `which your current version of Babel does not support. ` +\n          `If you're using a published plugin, you may need to upgrade ` +\n          `your @babel/core version.`,\n      );\n    }\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    // node has been replaced, it will have been requeued\n    if (this.node !== node) return true;\n\n    // this.shouldSkip || this.shouldStop || this.removed\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nexport function isDenylisted(this: NodePath): boolean {\n  // @ts-expect-error TODO(Babel 8): Remove blacklist\n  const denylist = this.opts.denylist ?? this.opts.blacklist;\n  return denylist?.includes(this.node.type);\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.isBlacklisted = isDenylisted;\n}\n\nfunction restoreContext(path: NodePath, context: TraversalContext) {\n  if (path.context !== context) {\n    path.context = context;\n    path.state = context.state;\n    path.opts = context.opts;\n  }\n}\n\nexport function visit(this: NodePath): boolean {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip?.(this)) {\n    return false;\n  }\n\n  const currentContext = this.context;\n  // Note: We need to check \"this.shouldSkip\" first because\n  // another visitor can set it to true. Usually .shouldSkip is false\n  // before calling the enter visitor, but it can be true in case of\n  // a requeued node (e.g. by .replaceWith()) that is then marked\n  // with .skip().\n  if (this.shouldSkip || call.call(this, \"enter\")) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n  restoreContext(this, currentContext);\n\n  this.debug(\"Recursing into...\");\n  this.shouldStop = traverseNode(\n    this.node,\n    this.opts,\n    this.scope,\n    this.state,\n    this,\n    this.skipKeys,\n  );\n\n  restoreContext(this, currentContext);\n\n  call.call(this, \"exit\");\n\n  return this.shouldStop;\n}\n\nexport function skip(this: NodePath) {\n  this.shouldSkip = true;\n}\n\nexport function skipKey(this: NodePath, key: string) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n  this.skipKeys[key] = true;\n}\n\nexport function stop(this: NodePath) {\n  // this.shouldSkip = true; this.shouldStop = true;\n  this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;\n}\n\nexport function setScope(this: NodePath) {\n  if (this.opts?.noScope) return;\n\n  let path = this.parentPath;\n\n  if (\n    // Skip method scope if is computed method key or decorator expression\n    ((this.key === \"key\" || this.listKey === \"decorators\") &&\n      path.isMethod()) ||\n    // Skip switch scope if for discriminant (`x` in `switch (x) {}`).\n    (this.key === \"discriminant\" && path.isSwitchStatement())\n  ) {\n    path = path.parentPath;\n  }\n\n  let target;\n  while (path && !target) {\n    if (path.opts?.noScope) return;\n\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  this.scope?.init();\n}\n\nexport function setContext<S = unknown>(\n  this: NodePath,\n  context?: TraversalContext<S>,\n) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n  // this.shouldSkip = false; this.shouldStop = false; this.removed = false;\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    // Discard the S type parameter from context.opts\n    this.opts = context.opts as typeof this.opts;\n  }\n\n  setScope.call(this);\n\n  return this;\n}\n\n/**\n * Here we resync the node paths `key` and `container`. If they've changed according\n * to what we have stored internally then we attempt to resync by crawling and looking\n * for the new values.\n */\n\nexport function resync(this: NodePath) {\n  if (this.removed) return;\n\n  _resyncParent.call(this);\n  _resyncList.call(this);\n  _resyncKey.call(this);\n  //this._resyncRemoved();\n}\n\nexport function _resyncParent(this: NodePath) {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nexport function _resyncKey(this: NodePath) {\n  if (!this.container) return;\n\n  if (\n    this.node ===\n    // @ts-expect-error this.key should present in this.container\n    this.container[this.key]\n  ) {\n    return;\n  }\n\n  // grrr, path key is out of sync. this is likely due to a modification to the AST\n  // not done through our path APIs\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        setKey.call(this, i);\n        return;\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      // @ts-expect-error this.key should present in this.container\n      if (this.container[key] === this.node) {\n        setKey.call(this, key);\n        return;\n      }\n    }\n  }\n\n  // \\_()_/ who knows where it's gone lol\n  this.key = null;\n}\n\nexport function _resyncList(this: NodePath) {\n  if (!this.parent || !this.inList) return;\n\n  const newContainer =\n    // @ts-expect-error this.listKey should present in this.parent\n    this.parent[this.listKey];\n  if (this.container === newContainer) return;\n\n  // container is out of sync. this is likely the result of it being reassigned\n  this.container = newContainer || null;\n}\n\nexport function _resyncRemoved(this: NodePath) {\n  if (\n    this.key == null ||\n    !this.container ||\n    // @ts-expect-error this.key should present in this.container\n    this.container[this.key] !== this.node\n  ) {\n    _markRemoved.call(this);\n  }\n}\n\nexport function popContext(this: NodePath) {\n  this.contexts.pop();\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nexport function pushContext(this: NodePath, context: TraversalContext) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nexport function setup(\n  this: NodePath,\n  parentPath: NodePath | undefined,\n  container: t.Node | t.Node[],\n  listKey: string,\n  key: string | number,\n) {\n  this.listKey = listKey;\n  this.container = container;\n\n  this.parentPath = parentPath || this.parentPath;\n  setKey.call(this, key);\n}\n\nexport function setKey(this: NodePath, key: string | number) {\n  this.key = key;\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key];\n  this.type = this.node?.type;\n}\n\nexport function requeue(this: NodePath, pathToQueue = this) {\n  if (pathToQueue.removed) return;\n\n  // If a path is skipped, and then replaced with a\n  // new one, the new one shouldn't probably be skipped.\n  if (process.env.BABEL_8_BREAKING) {\n    pathToQueue.shouldSkip = false;\n  }\n\n  // TODO(loganfsmyth): This should be switched back to queue in parent contexts\n  // automatically once #2892 and #4135 have been resolved. See #4140.\n  // let contexts = this._getQueueContexts();\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nexport function requeueComputedKeyAndDecorators(\n  this: NodePath<t.Method | t.Property>,\n) {\n  const { context, node } = this;\n  if (!t.isPrivate(node) && node.computed) {\n    context.maybeQueue(this.get(\"key\"));\n  }\n  if (node.decorators) {\n    for (const decorator of this.get(\"decorators\")) {\n      context.maybeQueue(decorator);\n    }\n  }\n}\n\nexport function _getQueueContexts(this: NodePath) {\n  let path = this;\n  let contexts = this.contexts;\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n  return contexts;\n}\n", "import type Scope from \"./scope/index.ts\";\nimport type { Node } from \"@babel/types\";\n\nexport interface HubInterface {\n  getCode(): string | void;\n  getScope(): Scope | void;\n  addHelper(name: string): any;\n  buildError(node: Node, msg: string, Error: new () => Error): Error;\n}\n\nexport default class Hub implements HubInterface {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node: Node, msg: string, Error = TypeError): Error {\n    return new Error(msg);\n  }\n}\n", "import \"./path/context.ts\"; // We have some cycles, this ensures correct order to avoid TDZ\nimport * as visitors from \"./visitors.ts\";\nimport {\n  VISITOR_KEYS,\n  removeProperties,\n  type RemovePropertiesOptions,\n  traverseFast,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as cache from \"./cache.ts\";\nimport type NodePath from \"./path/index.ts\";\nimport type { default as Scope, Binding } from \"./scope/index.ts\";\nimport type { ExplodedVisitor, Visitor, VisitorBase } from \"./types.ts\";\nimport { traverseNode } from \"./traverse-node.ts\";\n\nexport type { ExplodedVisitor, Visitor, VisitorBase, Binding };\nexport { default as NodePath } from \"./path/index.ts\";\nexport { default as Scope } from \"./scope/index.ts\";\nexport { default as Hub } from \"./hub.ts\";\nexport type { HubInterface } from \"./hub.ts\";\n\nexport { visitors };\n\nexport type TraverseOptions<S = t.Node> = {\n  scope?: Scope;\n  noScope?: boolean;\n  denylist?: string[];\n  shouldSkip?: (node: NodePath) => boolean;\n} & Visitor<S>;\n\nexport type ExplodedTraverseOptions<S = t.Node> = TraverseOptions<S> &\n  ExplodedVisitor<S>;\n\nfunction traverse<S>(\n  parent: t.Node,\n  opts: TraverseOptions<S>,\n  scope: Scope | undefined,\n  state: S,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n): void;\n\nfunction traverse(\n  parent: t.Node,\n  opts: TraverseOptions,\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n): void;\n\nfunction traverse<Options extends TraverseOptions>(\n  parent: t.Node,\n  // @ts-expect-error provide {} as default value for Options\n  opts: Options = {},\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\n        \"You must pass a scope and parentPath unless traversing a Program/File. \" +\n          `Instead of that you tried to traverse a ${parent.type} node without ` +\n          \"passing scope and parentPath.\",\n      );\n    }\n  }\n\n  if (!parentPath && visitSelf) {\n    throw new Error(\"visitSelf can only be used when providing a NodePath.\");\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts as Visitor);\n\n  traverseNode(\n    parent,\n    opts as ExplodedVisitor,\n    scope,\n    state,\n    parentPath,\n    /* skipKeys */ null,\n    visitSelf,\n  );\n}\n\nexport default traverse;\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node: t.Node, enter: (node: t.Node) => void) {\n  traverseFast(node, enter);\n  return;\n};\n\ntraverse.node = function (\n  node: t.Node,\n  opts: ExplodedTraverseOptions,\n  scope?: Scope,\n  state?: any,\n  path?: NodePath,\n  skipKeys?: Record<string, boolean>,\n) {\n  traverseNode(node, opts, scope, state, path, skipKeys);\n  // traverse.node always returns undefined\n};\n\ntraverse.clearNode = function (node: t.Node, opts?: RemovePropertiesOptions) {\n  removeProperties(node, opts);\n};\n\ntraverse.removeProperties = function (\n  tree: t.Node,\n  opts?: RemovePropertiesOptions,\n) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\ntype HasDenylistedTypeState = {\n  has: boolean;\n  type: t.Node[\"type\"];\n};\nfunction hasDenylistedType(path: NodePath, state: HasDenylistedTypeState) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (\n  tree: t.Node,\n  type: t.Node[\"type\"],\n  denylistTypes?: Array<string>,\n): boolean {\n  // the node we're searching in is denylisted\n  if (denylistTypes?.includes(tree.type)) return false;\n\n  // the type we're looking for is the same as the passed node\n  if (tree.type === type) return true;\n\n  const state: HasDenylistedTypeState = {\n    has: false,\n    type: type,\n  };\n\n  traverse(\n    tree,\n    {\n      noScope: true,\n      denylist: denylistTypes,\n      enter: hasDenylistedType,\n    },\n    null,\n    state,\n  );\n\n  return state.has;\n};\n\ntraverse.cache = cache;\n"],
  "mappings": "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",
  "names": ["ReferencedIdentifier", "exports", "ReferencedMemberExpression", "BindingIdentifier", "Statement", "Expression", "Scope", "Referenced", "BlockScoped", "Var", "User", "Generated", "Pure", "Flow", "RestProperty", "SpreadProperty", "ExistentialTypeParam", "NumericLiteralTypeAnnotation", "ForAwaitStatement", "_t", "require", "isBinding", "isBlockScoped", "nodeIsBlockScoped", "isExportDeclaration", "isExpression", "nodeIsExpression", "isFlow", "nodeIsFlow", "isForStatement", "isForXStatement", "isIdentifier", "isImportDeclaration", "isImportSpecifier", "isJSXIdentifier", "isJSXMemberExpression", "isMemberExpression", "isRestElement", "nodeIsRestElement", "isReferenced", "nodeIsReferenced", "isScope", "nodeIsScope", "isStatement", "nodeIsStatement", "isVar", "nodeIsVar", "isVariableDeclaration", "react", "isForOfStatement", "isCompatTag", "isReferencedIdentifier", "opts", "node", "parent", "name", "parentPath", "isReferencedMemberExpression", "isBindingIdentifier", "grandparent", "left", "init", "isUser", "loc", "isGenerated", "isPure", "constantsOnly", "scope", "importKind", "exportKind", "isRestProperty", "_this$parentPath", "isObjectPattern", "isSpreadProperty", "_this$parentPath2", "isObjectExpression", "isForAwaitStatement", "await", "exports", "isExistentialTypeParam", "Error", "isNumericLiteralTypeAnnotation", "virtualTypes", "require", "virtualTypesValidators", "_t", "_context", "DEPRECATED_KEYS", "DEPRECATED_ALIASES", "FLIPPED_ALIAS_KEYS", "TYPES", "__internal__deprecationWarning", "deprecationWarning", "isVirtualType", "type", "isExplodedVisitor", "visitor", "_exploded", "explode$1", "nodeType", "Object", "keys", "shouldIgnoreKey", "parts", "split", "length", "fns", "part", "verify$1", "__esModule", "ensureEntranceObjects", "ensureCallbackArrays", "wrapCheck", "types", "mergePair", "aliases", "deprecatedKey", "deprecatedAlias", "alias", "existing", "assign", "_verified", "Error", "validateVisitorMethods", "includes", "visitors", "visitorKey", "path", "val", "concat", "fn", "TypeError", "merge", "states", "wrapper", "mergedVisitor", "defineProperty", "enumerable", "i", "state", "topVisitor", "wrapWithStateOrWrapper", "key", "typeVisitor", "nodeVisitor", "oldVisitor", "newVisitor", "phase", "Array", "isArray", "map", "newFn", "call", "toString", "obj", "enter", "exit", "fnKey", "validator", "apply", "arguments", "dest", "src", "_environmentVisitor", "FunctionParent", "isArrowFunctionExpression", "skip", "isMethod", "requeueComputedKeyAndDecorators", "Property", "isObjectProperty", "environmentVisitor", "t", "require", "_t", "_traverseNode", "_visitors", "_context", "getAssignmentIdentifiers", "renameVisitor", "ReferencedIdentifier", "node", "state", "name", "oldName", "newName", "Scope", "path", "scope", "bindingIdentifierEquals", "binding", "identifier", "skip", "isMethod", "requeueComputedKeyAndDecorators", "call", "ObjectProperty", "key", "shorthand", "getBindingIdentifier", "_node$extra", "extra", "isVariableDeclaration", "ids", "isAssignmentExpression", "getOuterBindingIdentifiers", "Renamer", "constructor", "maybeConvertFromExportDeclaration", "parentDeclar", "maybeExportDeclar", "parentPath", "isExportDeclaration", "isExportDefaultDeclaration", "declaration", "isDeclaration", "id", "isExportAllDeclaration", "splitExportDeclaration", "maybeConvertFromClassFunctionDeclaration", "maybeConvertFromClassFunctionExpression", "rename", "find", "isFunctionExpression", "isClassExpression", "bindingIds", "blockToTraverse", "arguments", "block", "skipKeys", "discriminant", "computed", "isObjectMethod", "decorators", "traverseNode", "explode", "removeOwnBinding", "bindings", "exports", "default", "Binding", "constructor", "identifier", "scope", "path", "kind", "constantViolations", "constant", "referencePaths", "referenced", "references", "isDeclaredInLoop", "reassign", "clearValue", "deoptValue", "hasDeoptedValue", "setValue", "value", "hasValue", "includes", "push", "reference", "dereference", "exports", "default", "parentPath", "key", "isFunctionParent", "isWhile", "isForXStatement", "isForStatement", "require_globals", "pathsCache", "exports", "path", "WeakMap", "scope", "clear", "clearPath", "clearScope", "nullHub", "Object", "freeze", "getCachedPaths", "hub", "parent", "_pathsCache$get", "_hub", "get", "getOrCreateCachedPaths", "_hub2", "_hub3", "parents", "set", "paths", "Map", "_renamer", "require", "_index", "_binding", "_globals", "_t", "t", "_cache", "_visitors", "NOT_LOCAL_BINDING", "assignmentExpression", "callExpression", "cloneNode", "getBindingIdentifiers", "identifier", "isArrayExpression", "isBinary", "isCallExpression", "isClass", "isClassBody", "isClassDeclaration", "isExportAllDeclaration", "isExportDefaultDeclaration", "isExportNamedDeclaration", "isFunctionDeclaration", "isIdentifier", "isImportDeclaration", "isLiteral", "isMemberExpression", "isMethod", "isModuleSpecifier", "isNullLiteral", "isObjectExpression", "isProperty", "isPureish", "isRegExpLiteral", "isSuper", "isTaggedTemplateExpression", "isTemplateLiteral", "isThisExpression", "isUnaryExpression", "isVariableDeclaration", "expressionStatement", "matchesPattern", "memberExpression", "numericLiteral", "toIdentifier", "variableDeclaration", "variableDeclarator", "isRecordExpression", "isTupleExpression", "isObjectProperty", "isTopicReference", "isMetaProperty", "isPrivateName", "isExportDeclaration", "buildUndefinedNode", "sequenceExpression", "gatherNodeParts", "node", "parts", "type", "_node$specifiers", "source", "specifiers", "length", "e", "declaration", "local", "push", "value", "object", "property", "name", "callee", "properties", "argument", "key", "left", "id", "expression", "meta", "openingElement", "openingFragment", "namespace", "collectorVisitor", "ForStatement", "path", "declar", "get", "isVar", "scope", "parentScope", "getFunctionParent", "getProgramParent", "registerBinding", "Declaration", "isBlockScoped", "parent", "registerDeclaration", "ImportDeclaration", "getBlockParent", "TSImportEqualsDeclaration", "ReferencedIdentifier", "state", "isTSQualifiedName", "right", "parentPath", "isTSImportEqualsDeclaration", "references", "ForXStatement", "isPattern", "constantViolations", "ExportDeclaration", "exit", "binding", "getBinding", "reference", "decl", "declarations", "Object", "keys", "LabeledStatement", "AssignmentExpression", "assignments", "UpdateExpression", "UnaryExpression", "operator", "BlockScoped", "bindings", "CatchClause", "Function", "params", "param", "isFunctionExpression", "ClassExpression", "TSTypeAnnotation", "skip", "uid", "Scope", "constructor", "block", "inited", "labels", "globals", "uids", "data", "crawling", "cached", "scopeCache", "set", "Map", "_parent", "_path", "shouldSkip", "listKey", "isScope", "generateDeclaredUidIdentifier", "generateUidIdentifier", "generateUid", "replace", "i", "hasLabel", "hasBinding", "hasGlobal", "hasReference", "program", "generateUidBasedOnNode", "defaultName", "join", "slice", "generateUidIdentifierBasedOnNode", "isStatic", "constant", "maybeGenerateMemoised", "dontPush", "checkBlockScopedCollisions", "kind", "duplicate", "hub", "buildError", "TypeError", "rename", "oldName", "newName", "renamer", "Renamer", "arguments", "dump", "sep", "repeat", "console", "log", "violations", "getLabel", "registerLabel", "label", "isLabeledStatement", "declare", "isTypeDeclaration", "importKind", "specifier", "isTypeSpecifier", "isImportSpecifier", "registerConstantViolation", "ids", "getAssignmentIdentifiers", "_this$getBinding", "reassign", "bindingPath", "ReferenceError", "declarators", "getOuterBindingIdentifiers", "getOwnBinding", "Binding", "addGlobal", "hasUid", "isPure", "constantsOnly", "_node$decorators", "superClass", "decorators", "body", "method", "elem", "elements", "prop", "_node$decorators2", "computed", "_node$decorators3", "static", "expressions", "tag", "noGlobals", "quasi", "isStringLiteral", "setData", "val", "getData", "removeData", "init", "crawl", "create", "isProgram", "programParent", "isExplodedVisitor", "visit", "enter", "call", "typeVisitors", "traverse", "ref", "opts", "getPatternParent", "isBlockStatement", "isSwitchStatement", "unique", "isFunction", "pushContainer", "isLoop", "isCatchClause", "ensureBlock", "blockHoist", "_blockHoist", "dataKey", "declarPath", "unshiftContainer", "declarator", "len", "Error", "isFunctionParent", "isBlockParent", "getAllBindings", "bindingIdentifierEquals", "getBindingIdentifier", "previousPath", "_previousPath", "isArrowFunctionExpression", "_this$getBinding2", "getOwnBindingIdentifier", "hasOwnBinding", "noUids", "includes", "contextVariables", "parentHasBinding", "_this$parent", "moveBindingTo", "info", "removeOwnBinding", "removeBinding", "_this$getBinding3", "hoistVariables", "emit", "seen", "Set", "isVariableDeclarator", "has", "add", "firstId", "_firstId", "isFor", "replaceWith", "remove", "expr", "isForStatement", "exports", "default", "builtin", "prototype", "_renameFromMap", "map", "_generateUid", "toArray", "arrayLikeIsIterable", "isGenericType", "helperName", "args", "unshift", "addHelper", "getAllBindingsOfKind", "kinds", "defineProperties", "parentBlock", "configurable", "enumerable", "_t", "require", "VISITOR_KEYS", "findParent", "callback", "path", "parentPath", "find", "getFunctionParent", "p", "isFunction", "getStatementParent", "Array", "isArray", "container", "isStatement", "isProgram", "isFile", "Error", "getEarliestCommonAncestorFrom", "paths", "getDeepestCommonAncestorFrom", "deepest", "i", "ancestries", "earliest", "keys", "type", "ancestry", "listKey", "key", "earliestKeyIndex", "indexOf", "parentKey", "currentKeyIndex", "filter", "length", "minDepth", "Infinity", "lastCommonIndex", "lastCommon", "map", "unshift", "first", "depthLoop", "shouldMatch", "getAncestry", "push", "isAncestor", "maybeDescendant", "isDescendant", "maybeAncestor", "parent", "inType", "candidateTypes", "node", "_t", "require", "createFlowUnionType", "createTSUnionType", "createUnionTypeAnnotation", "isFlowType", "isTSType", "createUnionType", "types", "every", "v", "_t", "require", "_util", "BOOLEAN_NUMBER_BINARY_OPERATORS", "createTypeAnnotationBasedOnTypeof", "numberTypeAnnotation", "voidTypeAnnotation", "_default", "node", "isReferenced", "binding", "scope", "getBinding", "name", "identifier", "typeAnnotation", "getTypeAnnotationBindingConstantViolations", "path", "types", "functionConstantViolations", "constantViolations", "getConstantViolationsBefore", "testType", "getConditionalAnnotation", "testConstantViolations", "ifStatement", "filter", "includes", "push", "length", "violation", "getTypeAnnotation", "createUnionType", "functions", "violations", "slice", "unshift", "resolve", "status", "_guessExecutionStatusRelativeTo", "inferAnnotationFromBinaryExpression", "operator", "right", "get", "left", "target", "isIdentifier", "typeofPath", "typePath", "isUnaryExpression", "isLiteral", "typeValue", "value", "getParentConditionalPath", "parentPath", "isIfStatement", "isConditionalExpression", "key", "isFunction", "test", "paths", "i", "isLogicalExpression", "isBinaryExpression", "type", "_t", "require", "_infererReference", "_util", "BOOLEAN_BINARY_OPERATORS", "BOOLEAN_UNARY_OPERATORS", "NUMBER_BINARY_OPERATORS", "NUMBER_UNARY_OPERATORS", "STRING_UNARY_OPERATORS", "anyTypeAnnotation", "arrayTypeAnnotation", "booleanTypeAnnotation", "buildMatchMemberExpression", "genericTypeAnnotation", "identifier", "nullLiteralTypeAnnotation", "numberTypeAnnotation", "stringTypeAnnotation", "tupleTypeAnnotation", "unionTypeAnnotation", "voidTypeAnnotation", "isIdentifier", "VariableDeclarator", "get", "getTypeAnnotation", "TypeCastExpression", "node", "typeAnnotation", "validParent", "TSAsExpression", "TSNonNullExpression", "NewExpression", "callee", "type", "TemplateLiteral", "UnaryExpression", "operator", "includes", "BinaryExpression", "right", "left", "isBaseType", "LogicalExpression", "argumentTypes", "createUnionType", "ConditionalExpression", "SequenceExpression", "pop", "ParenthesizedExpression", "AssignmentExpression", "UpdateExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "RegExpLiteral", "ObjectExpression", "ArrayExpression", "RestElement", "Func", "isArrayFrom", "isObjectKeys", "isObjectValues", "isObjectEntries", "CallExpression", "name", "resolveCall", "TaggedTemplateExpression", "resolve", "isFunction", "async", "generator", "returnType", "inferers", "require", "_t", "anyTypeAnnotation", "isAnyTypeAnnotation", "isArrayTypeAnnotation", "isBooleanTypeAnnotation", "isEmptyTypeAnnotation", "isFlowBaseAnnotation", "isGenericTypeAnnotation", "isIdentifier", "isMixedTypeAnnotation", "isNumberTypeAnnotation", "isStringTypeAnnotation", "isTSArrayType", "isTSTypeAnnotation", "isTSTypeReference", "isTupleTypeAnnotation", "isTypeAnnotation", "isUnionTypeAnnotation", "isVoidTypeAnnotation", "stringTypeAnnotation", "voidTypeAnnotation", "getTypeAnnotation", "type", "getData", "_getTypeAnnotation", "call", "typeAnnotation", "setData", "typeAnnotationInferringNodes", "WeakSet", "node", "key", "parentPath", "isVariableDeclarator", "declar", "declarParent", "isForInStatement", "isForOfStatement", "has", "add", "_inferer", "inferer", "validParent", "delete", "isBaseType", "baseName", "soft", "_isBaseType", "Error", "couldBeBaseType", "name", "type2", "types", "baseTypeStrictlyMatches", "rightArg", "left", "right", "isGenericType", "genericName", "id", "typeName", "isColorSupported", "process", "env", "FORCE_COLOR", "picocolors", "compose", "f", "g", "v", "buildDefs", "colors", "keyword", "cyan", "capitalized", "yellow", "jsxIdentifier", "punctuator", "number", "magenta", "string", "green", "regex", "comment", "gray", "invalid", "white", "bgRed", "bold", "gutter", "marker", "red", "message", "reset", "defsOn", "createColors", "defsOff", "getDefs", "enabled", "sometimesKeywords", "Set", "NEWLINE", "BRACKET", "tokenize", "JSX_TAG", "getTokenType", "token", "offset", "text", "type", "isKeyword", "value", "isStrictReservedWord", "has", "test", "slice", "toLowerCase", "match", "jsTokens", "default", "exec", "matchToToken", "index", "highlight", "defs", "highlighted", "split", "map", "str", "join", "deprecationWarningShown", "getMarkerLines", "loc", "source", "opts", "startLoc", "Object", "assign", "column", "line", "start", "endLoc", "end", "linesAbove", "linesBelow", "startLine", "startColumn", "endLine", "endColumn", "Math", "max", "min", "length", "lineDiff", "markerLines", "i", "lineNumber", "sourceLength", "codeFrameColumns", "rawLines", "shouldHighlight", "forceColor", "highlightCode", "lines", "hasColumns", "numberMaxWidth", "String", "highlightedLines", "frame", "paddedNumber", "hasMarker", "lastMarkerLine", "markerLine", "Array", "isArray", "markerSpacing", "replace", "numberOfMarkers", "repeat", "colNumber", "emitWarning", "deprecationError", "Error", "name", "console", "warn", "location", "_t", "require", "_t2", "react", "cloneNode", "jsxExpressionContainer", "variableDeclaration", "variableDeclarator", "referenceVisitor", "ReferencedIdentifier", "path", "state", "isJSXIdentifier", "isCompatTag", "node", "name", "parentPath", "isJSXMemberExpression", "scope", "isFunction", "isArrowFunctionExpression", "parent", "breakOnScopePaths", "push", "binding", "getBinding", "violation", "constantViolations", "mutableBinding", "stop", "bindings", "PathHoister", "constructor", "scopes", "attachAfter", "isCompatibleScope", "key", "Object", "keys", "bindingIdentifierEquals", "identifier", "getCompatibleScopes", "includes", "getAttachmentPath", "_getAttachmentPath", "targetScope", "isProgram", "hasOwnBinding", "kind", "parentKey", "bindingParentPath", "getAttachmentParentForPath", "violationPath", "pop", "hasOwnParamBindings", "bodies", "get", "i", "length", "_blockHoist", "getNextScopeAttachmentParent", "Array", "isArray", "container", "isStatement", "constant", "run", "traverse", "attachTo", "getFunctionParent", "uid", "generateUidIdentifier", "declarator", "insertFn", "attached", "isVariableDeclarator", "isJSXElement", "children", "replaceWith", "exports", "default", "hooks", "exports", "self", "parent", "removeParent", "key", "isWhile", "isSwitchCase", "isExportDeclaration", "isLabeledStatement", "listKey", "isVariableDeclaration", "node", "declarations", "length", "isExpressionStatement", "remove", "isSequenceExpression", "expressions", "replaceWith", "isBinary", "right", "left", "isIfStatement", "isLoop", "isArrowFunctionExpression", "type", "body", "_removalHooks", "require", "_cache", "_replacement", "_index", "_t", "_modification", "_context", "getBindingIdentifiers", "remove", "_this$opts", "_assertUnremoved", "call", "resync", "_callRemovalHooks", "_markRemoved", "opts", "noScope", "_removeFromScope", "shareCommentsWithSiblings", "_remove", "bindings", "node", "Object", "keys", "forEach", "name", "scope", "removeBinding", "parentPath", "fn", "hooks", "Array", "isArray", "container", "splice", "key", "updateSiblingKeys", "_replaceWith", "_traverseFlags", "SHOULD_SKIP", "REMOVED", "parent", "getCachedPaths", "hub", "delete", "removed", "buildCodeFrameError", "_cache", "require", "_hoister", "_index", "_context", "_removal", "_t", "arrowFunctionExpression", "assertExpression", "assignmentExpression", "blockStatement", "callExpression", "cloneNode", "expressionStatement", "isAssignmentExpression", "isCallExpression", "isExportNamedDeclaration", "isExpression", "isIdentifier", "isSequenceExpression", "isSuper", "thisExpression", "insertBefore", "nodes_", "_assertUnremoved", "call", "nodes", "_verifyNodeList", "parentPath", "parent", "isExpressionStatement", "isLabeledStatement", "isExportDefaultDeclaration", "isDeclaration", "isNodeType", "isJSXElement", "isForStatement", "key", "node", "push", "replaceExpressionWithStatements", "Array", "isArray", "container", "_containerInsertBefore", "isStatementOrBlock", "shouldInsertCurrentNode", "expression", "replaceWith", "unshiftContainer", "Error", "_containerInsert", "from", "updateSiblingKeys", "length", "paths", "splice", "i", "_this$context", "to", "path", "getSibling", "context", "queue", "pushContext", "contexts", "_getQueueContexts", "setScope", "debug", "maybeQueue", "_containerInsertAfter", "last", "arr", "isHiddenInSequenceExpression", "expressions", "isAlmostConstantAssignment", "scope", "left", "blockScope", "getBlockParent", "hasOwnBinding", "name", "getOwnBinding", "constantViolations", "insertAfter", "get", "map", "self", "isPattern", "unshift", "callee", "isPure", "isMethod", "computed", "temp", "generateDeclaredUidIdentifier", "pushContainer", "fromIndex", "incrementBy", "getCachedPaths", "hub", "msg", "type", "NodePath", "listKey", "setContext", "verifiedNodes", "replaceWithMultiple", "exports", "hoist", "hoister", "PathHoister", "run", "_codeFrame", "require", "_index", "_index2", "_cache", "_modification", "_parser", "_t", "_context", "FUNCTION_TYPES", "arrowFunctionExpression", "assignmentExpression", "awaitExpression", "blockStatement", "buildUndefinedNode", "callExpression", "cloneNode", "conditionalExpression", "expressionStatement", "getBindingIdentifiers", "identifier", "inheritLeadingComments", "inheritTrailingComments", "inheritsComments", "isBlockStatement", "isEmptyStatement", "isExpression", "isExpressionStatement", "isIfStatement", "isProgram", "isStatement", "isVariableDeclaration", "removeComments", "returnStatement", "sequenceExpression", "validate", "yieldExpression", "replaceWithMultiple", "nodes", "_getCachedPaths", "resync", "call", "_verifyNodeList", "node", "length", "getCachedPaths", "hub", "parent", "delete", "container", "key", "paths", "insertAfter", "requeue", "remove", "replaceWithSourceString", "replacement", "ast", "parse", "err", "loc", "message", "codeFrameColumns", "start", "line", "column", "code", "expressionAST", "program", "body", "expression", "traverse", "removeProperties", "replaceWith", "replacementPath", "removed", "Error", "NodePath", "Array", "isArray", "nodePath", "isNodeType", "canHaveVariableDeclarationOrExpression", "canSwapBetweenExpressionAndStatement", "parentPath", "isExportDefaultDeclaration", "replaceExpressionWithStatements", "oldNode", "_replaceWith", "type", "setScope", "get", "_getCachedPaths2", "ReferenceError", "inList", "debug", "set", "declars", "nodesAsSingleExpression", "gatherSequenceExpressions", "id", "scope", "push", "functionParent", "getFunctionParent", "isParentAsync", "async", "isParentGenerator", "generator", "callee", "hoistVariables", "completionRecords", "getCompletionRecords", "path", "loop", "findParent", "isLoop", "uid", "getData", "generateDeclaredUidIdentifier", "pushContainer", "setData", "name", "arrowFunctionToExpression", "newCallee", "needToAwaitFunction", "hasType", "needToYieldFunction", "exprs", "ensureLastUndefined", "kind", "declar", "declarations", "bindings", "Object", "keys", "init", "consequent", "alternate", "test", "indexOf", "replaceInline", "_containerInsertAfter", "VALID_OBJECT_CALLEES", "VALID_IDENTIFIER_CALLEES", "INVALID_METHODS", "isValidObjectCallee", "val", "includes", "isValidIdentifierCallee", "isInvalidMethod", "evaluateTruthy", "res", "evaluate", "confident", "value", "deopt", "path", "state", "deoptPath", "Globals", "Map", "undefined", "Infinity", "NaN", "evaluateCached", "node", "seen", "has", "existing", "get", "resolved", "item", "set", "_evaluate", "isSequenceExpression", "exprs", "length", "isStringLiteral", "isNumericLiteral", "isBooleanLiteral", "isNullLiteral", "isTemplateLiteral", "evaluateQuasis", "quasis", "isTaggedTemplateExpression", "isMemberExpression", "object", "name", "property", "isIdentifier", "scope", "getBinding", "quasi", "isConditionalExpression", "testResult", "isExpressionWrapper", "parentPath", "isCallExpression", "callee", "isLiteral", "type", "key", "computed", "isReferencedIdentifier", "binding", "constantViolations", "start", "end", "hasValue", "resolve", "isUnaryExpression", "prefix", "operator", "argument", "isFunction", "isClass", "arg", "isArrayExpression", "arr", "elems", "elem", "elemValue", "push", "isObjectExpression", "obj", "props", "prop", "isObjectMethod", "isSpreadElement", "keyPath", "valuePath", "isLogicalExpression", "wasConfident", "left", "leftConfident", "right", "rightConfident", "isBinaryExpression", "Math", "pow", "context", "func", "global", "hasOwnProperty", "call", "args", "map", "apply", "raw", "str", "i", "cooked", "expr", "String", "_t", "require", "assertExpressionStatement", "makeStatementFormatter", "fn", "code", "str", "validate", "unwrap", "ast", "program", "body", "slice", "smart", "exports", "length", "statements", "statement", "Error", "expression", "start", "stmt", "merge", "a", "b", "placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders", "parser", "Object", "assign", "validate", "opts", "Error", "_ref", "_objectWithoutPropertiesLoose", "_excluded", "Set", "RegExp", "undefined", "normalizeReplacements", "replacements", "Array", "isArray", "reduce", "acc", "replacement", "i", "_t", "require", "_parser", "_codeFrame", "isCallExpression", "isExpressionStatement", "isFunction", "isIdentifier", "isJSXIdentifier", "isNewExpression", "isPlaceholder", "isStatement", "isStringLiteral", "removePropertiesDeep", "traverse", "PATTERN", "parseAndBuildMetadata", "formatter", "code", "opts", "placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders", "ast", "parseWithCodeFrame", "parser", "validate", "state", "syntactic", "placeholders", "placeholderNames", "Set", "legacy", "placeholderVisitorHandler", "Object", "assign", "length", "node", "ancestors", "_state$placeholderWhi", "name", "hasSyntacticPlaceholders", "Error", "value", "test", "has", "slice", "parent", "key", "type", "expectedNode", "push", "resolve", "resolveAncestors", "isDuplicate", "add", "i", "index", "undefined", "parserOpts", "plugins", "allowReturnOutsideFunction", "allowSuperOutsideMethod", "sourceType", "parse", "err", "loc", "message", "codeFrameColumns", "start", "_t", "require", "blockStatement", "cloneNode", "emptyStatement", "expressionStatement", "identifier", "isStatement", "isStringLiteral", "stringLiteral", "validate", "populatePlaceholders", "metadata", "replacements", "ast", "placeholders", "forEach", "placeholder", "hasOwnProperty", "call", "name", "placeholderName", "Error", "Object", "keys", "key", "placeholderNames", "has", "slice", "reverse", "applyReplacement", "e", "message", "replacement", "isDuplicate", "Array", "isArray", "map", "node", "parent", "index", "resolve", "type", "undefined", "set", "value", "typeAnnotation", "optional", "decorators", "items", "splice", "_options", "require", "_parse", "_populate", "stringTemplate", "formatter", "code", "opts", "metadata", "arg", "replacements", "normalizeReplacements", "parseAndBuildMetadata", "unwrap", "populatePlaceholders", "_options", "require", "_parse", "_populate", "literalTemplate", "formatter", "tpl", "opts", "metadata", "names", "buildLiteralData", "arg", "defaultReplacements", "forEach", "replacement", "i", "replacements", "normalizeReplacements", "Object", "keys", "key", "hasOwnProperty", "call", "Error", "unwrap", "populatePlaceholders", "assign", "prefix", "raw", "join", "includes", "code", "buildTemplateCode", "parseAndBuildMetadata", "parser", "placeholderWhitelist", "Set", "concat", "Array", "from", "placeholderPattern", "preserveComments", "syntacticPlaceholders", "length", "value", "push", "_options", "require", "_string", "_literal", "NO_PLACEHOLDER", "validate", "placeholderPattern", "createTemplateBuilder", "formatter", "defaultOpts", "templateFnCache", "WeakMap", "templateAstCache", "cachedOpts", "Object", "assign", "tpl", "args", "length", "Error", "extendedTrace", "stringTemplate", "merge", "Array", "isArray", "builder", "get", "literalTemplate", "set", "ast", "fn", "rootStack", "error", "stack", "split", "slice", "join", "arg", "err", "formatters", "require", "_builder", "smart", "exports", "createTemplateBuilder", "statement", "statements", "expression", "program", "_default", "default", "Object", "assign", "bind", "undefined", "ast", "_t", "require", "_template", "_visitors", "_context", "arrowFunctionExpression", "assignmentExpression", "binaryExpression", "blockStatement", "callExpression", "conditionalExpression", "expressionStatement", "identifier", "isIdentifier", "jsxIdentifier", "logicalExpression", "LOGICAL_OPERATORS", "memberExpression", "metaProperty", "numericLiteral", "objectExpression", "restElement", "returnStatement", "sequenceExpression", "spreadElement", "stringLiteral", "super", "_super", "thisExpression", "toExpression", "unaryExpression", "toBindingIdentifierName", "isFunction", "isAssignmentPattern", "isRestElement", "getFunctionName", "cloneNode", "variableDeclaration", "variableDeclarator", "exportNamedDeclaration", "exportSpecifier", "inherits", "toComputedKey", "key", "isMemberExpression", "node", "property", "isProperty", "isMethod", "ReferenceError", "computed", "name", "ensureBlock", "body", "get", "bodyNode", "Array", "isArray", "Error", "isBlockStatement", "statements", "stringPath", "listKey", "isStatement", "push", "parentPath", "setup", "call", "exports", "arrowFunctionToShadowed", "isArrowFunctionExpression", "arrowFunctionToExpression", "unwrapFunctionEnvironment", "isFunctionExpression", "isFunctionDeclaration", "buildCodeFrameError", "hoistFunctionEnvironment", "setType", "path", "type", "allowInsertArrow", "allowInsertArrowWithRest", "noNewArrows", "_arguments$", "arguments", "specCompliant", "self", "_self$ensureFunctionN", "ensureFunctionName", "thisBinding", "fnPath", "fn", "checkBinding", "scope", "generateUidIdentifier", "id", "init", "unshiftContainer", "hub", "addHelper", "replaceWith", "getSuperCallsVisitor", "environmentVisitor", "CallExpression", "child", "allSuperCalls", "isSuper", "arrowParent", "thisEnvFn", "findParent", "p", "_arrowParent", "isProgram", "isClassProperty", "static", "isClassPrivateProperty", "inConstructor", "isClassMethod", "kind", "thisPaths", "argumentsPaths", "newTargetPaths", "superProps", "superCalls", "getScopeInformation", "length", "traverse", "superBinding", "getSuperBinding", "forEach", "superCall", "callee", "loc", "argumentsBinding", "getBinding", "args", "buildUndefinedNode", "argumentsChild", "argsRef", "newTargetBinding", "targetChild", "targetRef", "flatSuperProps", "reduce", "acc", "superProp", "concat", "standardizeSuperProperty", "superParentPath", "isAssignment", "isAssignmentExpression", "left", "isCall", "isCallExpression", "isTaggedTemplate", "isTaggedTemplateExpression", "tag", "getSuperPropBinding", "value", "right", "getThisBinding", "hasSuperClass", "thisChild", "thisRef", "isJSX", "isLogicalOp", "op", "includes", "operator", "assignmentPath", "slice", "isLogicalAssignment", "tmp", "generateDeclaredUidIdentifier", "object", "rightExpression", "isUpdateExpression", "updateExpr", "computedKey", "parts", "prefix", "superClass", "assignSuperThisVisitor", "supers", "has", "add", "replaceWithMultiple", "WeakSet", "argsBinding", "propName", "argsList", "fnBody", "method", "unshift", "valueIdent", "cacheKey", "data", "getData", "setData", "getScopeInformationVisitor", "ThisExpression", "JSXIdentifier", "isJSXMemberExpression", "isJSXOpeningElement", "MemberExpression", "Identifier", "isReferencedIdentifier", "curr", "hasOwnBinding", "rename", "parent", "MetaProperty", "splitExportDeclaration", "isExportDeclaration", "isExportAllDeclaration", "isExportNamedDeclaration", "declaration", "isExportDefaultDeclaration", "standaloneDeclaration", "isClassDeclaration", "exportExpr", "isClassExpression", "isScope", "needBindingRegistration", "hasBinding", "updatedDeclaration", "updatedExportDeclaration", "insertAfter", "registerDeclaration", "bindingIdentifiers", "getOuterBindingIdentifiers", "specifiers", "Object", "keys", "map", "aliasDeclar", "refersOuterBindingVisitor", "state", "needsRename", "stop", "Scope", "skip", "supportUnicodeId", "res", "test", "startsWith", "replace", "originalNode", "binding", "getOwnBinding", "hasGlobal", "getProgramParent", "references", "params", "i", "len", "getFunctionArity", "template", "expression", "ast", "count", "findIndex", "param", "_t", "require", "STATEMENT_OR_BLOCK_KEYS", "VISITOR_KEYS", "isBlockStatement", "isExpression", "isIdentifier", "isLiteral", "isStringLiteral", "isType", "matchesPattern", "_matchesPattern", "pattern", "allowPartial", "node", "exports", "has", "key", "_this$node", "val", "Array", "isArray", "length", "isStatic", "scope", "is", "isnt", "equals", "value", "isNodeType", "type", "canHaveVariableDeclarationOrExpression", "parentPath", "isFor", "canSwapBetweenExpressionAndStatement", "replacement", "isArrowFunctionExpression", "isCompletionRecord", "allowInsideFunction", "path", "first", "container", "isFunction", "isProgram", "isDoExpression", "isStatementOrBlock", "isLabeledStatement", "includes", "referencesImport", "moduleSource", "importName", "isReferencedIdentifier", "isJSXMemberExpression", "property", "name", "isMemberExpression", "isOptionalMemberExpression", "computed", "object", "get", "binding", "getBinding", "kind", "parent", "isImportDeclaration", "source", "isImportDefaultSpecifier", "isImportNamespaceSpecifier", "isImportSpecifier", "imported", "getSource", "end", "code", "hub", "getCode", "slice", "start", "willIMaybeExecuteBefore", "target", "_guessExecutionStatusRelativeTo", "getOuterFunction", "getFunctionParent", "getProgramParent", "isExecutionUncertain", "isExecutionUncertainInList", "paths", "maxIndex", "i", "parentKey", "SYMBOL_CHECKING", "Symbol", "_guessExecutionStatusRelativeToCached", "Map", "base", "cache", "funcParent", "this", "_guessExecutionStatusRelativeToDifferentFunctionsCached", "getAncestry", "commonPath", "commonIndex", "indexOf", "Error", "divergence", "listKey", "keys", "keyPosition", "_guessExecutionStatusRelativeToDifferentFunctionsInternal", "isFunctionDeclaration", "isExportDeclaration", "id", "references", "referencePaths", "allStatus", "childOfFunction", "find", "isCallExpression", "status", "nodeMap", "cached", "set", "result", "resolve", "dangerous", "resolved", "_resolve", "call", "_resolved", "push", "isVariableDeclarator", "constant", "ret", "isTypeCastExpression", "targetKey", "toComputedKey", "targetName", "isObjectExpression", "props", "prop", "isProperty", "match", "isArrayExpression", "isNaN", "elems", "elem", "isConstantExpression", "isRegExpLiteral", "isTemplateLiteral", "every", "expression", "isUnaryExpression", "operator", "isBinaryExpression", "hasBinding", "noGlobals", "arguments", "isInStrictMode", "strictParent", "sourceType", "isClass", "body", "directive", "directives", "_index", "require", "_t", "getAssignmentIdentifiers", "_getAssignmentIdentifiers", "getBindingIdentifiers", "_getBindingIdentifiers", "getOuterBindingIdentifiers", "_getOuterBindingIdentifiers", "numericLiteral", "unaryExpression", "NORMAL_COMPLETION", "BREAK_COMPLETION", "NormalCompletion", "path", "type", "BreakCompletion", "getOpposite", "key", "getSibling", "addCompletionRecords", "records", "context", "push", "_getCompletionRecords", "completionRecordForSwitch", "cases", "lastNormalCompletions", "i", "length", "casePath", "caseCompletions", "normalCompletions", "breakCompletions", "c", "normalCompletionToBreak", "completions", "forEach", "replaceBreakStatementInBreakCompletion", "reachable", "isBreakStatement", "label", "replaceWith", "remove", "getStatementListCompletion", "paths", "canHaveBreak", "newContext", "Object", "assign", "inCaseClause", "isBlockStatement", "shouldPopulateBreak", "statementCompletions", "every", "some", "isDeclaration", "pathCompletions", "isVariableDeclaration", "isIfStatement", "get", "isDoExpression", "isFor", "isWhile", "isLabeledStatement", "isProgram", "isFunction", "isTryStatement", "isCatchClause", "isSwitchStatement", "isSwitchCase", "getCompletionRecords", "map", "r", "NodePath", "parentPath", "parent", "container", "listKey", "setContext", "getPrevSibling", "getNextSibling", "getAllNextSiblings", "_key", "sibling", "siblings", "node", "getAllPrevSiblings", "parts", "split", "_getKey", "call", "_getPattern", "Array", "isArray", "_", "part", "duplicates", "getBindingIdentifierPaths", "outerOnly", "search", "ids", "create", "id", "shift", "keys", "isIdentifier", "_ids", "name", "isExportDeclaration", "declaration", "isFunctionDeclaration", "isFunctionExpression", "child", "getOuterBindingIdentifierPaths", "_t", "require", "addComment", "_addComment", "addComments", "_addComments", "shareCommentsWithSiblings", "key", "node", "trailing", "trailingComments", "leading", "leadingComments", "prev", "getSibling", "next", "hasPrev", "Boolean", "hasNext", "removeIfExisting", "list", "toRemove", "length", "set", "Set", "filter", "el", "has", "type", "content", "line", "comments", "virtualTypes", "require", "_debug", "_index", "_index2", "_t", "t", "cache", "_generator", "NodePath_ancestry", "NodePath_inference", "NodePath_replacement", "NodePath_evaluation", "NodePath_conversion", "NodePath_introspection", "_context", "NodePath_context", "NodePath_removal", "NodePath_modification", "NodePath_family", "NodePath_comments", "NodePath_virtual_types_validator", "validate", "debug", "buildDebug", "REMOVED", "exports", "SHOULD_STOP", "SHOULD_SKIP", "NodePath_Final", "default", "NodePath", "constructor", "hub", "parent", "contexts", "state", "opts", "_traverseFlags", "skipKeys", "parentPath", "container", "listKey", "key", "node", "type", "data", "context", "scope", "removed", "v", "shouldStop", "shouldSkip", "get", "Error", "targetNode", "paths", "getOrCreateCachedPaths", "path", "set", "setup", "call", "getScope", "isScope", "Scope", "setData", "val", "Object", "create", "getData", "def", "undefined", "hasNode", "buildCodeFrameError", "msg", "SyntaxError", "buildError", "traverse", "visitor", "getPathLocation", "parts", "inList", "unshift", "join", "message", "enabled", "toString", "generator", "code", "parentKey", "methods", "findParent", "find", "getFunctionParent", "getStatementParent", "getEarliestCommonAncestorFrom", "getDeepestCommonAncestorFrom", "getAncestry", "isAncestor", "isDescendant", "inType", "getTypeAnnotation", "isBaseType", "couldBeBaseType", "baseTypeStrictlyMatches", "isGenericType", "replaceWithMultiple", "replaceWithSourceString", "replaceWith", "replaceExpressionWithStatements", "replaceInline", "evaluateTruthy", "evaluate", "toComputedKey", "ensureBlock", "unwrapFunctionEnvironment", "arrowFunctionToExpression", "splitExportDeclaration", "ensureFunctionName", "matchesPattern", "isStatic", "isNodeType", "canHaveVariableDeclarationOrExpression", "canSwapBetweenExpressionAndStatement", "isCompletionRecord", "isStatementOrBlock", "referencesImport", "getSource", "willIMaybeExecuteBefore", "_guessExecutionStatusRelativeTo", "resolve", "isConstantExpression", "isInStrictMode", "isDenylisted", "visit", "skip", "skipKey", "stop", "setContext", "requeue", "requeueComputedKeyAndDecorators", "remove", "insertBefore", "insertAfter", "unshiftContainer", "pushContainer", "getOpposite", "getCompletionRecords", "getSibling", "getPrevSibling", "getNextSibling", "getAllNextSiblings", "getAllPrevSiblings", "getAssignmentIdentifiers", "getBindingIdentifiers", "getOuterBindingIdentifiers", "getBindingIdentifierPaths", "getOuterBindingIdentifierPaths", "shareCommentsWithSiblings", "addComment", "addComments", "assign", "prototype", "arrowFunctionToShadowed", "String", "has", "is", "isnt", "equals", "hoist", "updateSiblingKeys", "isBlacklisted", "setScope", "resync", "popContext", "pushContext", "setKey", "_guessExecutionStatusRelativeToDifferentFunctions", "_getTypeAnnotation", "_replaceWith", "_resolve", "_call", "_resyncParent", "_resyncKey", "_resyncList", "_resyncRemoved", "_getQueueContexts", "_removeFromScope", "_callRemovalHooks", "_remove", "_markRemoved", "_assertUnremoved", "_containerInsert", "_containerInsertBefore", "_containerInsertAfter", "_verifyNodeList", "_getKey", "_getPattern", "TYPES", "typeKey", "fn", "TypeError", "keys", "includes", "push", "_index", "require", "_t", "_context", "VISITOR_KEYS", "TraversalContext", "constructor", "scope", "opts", "state", "parentPath", "queue", "priorityQueue", "shouldVisit", "node", "enter", "exit", "type", "keys", "length", "key", "create", "container", "listKey", "NodePath", "get", "parent", "maybeQueue", "path", "notPriority", "push", "visitMultiple", "visitQueue", "visitSingle", "visited", "WeakSet", "stop", "visitIndex", "resync", "call", "contexts", "pushContext", "has", "add", "visit", "i", "popContext", "nodes", "Array", "isArray", "exports", "default", "_context", "require", "_t", "VISITOR_KEYS", "traverseNode", "node", "opts", "scope", "state", "path", "skipKeys", "visitSelf", "keys", "type", "context", "TraversalContext", "parentKey", "visitQueue", "key", "visit", "_traverseNode", "require", "_index", "_removal", "t", "call", "key", "opts", "debug", "node", "_call", "_opts$this$node$type", "type", "fns", "fn", "ret", "state", "then", "Error", "_traverseFlags", "isDenylisted", "_this$opts$denylist", "denylist", "blacklist", "includes", "exports", "isBlacklisted", "restoreContext", "path", "context", "visit", "_this$opts$shouldSkip", "_this$opts", "shouldSkip", "currentContext", "shouldStop", "traverseNode", "scope", "skipKeys", "skip", "skipKey", "stop", "SHOULD_SKIP", "SHOULD_STOP", "setScope", "_this$opts2", "_this$scope", "noScope", "parentPath", "listKey", "isMethod", "isSwitchStatement", "target", "_path$opts", "getScope", "init", "setContext", "resync", "removed", "_resyncParent", "_resyncList", "_resyncKey", "parent", "container", "Array", "isArray", "i", "length", "setKey", "Object", "keys", "inList", "newContainer", "_resyncRemoved", "_markRemoved", "popContext", "contexts", "pop", "undefined", "pushContext", "push", "setup", "_this$node", "requeue", "pathToQueue", "maybeQueue", "requeueComputedKeyAndDecorators", "isPrivate", "computed", "get", "decorators", "decorator", "_getQueueContexts", "Hub", "getCode", "getScope", "addHelper", "Error", "buildError", "node", "msg", "TypeError", "exports", "default", "require", "visitors", "exports", "_t", "cache", "_traverseNode", "_index", "_index2", "_hub", "VISITOR_KEYS", "removeProperties", "traverseFast", "traverse", "parent", "opts", "scope", "state", "parentPath", "visitSelf", "noScope", "type", "Error", "explode", "traverseNode", "_default", "default", "verify", "cheap", "node", "enter", "path", "skipKeys", "clearNode", "tree", "hasDenylistedType", "has", "stop", "hasType", "denylistTypes", "includes", "denylist"]
}
